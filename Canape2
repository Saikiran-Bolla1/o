import win32com.client
import time
import array
import threading
from contextlib import contextmanager
from typing import Dict, List, Optional, Tuple, Union, Any

# ---------------------------
# Helpers
# ---------------------------

def dispatch_canape():
    try:
        return win32com.client.Dispatch('CANape.Application')
    except Exception:
        return win32com.client.Dispatch('CAMape.Application')


# ---------------------------
# Core variable object (bound to a specific device)
# ---------------------------

class CanapeVariable:
    """
    Represents a calibration/measurement object on a specific CANape device.

    Create directly from the session using longname "Device:Var":
      var1 = session["DeviceA:VarX"]

    Then use only the variable:
      print(var1.value)
      var1.value = 42

    Note: COM access is device-specific:
      self._dev.CalibrationObjects(Var)  # we do NOT use "Device:Var" here
    """
    def __init__(self, app, device_com, device_name: str, varname: str):
        self._app = app
        self._dev = device_com
        self.device_name = device_name
        self.varname = varname  # name in the device's A2L (no "Device:" prefix)
        self.longname = f"{device_name}:{varname}"

    def __repr__(self):
        return f"<CanapeVariable {self.longname}>"

    @property
    def value(self):
        # Access via device-specific CalibrationObjects, not "Device:Var"
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, val):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Value = val
        obj.Write()


# ---------------------------
# Multi-device recorder implementation
# ---------------------------

class _DeviceRecorderWorker:
    """
    Background collector for one device/task. Collects values per CanapeVariable.
    """
    def __init__(self, task, vars_for_device: List[CanapeVariable], values_store: Dict[CanapeVariable, List], ts_store: Dict[CanapeVariable, List]):
        self._task = task
        self._vars = vars_for_device
        self._values_store = values_store
        self._ts_store = ts_store
        self._stop_evt = threading.Event()
        name = vars_for_device[0].device_name if vars_for_device else 'dev'
        self._thread = threading.Thread(target=self._run, name=f"CANapeRecorder-{name}", daemon=True)

        # Build index map from task channel order to variables
        try:
            channel_names = [ch.Name for ch in task.Channels]
        except Exception:
            channel_names = []
        self._idx_map: List[Tuple[int, CanapeVariable]] = []
        for v in self._vars:
            idx = -1
            try:
                idx = channel_names.index(v.varname)
            except ValueError:
                pass
            if idx >= 0:
                self._idx_map.append((idx, v))

    def start(self):
        self._thread.start()

    def stop_and_drain(self, timeout: float = 5.0):
        self._stop_evt.set()
        self._thread.join(timeout=timeout)
        self._drain_remaining()

    def _run(self):
        # Pull samples until stopped
        while not self._stop_evt.is_set():
            if not self._pull_one():
                time.sleep(0.001)

    def _pull_one(self) -> bool:
        try:
            sample = self._task.NextSample()
        except Exception:
            sample = None
        if not sample:
            return False
        y_vals, ts = sample[0], sample[1]
        for idx, var in self._idx_map:
            if idx < len(y_vals):
                self._values_store[var].append(y_vals[idx])
                self._ts_store[var].append(ts)
        return True

    def _drain_remaining(self):
        while self._pull_one():
            pass


class GlobalRecorderContext:
    """
    Context returned by session.recorder(...).
    Data is only available AFTER the 'with' block ends.

    Access:
      vals = rec[var_obj]
      ts_list = rec.get_timestamps(var_obj)
    """
    def __init__(self, workers: List[_DeviceRecorderWorker], added_per_device: Dict[str, List[str]], task_per_device: Dict[str, Any], app):
        self._workers = workers
        self._added_per_device = added_per_device
        self._task_per_device = task_per_device
        self._app = app

        self._closed = False
        self._values: Dict[CanapeVariable, List] = {}
        self._timestamps: Dict[CanapeVariable, List] = {}

    def _attach_stores(self, values_store: Dict[CanapeVariable, List], ts_store: Dict[CanapeVariable, List]):
        # Called by the recorder to give us the shared stores
        self._values = values_store
        self._timestamps = ts_store

    def start(self):
        for w in self._workers:
            w.start()

    def finalize(self):
        # Stop measurement first so no more data comes in
        try:
            self._app.Measurement.Stop()
        except Exception:
            pass

        # Finalize workers
        for w in self._workers:
            w.stop_and_drain()

        # Cleanup channels
        for devname, task in self._task_per_device.items():
            for ch_name in self._added_per_device.get(devname, []):
                try:
                    task.Channels.Remove(ch_name)
                except Exception:
                    pass

        self._closed = True

    def __getitem__(self, var: CanapeVariable):
        if not isinstance(var, CanapeVariable):
            raise TypeError("Use the declared CanapeVariable object as key, e.g., rec[var_obj].")
        if not self._closed:
            raise RuntimeError("Recorded values are available only after recording has stopped.")
        return self._values.get(var, [])

    def get_timestamps(self, var: CanapeVariable) -> List[float]:
        if not self._closed:
            raise RuntimeError("Timestamps are available only after recording has stopped.")
        return self._timestamps.get(var, [])


# ---------------------------
# Device wrapper and Session
# ---------------------------

class CanapeDevice:
    def __init__(self, app, device_com, name: str):
        self.app = app
        self.dev = device_com
        self.name = name

    # Optional low-level helpers
    def read_memory(self, addr: int, size: int):
        val = self.dev.ReadMemory(addr, size)
        print(f"[READ] Memory {addr}: {''.join('%02x' % b for b in val)}")
        return val

    def write_memory(self, addr: int, data):
        self.dev.WriteMemory(addr, array.array('B', data))
        print(f"[WRITE] Memory {addr}: {''.join('%02x' % b for b in data)}")


class CanapeAutomation:
    """
    Session manager with DIRECT longname access:
      var = session["Device:Var"]
      with session.recorder(var, "OtherDevice:OtherVar"): ...

    No per-device or session.canapevariable accessor required.
    """
    def __init__(self, project_path: Optional[str] = None):
        self.app = dispatch_canape()
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except Exception:
            pass

        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"

        self.app.Open2(project_path, 1, 100000, 0, 0, 1)
        time.sleep(2)

        self.devices: Dict[str, CanapeDevice] = {}
        self._var_cache: Dict[str, CanapeVariable] = {}

    def add_device(self, name: str, a2l: str, dev_type: str, channel: int) -> CanapeDevice:
        dev_com = self.app.Devices.Add(name, a2l, dev_type, channel)
        dev = CanapeDevice(self.app, dev_com, name)
        self.devices[name] = dev
        return dev

    def go_online_all(self, reconnect: bool = False):
        for dev in self.devices.values():
            try:
                dev.dev.GoOnline(reconnect)
            except Exception:
                pass

    def go_offline_all(self):
        for dev in self.devices.values():
            try:
                dev.dev.GoOffline()
            except Exception:
                pass

    def close(self):
        try:
            self.go_offline_all()
        except Exception:
            pass
        try:
            self.app.Quit()
        except Exception:
            pass

    # ------------- Direct variable access on the session -------------

    def __getitem__(self, longname: str) -> CanapeVariable:
        # Require "Device:Var"
        if ":" not in longname:
            raise ValueError('Use long name format "Device:Variable", e.g., "XCPsim:ampl".')
        devname, varname = longname.split(":", 1)
        if devname not in self.devices:
            raise KeyError(f"Device '{devname}' is not added to the session.")
        cache_key = f"{devname}:{varname}"
        if cache_key in self._var_cache:
            return self._var_cache[cache_key]
        dev_com = self.devices[devname].dev
        var = CanapeVariable(self.app, dev_com, devname, varname)
        self._var_cache[cache_key] = var
        return var

    @contextmanager
    def recorder(self, *vars_or_longnames: Union[CanapeVariable, str], task_name: str = "100ms", sampling_time: Optional[int] = 100):
        if not vars_or_longnames:
            raise TypeError("Provide at least one variable (CanapeVariable) or longname 'Device:Var'.")

        # Normalize to CanapeVariable objects
        vars_list: List[CanapeVariable] = []
        for item in vars_or_longnames:
            if isinstance(item, CanapeVariable):
                vars_list.append(item)
            elif isinstance(item, str):
                vars_list.append(self[item])
            else:
                raise TypeError("Items must be CanapeVariable or 'Device:Var' strings.")

        # Group variables by device
        by_device: Dict[str, List[CanapeVariable]] = {}
        for v in vars_list:
            by_device.setdefault(v.device_name, []).append(v)

        # Prepare tasks and channels per device
        added_per_device: Dict[str, List[str]] = {}
        task_per_device: Dict[str, Any] = {}

        for devname, dev_vars in by_device.items():
            dev_com = self.devices[devname].dev
            task = dev_com.Tasks(task_name)
            task_per_device[devname] = task

            if sampling_time is not None:
                try:
                    task.SamplingTime = int(sampling_time)
                except Exception:
                    pass

            added_names: List[str] = []
            for v in dev_vars:
                # Ensure calibration object exists
                try:
                    dev_com.CalibrationObjects.Add(v.varname)
                except Exception:
                    pass
                # Add channel by var name
                try:
                    task.Channels.Add(v.varname)
                    # Save to MDF if supported
                    try:
                        task.Channels(v.varname).Save2MDF = True
                    except Exception:
                        pass
                    added_names.append(v.varname)
                except Exception:
                    # Already present or failed; continue
                    pass

            added_per_device[devname] = added_names

        # Shared stores for all workers
        values_store: Dict[CanapeVariable, List] = {v: [] for v in vars_list}
        ts_store: Dict[CanapeVariable, List] = {v: [] for v in vars_list}

        # Build workers per device
        workers: List[_DeviceRecorderWorker] = []
        for devname, dev_vars in by_device.items():
            workers.append(_DeviceRecorderWorker(task_per_device[devname], dev_vars, values_store, ts_store))

        # Start measurement and workers
        try:
            self.app.Measurement.Start()
        except Exception:
            pass

        ctx = GlobalRecorderContext(workers, added_per_device, task_per_device, self.app)
        ctx._attach_stores(values_store, ts_store)
        ctx.start()

        try:
            yield ctx
        finally:
            # Finalize stops measurement, drains, and cleans channels
            ctx.finalize()


# ---------------------------
# Example usage (no session.canapevariable accessor)
# ---------------------------

if __name__ == "__main__":
    session = CanapeAutomation()
    session.add_device("XCPsim", "XCPsim.a2l", "XCP", 1)
    # Add more devices if needed:
    # session.add_device("XCPsim2", "XCPsim.a2l", "XCP", 2)

    session.go_online_all()

    # Declare variables directly from the session using longnames
    var_ampl = session["XCPsim:ampl"]
    var_ch1  = session["XCPsim:channel1"]

    # During recording, interact as needed
    with session.recorder(var_ampl, "XCPsim:channel1", task_name="100ms", sampling_time=100) as rec:
        print("Recording...")
        for _ in range(10):
            _ = var_ampl.value  # optional interaction
            time.sleep(0.1)

    # After recording stops, access finalized data
    ampl_values = rec[var_ampl]
    ch1_values  = rec[var_ch1]
    ampl_ts     = rec.get_timestamps(var_ampl)
    ch1_ts      = rec.get_timestamps(var_ch1)

    print(f"ampl samples: {len(ampl_values)}, channel1 samples: {len(ch1_values)}")
    if ampl_values:
        print(f"ampl first/last: {ampl_values[0]} -> {ampl_values[-1]}")
    if ch1_values:
        print(f"channel1 first/last: {ch1_values[0]} -> {ch1_values[-1]}")

    session.close()
