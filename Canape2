# Requires:
#   pip install pywin32 asammdf numpy
#
# Features:
# - Direct longname access: var = session["Device:Variable"]
# - Recording uses CANape's MF4 only (no background threads).
# - session.recorder(...) sets CANape.Measurement.MDFFilename to your path and reads the same file.
# - After the with-block:
#     V = rec[var]  or  V = rec["Device:Variable"]
#     V.x -> timestamps (numpy array)
#     V.y -> values (numpy array)
#     V.name -> "Device:Variable" when resolvable (else raw MF4 name)
#     V.data -> ((x0,y0), ..., (xn,yn))
# - rec.signals -> list of all recorded signal names (as provided to the recorder)
# - rec.values() -> list of objects having name, x, y, data
# - Enum/text signals are converted to numeric whenever possible.
#
# Vector driver support (optional):
# - vector_signals: list of "Device:Signal" or CanapeVariable
# - vector_task: task name for vector signals (default "cyclic")
# - vector_sampling_time: sampling time (ms) for vector_task
#
# Important: This version reads PHYSICAL values by default (matches CANape UI).
#            Set prefer_raw=True in recorder(...) to read RAW samples instead.

import os
import time
import win32com.client
import numpy as np
from datetime import datetime
from contextlib import contextmanager
from typing import Dict, List, Optional, Union, Any, Tuple, Iterable

from asammdf import MDF, Signal


def _dispatch_canape():
    try:
        return win32com.client.Dispatch("CANape.Application")
    except Exception:
        return win32com.client.Dispatch("CAMape.Application")


def _ensure_parent_dir(path: str):
    parent = os.path.dirname(os.path.abspath(path))
    if parent and not os.path.exists(parent):
        os.makedirs(parent, exist_ok=True)


def _wait_for_file_stable(path: str, timeout_s: float = 20.0, poll_s: float = 0.25) -> bool:
    end = time.time() + timeout_s
    last = -1
    seen = False
    while time.time() < end:
        if os.path.exists(path):
            size = os.path.getsize(path)
            if seen and size == last and size > 0:
                return True
            last = size
            seen = True
        time.sleep(poll_s)
    return os.path.exists(path)


class CanapeVariable:
    def __init__(self, app, device_com, device_name: str, varname: str):
        self._app = app
        self._dev = device_com
        self.device_name = device_name
        self.varname = varname
        self.longname = f"{device_name}:{varname}"

    @property
    def value(self):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, val):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Value = val
        obj.Write()

    def __repr__(self):
        return f"<CanapeVariable {self.longname}>"


class VectorSignalRef:
    def __init__(self, device_name: str, signal_name: str):
        self.device_name = device_name
        self.signal_name = signal_name

    @property
    def longname(self) -> str:
        return f"{self.device_name}:{self.signal_name}"

    def __repr__(self):
        return f"<VectorSignal {self.longname}>"


def _get_signal_preferred(mdf: MDF, name: str, prefer_raw: bool = False) -> Signal:
    """
    Return Signal from MDF, preferring PHYSICAL (converted) values by default.
    Set prefer_raw=True to force RAW (unconverted) samples.
    """
    if prefer_raw:
        try:
            return mdf.get(name, raw=True)
        except Exception:
            # Fallback to physical if RAW not available
            return mdf.get(name)
    else:
        try:
            return mdf.get(name)  # physical/converted
        except Exception:
            # Fallback to raw if physical retrieval fails
            return mdf.get(name, raw=True)


def _maybe_text_to_raw(samples: np.ndarray, signal: Signal) -> np.ndarray:
    # If already numeric, return as-is
    if hasattr(samples, "dtype") and samples.dtype.kind in ("i", "u", "f", "b"):
        return samples

    # Try to invert enum/text mapping using conversion object
    conv = getattr(signal, "conversion", None)
    if conv is not None:
        for attr in ("text_2_value", "text2value", "text_to_value", "value_map", "val_map"):
            mapping = getattr(conv, attr, None)
            if mapping:
                def map_one(s):
                    if s in mapping:
                        return mapping[s]
                    if isinstance(s, (bytes, bytearray)):
                        try:
                            s2 = s.decode(errors="ignore")
                            if s2 in mapping:
                                return mapping[s2]
                        except Exception:
                            pass
                    try:
                        return float(s)
                    except Exception:
                        return np.nan
                return np.array([map_one(s) for s in samples], dtype=float)

    try:
        return samples.astype(float)
    except Exception:
        return samples


class _SignalView:
    def __init__(self, signal: Signal, display_name: Optional[str] = None, force_raw_text_to_numeric: bool = True):
        self._sig = signal
        self._name = display_name or signal.name

        xs = signal.timestamps
        ys = signal.samples

        # Convert enum/text to numeric if needed
        if force_raw_text_to_numeric and (hasattr(ys, "dtype") and ys.dtype.kind in ("O", "U", "S")):
            ys = _maybe_text_to_raw(ys, signal)

        self._x = np.asarray(xs)
        self._y = np.asarray(ys)

    @property
    def x(self):
        return self._x

    @property
    def y(self):
        return self._y

    @property
    def name(self) -> str:
        return self._name

    @property
    def data(self) -> Tuple[Tuple[float, float], ...]:
        n = min(len(self._x), len(self._y))
        return tuple((float(self._x[i]), float(self._y[i])) for i in range(n))

    def __repr__(self):
        return f"<SignalView name={self._name!r} len={len(self._x)}>"


class RecorderResult:
    """
    Created by session.recorder(...). Finalized AFTER the with-block.
    Data source: the MF4 file written by CANape.

    Shortcuts:
      - rec.signals  -> list of recorded signal names (preserve recorder order)
      - rec.values() -> list of per-signal objects each having name, x, y, data
    """
    def __init__(
        self,
        app,
        cleanup_items: List[Tuple[Any, str]],  # (task_com_object, channel_name)
        var_list: List[CanapeVariable],
        vector_refs: List[VectorSignalRef],
        mdf_path: str,
        prefer_raw: bool = False,
    ):
        self._app = app
        self._cleanup_items = cleanup_items
        self._vars = var_list
        self._vectors = vector_refs
        self.filepath = os.path.abspath(mdf_path)
        self._prefer_raw = prefer_raw

        self._mdf: Optional[MDF] = None
        self._views_by_var: Dict[CanapeVariable, _SignalView] = {}
        self._views_by_name: Dict[str, _SignalView] = {}
        self._ordered_names: List[str] = []  # keep order consistent with input

    def _resolve_signal(self, mdf: MDF, expected_long: str, tail: str, names: List[str]) -> Optional[Signal]:
        # 1) Try exact long name
        try:
            return _get_signal_preferred(mdf, expected_long, prefer_raw=self._prefer_raw)
        except Exception:
            pass
        # 2) Try exact tail
        try:
            return _get_signal_preferred(mdf, tail, prefer_raw=self._prefer_raw)
        except Exception:
            pass
        # 3) Case-insensitive exact match
        lower = {n.lower(): n for n in names}
        for cand in (expected_long, tail):
            n = lower.get(cand.lower())
            if n:
                try:
                    return _get_signal_preferred(mdf, n, prefer_raw=self._prefer_raw)
                except Exception:
                    pass
        # 4) Unique suffix ":Var" or ".Var"
        for sep in (":", "."):
            suffix = f"{sep}{tail}"
            matches = [n for n in names if n.endswith(suffix)]
            if len(matches) == 1:
                try:
                    return _get_signal_preferred(mdf, matches[0], prefer_raw=self._prefer_raw)
                except Exception:
                    pass
        return None

    def _load_views(self):
        self._mdf = MDF(self.filepath)
        try:
            names = list(self._mdf.get_channel_names())
        except Exception:
            names = []

        # Calibration variables
        for v in self._vars:
            sig = self._resolve_signal(self._mdf, v.longname, v.varname, names)
            if sig is not None:
                view = _SignalView(sig, display_name=v.longname)
                self._views_by_var[v] = view
                self._views_by_name[v.longname] = view
                self._ordered_names.append(v.longname)

        # Vector driver signals
        for ref in self._vectors:
            expected_long = ref.longname
            sig = self._resolve_signal(self._mdf, expected_long, ref.signal_name, names)
            if sig is not None:
                view = _SignalView(sig, display_name=expected_long)
                self._views_by_name[expected_long] = view
                self._ordered_names.append(expected_long)

        # Also allow access by raw MDF names (in case user queries by that)
        for n in names:
            if n not in self._views_by_name:
                try:
                    sig = _get_signal_preferred(self._mdf, n, prefer_raw=self._prefer_raw)
                    self._views_by_name[n] = _SignalView(sig, display_name=n)
                except Exception:
                    continue

    def finalize(self):
        # Stop CANape measurement
        try:
            self._app.Measurement.Stop()
        except Exception:
            pass

        # Cleanup: remove channels we added
        for task_obj, ch_name in self._cleanup_items:
            try:
                task_obj.Channels.Remove(ch_name)
            except Exception:
                pass

        # Wait until MF4 appears and is stable, then load
        _wait_for_file_stable(self.filepath, timeout_s=30.0, poll_s=0.25)
        self._load_views()

    def __getitem__(self, key: Union[CanapeVariable, str]) -> _SignalView:
        if isinstance(key, CanapeVariable):
            view = self._views_by_var.get(key)
            if view is None:
                raise KeyError(f"No recorded data for {key.longname} in '{self.filepath}'")
            return view
        elif isinstance(key, str):
            if key in self._views_by_name:
                return self._views_by_name[key]
            # Tail-only lookup if unique among the recorded names
            tail = key.split(":", 1)[-1]
            matches = [n for n in self._views_by_name.keys() if n.endswith(":" + tail) or n.endswith("." + tail) or n == tail]
            if len(matches) == 1:
                return self._views_by_name[matches[0]]
            raise KeyError(f"No recorded data for '{key}' in '{self.filepath}'")
        else:
            raise TypeError("Key must be a CanapeVariable or 'Device:Variable' string.")

    @property
    def signals(self) -> List[str]:
        # Only the signals explicitly configured in this recorder (preserve order)
        return list(self._ordered_names)

    def values(self) -> List[_SignalView]:
        out: List[_SignalView] = []
        for name in self._ordered_names:
            view = self._views_by_name.get(name)
            if view is not None:
                out.append(view)
        return out

    # Backward compatible helper to get names and y-arrays only
    def y_values(self) -> List[Tuple[str, np.ndarray]]:
        out: List[Tuple[str, np.ndarray]] = []
        for name in self._ordered_names:
            view = self._views_by_name.get(name)
            if view is not None:
                out.append((name, view.y))
        return out

    def close(self):
        try:
            if self._mdf is not None:
                self._mdf.close()
        except Exception:
            pass


class CanapeDevice:
    def __init__(self, app, device_com, name: str):
        self.app = app
        self.dev = device_com
        self.name = name


class CanapeAutomation:
    def __init__(self, project_path: Optional[str] = None):
        self.app = _dispatch_canape()
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except Exception:
            pass

        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"

        self.app.Open2(project_path, 1, 100000, 0, 0, 1)
        time.sleep(2)

        self.devices: Dict[str, CanapeDevice] = {}
        self._var_cache: Dict[str, CanapeVariable] = {}

    def add_device(self, name: str, a2l: str, dev_type: str, channel: int) -> CanapeDevice:
        dev_com = self.app.Devices.Add(name, a2l, dev_type, channel)
        dev = CanapeDevice(self.app, dev_com, name)
        self.devices[name] = dev
        return dev

    def go_online_all(self, reconnect: bool = False):
        for dev in self.devices.values():
            try:
                dev.dev.GoOnline(reconnect)
            except Exception:
                pass

    def close(self):
        try:
            for dev in self.devices.values():
                try:
                    dev.dev.GoOffline()
                except Exception:
                    pass
        finally:
            try:
                self.app.Quit()
            except Exception:
                pass

    def __getitem__(self, longname: str) -> CanapeVariable:
        if ":" not in longname:
            raise ValueError('Use "Device:Variable", e.g., "XCPsim:ampl"')
        devname, varname = longname.split(":", 1)
        if devname not in self.devices:
            raise KeyError(f"Device '{devname}' is not added.")
        key = f"{devname}:{varname}"
        if key in self._var_cache:
            return self._var_cache[key]
        var = CanapeVariable(self.app, self.devices[devname].dev, devname, varname)
        self._var_cache[key] = var
        return var

    @staticmethod
    def _normalize_vector_signals(
        vector_signals: Optional[Iterable[Union[str, CanapeVariable]]]
    ) -> List[VectorSignalRef]:
        """
        Accepts strings "Device:Signal" or CanapeVariable. Returns normalized VectorSignalRef list.
        """
        out: List[VectorSignalRef] = []
        if not vector_signals:
            return out
        for item in vector_signals:
            if isinstance(item, CanapeVariable):
                out.append(VectorSignalRef(item.device_name, item.varname))
            elif isinstance(item, str):
                if ":" not in item:
                    raise ValueError(f"Invalid vector signal '{item}', expected 'Device:Signal'")
                dev, sig = item.split(":", 1)
                out.append(VectorSignalRef(dev, sig))
            else:
                raise TypeError("vector_signals entries must be 'Device:Signal' or CanapeVariable")
        return out

    @contextmanager
    def recorder(
        self,
        *signals: Union[CanapeVariable, str],
        task: str = "100ms",
        sampling_time: Optional[int] = 100,
        mdf_path: Optional[str] = None,
        vector_signals: Optional[Iterable[Union[str, CanapeVariable]]] = None,
        vector_task: str = "cyclic",
        vector_sampling_time: Optional[int] = None,
        prefer_raw: bool = False,  # set True to read raw samples from MF4
    ):
        """
        Start a measurement, add requested calibration variables into `task` (with `sampling_time`),
        and optionally add Vector driver signals into `vector_task` (with `vector_sampling_time`).
        The two groups are independent and can use different tasks/timing.

        prefer_raw: when False (default) reads PHYSICAL values (matches CANape UI);
                    when True reads RAW samples (unconverted).
        """
        if not signals and not vector_signals:
            raise TypeError("Provide at least one normal signal or vector_signals entry.")

        # Normalize normal signals -> CanapeVariable list
        var_list: List[CanapeVariable] = []
        for item in signals:
            if isinstance(item, CanapeVariable):
                var_list.append(item)
            elif isinstance(item, str):
                var_list.append(self[item])
            else:
                raise TypeError("Signals must be CanapeVariable or 'Device:Variable' strings.")

        # Normalize vector signals
        vector_refs: List[VectorSignalRef] = self._normalize_vector_signals(vector_signals)

        # Group normal vars by device
        cal_by_dev: Dict[str, List[CanapeVariable]] = {}
        for v in var_list:
            cal_by_dev.setdefault(v.device_name, []).append(v)

        # Track channels to clean up later as a simple list of tuples
        cleanup_items: List[Tuple[Any, str]] = []  # (task_com_object, channel_name)

        # Configure normal calibration variables
        for devname, dev_vars in cal_by_dev.items():
            dev_com = self.devices[devname].dev
            tsk = dev_com.Tasks(task)

            if sampling_time is not None:
                try:
                    tsk.SamplingTime = int(sampling_time)
                except Exception:
                    pass

            for v in dev_vars:
                try:
                    dev_com.CalibrationObjects.Add(v.varname)
                except Exception:
                    pass
                try:
                    tsk.Channels.Add(v.varname)
                    try:
                        tsk.Channels(v.varname).Save2MDF = True
                    except Exception:
                        pass
                    cleanup_items.append((tsk, v.varname))
                except Exception:
                    # ignore if already present or not addable
                    pass

        # Configure Vector driver signals (common task & sampling time for all)
        vec_by_dev: Dict[str, List[VectorSignalRef]] = {}
        for ref in vector_refs:
            vec_by_dev.setdefault(ref.device_name, []).append(ref)

        for devname, refs in vec_by_dev.items():
            if devname not in self.devices:
                raise KeyError(f"Vector driver device '{devname}' is not added.")
            dev_com = self.devices[devname].dev
            vtask = dev_com.Tasks(vector_task)

            if vector_sampling_time is not None:
                try:
                    vtask.SamplingTime = int(vector_sampling_time)
                except Exception:
                    pass

            for r in refs:
                try:
                    vtask.Channels.Add(r.signal_name)
                    try:
                        vtask.Channels(r.signal_name).Save2MDF = True
                    except Exception:
                        pass
                    cleanup_items.append((vtask, r.signal_name))
                except Exception:
                    # Ignore if already present or cannot be added
                    pass

        # MF4 path
        if mdf_path is None:
            stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            mdf_path = os.path.abspath(f"canape_recording_{stamp}.mf4")
        _ensure_parent_dir(mdf_path)
        try:
            self.app.Measurement.MDFFilename = mdf_path
        except Exception:
            pass

        # Start measurement
        try:
            self.app.Measurement.Start()
        except Exception:
            pass

        rec = RecorderResult(self.app, cleanup_items, var_list, vector_refs, mdf_path, prefer_raw=prefer_raw)
        try:
            yield rec
        finally:
            rec.finalize()
