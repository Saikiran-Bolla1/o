# Requires:
#   pip install pywin32 asammdf
#
# Features:
# - Direct longname access: var = session["Device:Variable"]
# - Recording uses CANape's own MF4 output (no background threads).
# - Set output path with CANape.Measurement.MDFFilename; the same path is used for reading.
# - After the with-block, access data via:
#     V = rec[var]  or  V = rec["Device:Variable"]
#     V.x -> timestamps (numpy array from asammdf)
#     V.y -> values (numpy array from asammdf)
#     V.name -> signal name ("Device:Variable" when resolvable)
#     V.data -> ((x0,y0), ..., (xn,yn))

import os
import time
import win32com.client
from datetime import datetime
from contextlib import contextmanager
from typing import Dict, List, Optional, Union, Any

from asammdf import MDF, Signal


def _dispatch_canape():
    try:
        return win32com.client.Dispatch("CANape.Application")
    except Exception:
        return win32com.client.Dispatch("CAMape.Application")


def _ensure_parent_dir(path: str):
    parent = os.path.dirname(os.path.abspath(path))
    if parent and not os.path.exists(parent):
        os.makedirs(parent, exist_ok=True)


def _wait_for_file_stable(path: str, timeout_s: float = 20.0, poll_s: float = 0.25) -> bool:
    end = time.time() + timeout_s
    last = -1
    seen = False
    while time.time() < end:
        if os.path.exists(path):
            size = os.path.getsize(path)
            if seen and size == last and size > 0:
                return True
            last = size
            seen = True
        time.sleep(poll_s)
    return os.path.exists(path)


class CanapeVariable:
    def __init__(self, app, device_com, device_name: str, varname: str):
        self._app = app
        self._dev = device_com
        self.device_name = device_name
        self.varname = varname
        self.longname = f"{device_name}:{varname}"

    @property
    def value(self):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, val):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Value = val
        obj.Write()

    def __repr__(self):
        return f"<CanapeVariable {self.longname}>"


class _SignalView:
    def __init__(self, signal: Signal, display_name: Optional[str] = None):
        self._sig = signal
        self._name = display_name or signal.name

    @property
    def x(self):
        return self._sig.timestamps

    @property
    def y(self):
        return self._sig.samples

    @property
    def name(self) -> str:
        return self._name

    @property
    def data(self):
        xs = self._sig.timestamps
        ys = self._sig.samples
        n = min(len(xs), len(ys))
        return tuple((float(xs[i]), float(ys[i])) for i in range(n))


class RecorderResult:
    """
    Created by session.recorder(...). Finalized AFTER the with-block.
    Data source: the MF4 file written by CANape.
    """
    def __init__(self, app, task_per_device: Dict[str, Any], added_per_device: Dict[str, List[str]], vars_list: List[CanapeVariable], mdf_path: str):
        self._app = app
        self._tasks = task_per_device
        self._added = added_per_device
        self._vars = vars_list
        self.filepath = os.path.abspath(mdf_path)

        self._mdf: Optional[MDF] = None
        self._views_by_var: Dict[CanapeVariable, _SignalView] = {}
        self._views_by_name: Dict[str, _SignalView] = {}

    def _resolve_signal(self, mdf: MDF, expected_long: str, tail: str, names: List[str]) -> Optional[Signal]:
        # Try exact "Device:Var"
        try:
            return mdf.get(expected_long)
        except Exception:
            pass
        # Try exact "Var"
        try:
            return mdf.get(tail)
        except Exception:
            pass
        # Case-insensitive exact match
        lower = {n.lower(): n for n in names}
        for candidate in (expected_long, tail):
            n = lower.get(candidate.lower())
            if n:
                try:
                    return mdf.get(n)
                except Exception:
                    pass
        # Unique suffix ":Var"
        suff = f":{tail}"
        cand = [n for n in names if n.endswith(suff)]
        if len(cand) == 1:
            try:
                return mdf.get(cand[0])
            except Exception:
                pass
        # Unique suffix ".Var"
        suff = f".{tail}"
        cand = [n for n in names if n.endswith(suff)]
        if len(cand) == 1:
            try:
                return mdf.get(cand[0])
            except Exception:
                pass
        return None

    def _load_views(self):
        self._mdf = MDF(self.filepath)
        try:
            names = list(self._mdf.get_channel_names())
        except Exception:
            names = []

        # Map recorded variables first
        for v in self._vars:
            sig = self._resolve_signal(self._mdf, v.longname, v.varname, names)
            if sig is not None:
                view = _SignalView(sig, display_name=v.longname)
                self._views_by_var[v] = view
                self._views_by_name[v.longname] = view

        # Also expose raw MDF channel names
        for n in names:
            if n not in self._views_by_name:
                try:
                    self._views_by_name[n] = _SignalView(self._mdf.get(n), display_name=n)
                except Exception:
                    continue

    def finalize(self):
        # Stop CANape measurement and cleanup channels
        try:
            self._app.Measurement.Stop()
        except Exception:
            pass

        for dev, task in self._tasks.items():
            for ch in self._added.get(dev, []):
                try:
                    task.Channels.Remove(ch)
                except Exception:
                    pass

        # Wait until MF4 appears and stops growing, then load and index
        _wait_for_file_stable(self.filepath, timeout_s=30.0, poll_s=0.25)
        self._load_views()

    def __getitem__(self, key: Union[CanapeVariable, str]) -> _SignalView:
        if isinstance(key, CanapeVariable):
            view = self._views_by_var.get(key)
            if view is None:
                raise KeyError(f"No recorded data for {key.longname} in '{self.filepath}'")
            return view
        elif isinstance(key, str):
            if key in self._views_by_name:
                return self._views_by_name[key]
            # Tail-only lookup if unique
            tail = key.split(":", 1)[-1]
            matches = [n for n in self._views_by_name.keys() if n.endswith(":" + tail) or n.endswith("." + tail) or n == tail]
            if len(matches) == 1:
                return self._views_by_name[matches[0]]
            raise KeyError(f"No recorded data for '{key}' in '{self.filepath}'")
        else:
            raise TypeError("Key must be a CanapeVariable or 'Device:Variable' string.")

    def close(self):
        try:
            if self._mdf is not None:
                self._mdf.close()
        except Exception:
            pass


class CanapeDevice:
    def __init__(self, app, device_com, name: str):
        self.app = app
        self.dev = device_com
        self.name = name


class CanapeAutomation:
    """
    Usage:
      session = CanapeAutomation()
      session.add_device("XCPsim", "XCPsim.a2l", "XCP", 1)
      var = session["XCPsim:ampl"]
      with session.recorder(var, "XCPsim:channel1", mdf_path="out.mf4") as rec:
          # do actions...
          pass
      V = rec[var]
      print(V.x, V.y, V.name, V.data)
    """
    def __init__(self, project_path: Optional[str] = None):
        self.app = _dispatch_canape()
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except Exception:
            pass

        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"

        self.app.Open2(project_path, 1, 100000, 0, 0, 1)
        time.sleep(2)

        self.devices: Dict[str, CanapeDevice] = {}
        self._var_cache: Dict[str, CanapeVariable] = {}

    def add_device(self, name: str, a2l: str, dev_type: str, channel: int) -> CanapeDevice:
        dev_com = self.app.Devices.Add(name, a2l, dev_type, channel)
        dev = CanapeDevice(self.app, dev_com, name)
        self.devices[name] = dev
        return dev

    def go_online_all(self, reconnect: bool = False):
        for dev in self.devices.values():
            try:
                dev.dev.GoOnline(reconnect)
            except Exception:
                pass

    def close(self):
        try:
            for dev in self.devices.values():
                try:
                    dev.dev.GoOffline()
                except Exception:
                    pass
        finally:
            try:
                self.app.Quit()
            except Exception:
                pass

    def __getitem__(self, longname: str) -> CanapeVariable:
        if ":" not in longname:
            raise ValueError('Use "Device:Variable", e.g., "XCPsim:ampl"')
        devname, varname = longname.split(":", 1)
        if devname not in self.devices:
            raise KeyError(f"Device '{devname}' is not added.")
        key = f"{devname}:{varname}"
        if key in self._var_cache:
            return self._var_cache[key]
        var = CanapeVariable(self.app, self.devices[devname].dev, devname, varname)
        self._var_cache[key] = var
        return var

    @contextmanager
    def recorder(
        self,
        *vars_or_longnames: Union[CanapeVariable, str],
        task_name: str = "100ms",
        sampling_time: Optional[int] = 100,
        mdf_path: Optional[str] = None
    ):
        if not vars_or_longnames:
            raise TypeError("Provide at least one variable or 'Device:Variable'.")

        # Normalize to CanapeVariable
        vars_list: List[CanapeVariable] = []
        for item in vars_or_longnames:
            if isinstance(item, CanapeVariable):
                vars_list.append(item)
            elif isinstance(item, str):
                vars_list.append(self[item])
            else:
                raise TypeError("Items must be CanapeVariable or 'Device:Variable'.")

        # Group by device and configure tasks/channels
        by_dev: Dict[str, List[CanapeVariable]] = {}
        for v in vars_list:
            by_dev.setdefault(v.device_name, []).append(v)

        tasks: Dict[str, Any] = {}
        added: Dict[str, List[str]] = {}

        for devname, dev_vars in by_dev.items():
            dev_com = self.devices[devname].dev
            task = dev_com.Tasks(task_name)
            tasks[devname] = task

            if sampling_time is not None:
                try:
                    task.SamplingTime = int(sampling_time)
                except Exception:
                    pass

            added_names: List[str] = []
            for v in dev_vars:
                try:
                    dev_com.CalibrationObjects.Add(v.varname)
                except Exception:
                    pass
                try:
                    task.Channels.Add(v.varname)
                    try:
                        task.Channels(v.varname).Save2MDF = True
                    except Exception:
                        pass
                    added_names.append(v.varname)
                except Exception:
                    pass
            added[devname] = added_names

        # Select MF4 path and set CANape to write it
        if mdf_path is None:
            stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            mdf_path = os.path.abspath(f"canape_recording_{stamp}.mf4")
        _ensure_parent_dir(mdf_path)
        try:
            self.app.Measurement.MDFFilename = mdf_path
        except Exception:
            pass

        # Start measurement
        try:
            self.app.Measurement.Start()
        except Exception:
            pass

        rec = RecorderResult(self.app, tasks, added, vars_list, mdf_path)
        try:
            yield rec
        finally:
            rec.finalize()
