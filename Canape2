import win32com.client
import platform
import time
import array
from contextlib import contextmanager
from typing import Optional

# ---------------------------
# Helpers
# ---------------------------

def dispatch_canape():
    """Robustly dispatch the CANape/CAMape COM application object."""
    try:
        return win32com.client.Dispatch('CANape.Application')
    except Exception:
        return win32com.client.Dispatch('CAMape.Application')

def print_platform():
    arch = platform.architecture()[0]
    print("Python x32 environment is used" if arch == '32bit' else "Python x64 environment is used")

# ---------------------------
# Minimal longname handling
# ---------------------------

class CanapeVariableMapper:
    """
    Longname format: 'devicename:variablename'.
    No registry, no external mapping. Extend later if needed.
    """
    def get_longname(self, devname: str, key: str) -> str:
        return key if ":" in key else f"{devname}:{key}"

# ---------------------------
# Variable wrapper (use variable object everywhere)
# ---------------------------

class CanapeVariable:
    """
    Create once and use everywhere:
      var_ampl = canapevariable["ampl"]        # or ["XCPsim:ampl"]
      print(var_ampl.value)
      var_ampl.value = 42
    """
    def __init__(self, app, device, mapper: CanapeVariableMapper, devname: str, varname: str):
        self._app = app
        self._dev = device
        self._mapper = mapper
        self._devname = devname
        self._varname = varname
        self._longname = mapper.get_longname(devname, varname)

    @property
    def value(self):
        self._dev.CalibrationObjects.Add(self._longname)
        obj = self._dev.CalibrationObjects.Item(self._longname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, val):
        self._dev.CalibrationObjects.Add(self._longname)
        obj = self._dev.CalibrationObjects.Item(self._longname)
        obj.Value = val
        obj.Write()

    # Optional CANape-like APIs
    def Read(self):
        return self.value

    def Write(self, val=None):
        if val is not None:
            self.value = val
        else:
            self._dev.CalibrationObjects.Add(self._longname)
            self._dev.CalibrationObjects.Item(self._longname).Write()

# ---------------------------
# Recorder context (accepts and returns only CanapeVariable)
# ---------------------------

class RecorderContext:
    """
    Access recorded values ONLY by CanapeVariable object:
      recorder[var_ampl]
    """
    def __init__(self, task, variables):
        self._task = task
        self._variables = list(variables)
        # Build index per variable to the channel in the task
        try:
            channel_names = [ch.Name for ch in task.Channels]
        except Exception:
            channel_names = []
        self._index_by_var = {}
        for v in self._variables:
            idx = -1
            try:
                idx = channel_names.index(v._longname)
            except ValueError:
                # Some projects expose short names in tasks
                try:
                    idx = channel_names.index(v._varname)
                except ValueError:
                    idx = -1
            self._index_by_var[v] = idx

    def __getitem__(self, key: CanapeVariable):
        if not isinstance(key, CanapeVariable):
            raise TypeError("Recorder expects CanapeVariable objects as keys. "
                            "Use variables created via canapevariable[...].")
        idx = self._index_by_var.get(key, -1)
        if idx < 0:
            raise KeyError(f"Variable not part of this recorder: {getattr(key, '_longname', repr(key))}")
        current = self._task.CurrentValues()
        return current[0][idx] if current else None

# ---------------------------
# Variable accessor for a device (provides canapevariable[...] and recorder(...))
# ---------------------------

class CanapeVariableAccess:
    """
    Build variables and record with variable objects only:
      canapevariable = dev.canapevariable
      var1 = canapevariable["ampl"]                 # or ["XCPsim:ampl"]
      with canapevariable.recorder(var1, ...) as rec:
          print(rec[var1])
    """
    def __init__(self, app, device, devname: str, mapper: Optional[CanapeVariableMapper] = None):
        self._app = app
        self._dev = device
        self._devname = devname
        self._mapper = mapper or CanapeVariableMapper()
        self._cache = {}

    def __getitem__(self, key: str) -> CanapeVariable:
        if ":" in key:
            devname, varname = key.split(":", 1)
        else:
            devname, varname = self._devname, key
        cache_key = f"{devname}:{varname}"
        if cache_key not in self._cache:
            self._cache[cache_key] = CanapeVariable(self._app, self._dev, self._mapper, devname, varname)
        return self._cache[cache_key]

    @contextmanager
    def recorder(self, *vars_only: CanapeVariable, task_name: str = "100ms", sampling_time: Optional[int] = 100):
        # Enforce variable-only API
        if not vars_only or any(not isinstance(v, CanapeVariable) for v in vars_only):
            raise TypeError("Pass only CanapeVariable objects to recorder, e.g. with canapevariable.recorder(var1, var2, ...)")

        task = self._dev.Tasks(task_name)
        if sampling_time is not None:
            try:
                task.SamplingTime = int(sampling_time)
            except Exception:
                pass

        added_names = []
        for v in vars_only:
            # Ensure cal object exists
            try:
                self._dev.CalibrationObjects.Add(v._longname)
            except Exception:
                pass
            # Add channel by longname then fallback to raw varname
            name_used = None
            try:
                task.Channels.Add(v._longname)
                name_used = v._longname
            except Exception:
                try:
                    task.Channels.Add(v._varname)
                    name_used = v._varname
                except Exception:
                    name_used = None
            if name_used:
                # Enable MDF save if available
                try:
                    task.Channels(name_used).Save2MDF = True
                except Exception:
                    pass
                added_names.append(name_used)

        # Start measurement
        self._app.Measurement.Start()
        ctx = RecorderContext(task, vars_only)
        try:
            yield ctx
        finally:
            # Stop and cleanup
            try:
                self._app.Measurement.Stop()
            except Exception:
                pass
            for name in added_names:
                try:
                    task.Channels.Remove(name)
                except Exception:
                    pass

# ---------------------------
# Device wrapper (minimal; exposes .canapevariable)
# ---------------------------

class CanapeDevice:
    """
    Wraps a CANape device and exposes:
      - .canapevariable to create/access variables and use recorder
      - simple memory helpers
    """
    def __init__(self, app, com_device, devname: str):
        self.app = app
        self.dev = com_device
        self.name = devname
        # Expose accessor with the name you asked for
        self.canapevariable = CanapeVariableAccess(app, com_device, devname)

    # Memory helpers (optional)
    def read_memory(self, addr: int, size: int):
        val = self.dev.ReadMemory(addr, size)
        print(f"[READ] Memory at {addr}: {''.join('%02x' % b for b in val)}")
        return val

    def write_memory(self, addr: int, data):
        self.dev.WriteMemory(addr, array.array('B', data))
        print(f"[WRITE] Memory at {addr}: {''.join('%02x' % b for b in data)}")

# ---------------------------
# Automation session (no registry; pass project path or use default example)
# ---------------------------

class CanapeAutomation:
    """
    Minimal automation with multi-device and var-only workflow.
    No registry access. Provide project_path explicitly or fallback to default example.
    """
    def __init__(self, project_path: Optional[str] = None):
        self.app = dispatch_canape()
        # Configure measurement before opening a project
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except Exception:
            pass

        self.devices = {}
        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"  # adjust as needed

        self.open_project(project_path)
        print_platform()

    def open_project(self, cmpWorkingDir: str, debugMode: int = 1, COMTimeout: int = 100000, clearDevList: int = 0, modalNode: int = 0):
        self.app.Open2(cmpWorkingDir, debugMode, COMTimeout, clearDevList, modalNode, 1)
        time.sleep(2)

    def add_device(self, devName: str, a2lFile: str, devType: str, channel: int) -> CanapeDevice:
        dev = self.app.Devices.Add(devName, a2lFile, devType, channel)
        device = CanapeDevice(self.app, dev, devName)
        self.devices[devName] = device
        return device

    def go_online_all(self, reconnect: bool = False):
        for d in self.devices.values():
            try:
                d.dev.GoOnline(reconnect)
            except Exception:
                pass

    def go_offline_all(self):
        for d in self.devices.values():
            try:
                d.dev.GoOffline()
            except Exception:
                pass

    def close(self):
        try:
            self.go_offline_all()
        except Exception:
            pass
        try:
            self.app.Quit()
        except Exception:
            pass

# ---------------------------
# Example Usage (uses canapevariable)
# ---------------------------

if __name__ == "__main__":
    # Create session (no registry)
    session = CanapeAutomation(project_path=None)  # or provide your .cnp working dir

    # Add device
    dev1 = session.add_device("XCPsim", "XCPsim.a2l", "XCP", 1)
    session.go_online_all()

    # Declare variables ONCE using canapevariable, then use only variable objects
    canapevariable = dev1.canapevariable
    var_ampl = canapevariable["ampl"]              # same as ["XCPsim:ampl"]
    var_ch1  = canapevariable["channel1"]          # same as ["XCPsim:channel1"]

    # Read/write using only var objects
    print("ampl (before):", var_ampl.value)
    var_ampl.value = var_ampl.value                # no-op write demo
    print("ampl (after):", var_ampl.value)

    # Record using only variable objects and access via variable objects
    with canapevariable.recorder(var_ampl, var_ch1, task_name="100ms", sampling_time=100) as rec:
        print("Recording...")
        for _ in range(5):
            print("ampl:", rec[var_ampl])
            print("channel1:", rec[var_ch1])
            time.sleep(0.2)

    session.close()
