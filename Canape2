import win32com.client
import time
import threading
import array
from contextlib import contextmanager
from typing import Optional, List, Dict

# ---------------------------
# Helpers
# ---------------------------

def dispatch_canape():
    try:
        return win32com.client.Dispatch('CANape.Application')
    except Exception:
        return win32com.client.Dispatch('CAMape.Application')

# ---------------------------
# Variable wrapper (declare once, use everywhere)
# ---------------------------

class CanapeVariable:
    """
    Create once and use everywhere:
      var_ampl = canapevariable["ampl"]        # or ["DeviceName:ampl"]
      print(var_ampl.value)
      var_ampl.value = 42

    IMPORTANT: Under the hood we talk to the device-specific COM path:
      self._app.Devices(DeviceName).CalibrationObjects(VariableName)
    We do NOT pass combined "Device:Variable" into CalibrationObjects.
    """
    def __init__(self, app, device_com, device_name: str, varname: str):
        self._app = app
        self._dev = device_com                    # COM device object (self._app.Devices(DeviceName))
        self._device_name = device_name
        self._varname = varname                   # variable name as in A2L for this device
        self._display = f"{device_name}:{varname}"

    @property
    def value(self):
        # self._app.Devices(Device).CalibrationObjects(Var)
        self._dev.CalibrationObjects.Add(self._varname)
        obj = self._dev.CalibrationObjects.Item(self._varname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, val):
        self._dev.CalibrationObjects.Add(self._varname)
        obj = self._dev.CalibrationObjects.Item(self._varname)
        obj.Value = val
        obj.Write()

    # Convenience for prints/debug
    def __repr__(self):
        return f"<CanapeVariable {self._display}>"

# ---------------------------
# Recorder (values available only AFTER stop)
# ---------------------------

class RecorderContext:
    """
    Recorded data is only accessible after the recording stops (after the with-block).
    Usage:
      with canapevariable.recorder(var1, var2, task_name="100ms", sampling_time=100) as rec:
          ... do stuff during recording ...
      # Here, recording stopped. Access data now:
      vals1 = rec[var1]        # list of values for var1
      ts    = rec.timestamps   # list of timestamps (common for all variables)
    """
    def __init__(self, task, variables: List[CanapeVariable]):
        self._task = task
        self._vars = list(variables)
        self._closed = False

        # Channel order follows the order variables were added
        self._channel_order: List[str] = [v._varname for v in self._vars]
        self._values: Dict[CanapeVariable, List] = {v: [] for v in self._vars}
        self._timestamps: List[float] = []

        self._stop_evt = threading.Event()
        self._thread = threading.Thread(target=self._collect_loop, name="CANapeRecorder", daemon=True)

    def start(self):
        self._thread.start()

    def stop_and_finalize(self):
        # Signal thread to stop and drain remaining samples
        self._stop_evt.set()
        self._thread.join(timeout=5.0)
        # Final drain in case anything left
        self._drain_once()
        self._closed = True

    @property
    def timestamps(self) -> List[float]:
        if not self._closed:
            raise RuntimeError("Timestamps are available only after recording has stopped.")
        return self._timestamps

    def __getitem__(self, var: CanapeVariable):
        if not isinstance(var, CanapeVariable):
            raise TypeError("Use the declared CanapeVariable object as key, e.g., rec[var_ampl].")
        if not self._closed:
            raise RuntimeError("Recorded values are available only after recording has stopped.")
        return self._values[var]

    # Internal: background collection
    def _collect_loop(self):
        # Continuously pull NextSample while recording
        while not self._stop_evt.is_set():
            got = self._pull_one()
            if not got:
                time.sleep(0.001)

    def _pull_one(self) -> bool:
        try:
            sample = self._task.NextSample()
        except Exception:
            sample = None
        if not sample:
            return False
        y_vals, ts = sample[0], sample[1]
        # Map by the order channels were added (same as self._vars order)
        for idx, v in enumerate(self._vars):
            try:
                self._values[v].append(y_vals[idx])
            except Exception:
                # if length mismatch, skip
                pass
        self._timestamps.append(ts)
        return True

    def _drain_once(self):
        while self._pull_one():
            pass

# ---------------------------
# Variable accessor (provides canapevariable[...] and recorder(...))
# ---------------------------

class CanapeVariableAccess:
    """
    var = canapevariable["short"] or canapevariable["Device:short"]
    with canapevariable.recorder(var1, var2, ...) as rec:
        ... inside recording ...
    # after with:
    vals = rec[var1]
    """
    def __init__(self, app, device_com, device_name: str):
        self._app = app
        self._dev = device_com
        self._device_name = device_name
        self._cache: Dict[str, CanapeVariable] = {}

    def __getitem__(self, key: str) -> CanapeVariable:
        # Accept "var" or "Device:var"
        if ":" in key:
            dev, var = key.split(":", 1)
            if dev != self._device_name:
                raise ValueError(f"Variable '{key}' does not belong to device '{self._device_name}'.")
        else:
            var = key
        cache_key = var
        if cache_key not in self._cache:
            self._cache[cache_key] = CanapeVariable(self._app, self._dev, self._device_name, var)
        return self._cache[cache_key]

    @contextmanager
    def recorder(self, *vars_only: CanapeVariable, task_name: str = "100ms", sampling_time: Optional[int] = 100):
        if not vars_only or any(not isinstance(v, CanapeVariable) for v in vars_only):
            raise TypeError("Pass only CanapeVariable objects: canapevariable.recorder(var1, var2, ...)")

        task = self._dev.Tasks(task_name)
        # Set sampling time
        if sampling_time is not None:
            try:
                task.SamplingTime = int(sampling_time)
            except Exception:
                pass

        # Add channels (by var name only, device-specific)
        added = []
        for v in vars_only:
            try:
                self._dev.CalibrationObjects.Add(v._varname)
            except Exception:
                pass
            try:
                task.Channels.Add(v._varname)
                # Save to MDF if supported
                try:
                    task.Channels(v._varname).Save2MDF = True
                except Exception:
                    pass
                added.append(v._varname)
            except Exception:
                pass

        # Start measurement and async collection
        self._app.Measurement.Start()
        rec = RecorderContext(task, list(vars_only))
        rec.start()

        try:
            yield rec
        finally:
            # Stop measurement first so no more data comes in
            try:
                self._app.Measurement.Stop()
            except Exception:
                pass
            # Finalize and expose data
            rec.stop_and_finalize()
            # Cleanup channels
            for name in added:
                try:
                    task.Channels.Remove(name)
                except Exception:
                    pass

# ---------------------------
# Device and session
# ---------------------------

class CanapeDevice:
    """
    Device wrapper exposing:
      - .canapevariable for variable creation and recording
      - memory helpers
    """
    def __init__(self, app, device_com, name: str):
        self.app = app
        self.dev = device_com
        self.name = name
        self.canapevariable = CanapeVariableAccess(app, device_com, name)

    def read_memory(self, addr: int, size: int):
        val = self.dev.ReadMemory(addr, size)
        print(f"[READ] Memory {addr}: {''.join('%02x' % b for b in val)}")
        return val

    def write_memory(self, addr: int, data):
        self.dev.WriteMemory(addr, array.array('B', data))
        print(f"[WRITE] Memory {addr}: {''.join('%02x' % b for b in data)}")

class CanapeAutomation:
    """
    Minimal session manager (no registry).
    """
    def __init__(self, project_path: Optional[str] = None):
        self.app = dispatch_canape()
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except Exception:
            pass
        self.devices: Dict[str, CanapeDevice] = {}
        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"
        self.app.Open2(project_path, 1, 100000, 0, 0, 1)
        time.sleep(2)

    def add_device(self, name: str, a2l: str, dev_type: str, channel: int) -> CanapeDevice:
        dev_com = self.app.Devices.Add(name, a2l, dev_type, channel)
        dev = CanapeDevice(self.app, dev_com, name)
        self.devices[name] = dev
        return dev

    def go_online_all(self, reconnect: bool = False):
        for dev in self.devices.values():
            try:
                dev.dev.GoOnline(reconnect)
            except Exception:
                pass

    def go_offline_all(self):
        for dev in self.devices.values():
            try:
                dev.dev.GoOffline()
            except Exception:
                pass

    def close(self):
        try:
            self.go_offline_all()
        except Exception:
            pass
        try:
            self.app.Quit()
        except Exception:
            pass

# ---------------------------
# Example usage demonstrating "rec[var] AFTER stop"
# ---------------------------

if __name__ == "__main__":
    session = CanapeAutomation()
    dev = session.add_device("XCPsim", "XCPsim.a2l", "XCP", 1)
    session.go_online_all()

    canapevariable = dev.canapevariable
    var_ampl = canapevariable["ampl"]          # or ["XCPsim:ampl"]
    var_ch1  = canapevariable["channel1"]

    # During recording, do your actions
    with canapevariable.recorder(var_ampl, var_ch1, task_name="100ms", sampling_time=100) as rec:
        print("Recording...")
        for _ in range(10):
            _ = var_ampl.value  # sample read or other actions
            time.sleep(0.1)

    # After exiting 'with', recording has stopped and data is finalized.
    # Now you can access recorded data:
    ampl_values = rec[var_ampl]     # list of values
    ch1_values  = rec[var_ch1]      # list of values
    timestamps  = rec.timestamps    # common timestamps

    print(f"Recorded samples: {len(timestamps)}")
    if ampl_values:
        print(f"ampl first/last: {ampl_values[0]} -> {ampl_values[-1]}")
    if ch1_values:
        print(f"channel1 first/last: {ch1_values[0]} -> {ch1_values[-1]}")

    session.close()
