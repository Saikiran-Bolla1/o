# Requires:
#   pip install pywin32 asammdf numpy
#
# Features kept minimal and aligned to your asks:
# - Direct longname access: var = session["Device:Variable"]
# - Recording uses CANape's MF4 only (no background threads).
# - session.recorder(...) sets CANape.Measurement.MDFFilename to your path and reads the same file.
# - After the with-block:
#     V = rec[var]  or  V = rec["Device:Variable"]
#     V.x -> timestamps (numpy array)
#     V.y -> values (numpy array)
#     V.name -> "Device:Variable" when resolvable (else raw MF4 name)
#     V.data -> ((x0,y0), ..., (xn,yn))
# - rec.signals -> list of all recorded signal names (as in the recorder)
# - rec.values  -> list of (name, values) for all recorded signals
# - Enum/text signals are converted to RAW (numeric) values whenever possible.

import os
import time
import win32com.client
import numpy as np
from datetime import datetime
from contextlib import contextmanager
from typing import Dict, List, Optional, Union, Any, Tuple

from asammdf import MDF, Signal


def _dispatch_canape():
    try:
        return win32com.client.Dispatch("CANape.Application")
    except Exception:
        return win32com.client.Dispatch("CAMape.Application")


def _ensure_parent_dir(path: str):
    parent = os.path.dirname(os.path.abspath(path))
    if parent and not os.path.exists(parent):
        os.makedirs(parent, exist_ok=True)


def _wait_for_file_stable(path: str, timeout_s: float = 20.0, poll_s: float = 0.25) -> bool:
    end = time.time() + timeout_s
    last = -1
    seen = False
    while time.time() < end:
        if os.path.exists(path):
            size = os.path.getsize(path)
            if seen and size == last and size > 0:
                return True
            last = size
            seen = True
        time.sleep(poll_s)
    return os.path.exists(path)


class CanapeVariable:
    def __init__(self, app, device_com, device_name: str, varname: str):
        self._app = app
        self._dev = device_com
        self.device_name = device_name
        self.varname = varname
        self.longname = f"{device_name}:{varname}"

    @property
    def value(self):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, val):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Value = val
        obj.Write()

    def __repr__(self):
        return f"<CanapeVariable {self.longname}>"


def _get_signal_raw_preferred(mdf: MDF, name: str) -> Signal:
    # Try to get RAW samples (no conversion applied)
    try:
        return mdf.get(name, raw=True)  # asammdf supports raw=True
    except TypeError:
        # Older asammdf: fall back to normal get
        return mdf.get(name)
    except Exception:
        return mdf.get(name)


def _maybe_text_to_raw(samples: np.ndarray, signal: Signal) -> np.ndarray:
    # If already numeric, return as-is
    if hasattr(samples, "dtype") and samples.dtype.kind in ("i", "u", "f", "b"):
        return samples

    # Try to invert enum/text mapping using conversion object
    conv = getattr(signal, "conversion", None)
    if conv is not None:
        # Common attribute names across asammdf versions
        for attr in ("text_2_value", "text2value", "text_to_value", "value_map", "val_map"):
            mapping = getattr(conv, attr, None)
            if mapping:
                def map_one(s):
                    # exact
                    if s in mapping:
                        return mapping[s]
                    # bytes -> str
                    if isinstance(s, (bytes, bytearray)):
                        try:
                            s2 = s.decode(errors="ignore")
                            if s2 in mapping:
                                return mapping[s2]
                        except Exception:
                            pass
                    # fallback: try numeric cast
                    try:
                        return float(s)
                    except Exception:
                        return np.nan
                return np.array([map_one(s) for s in samples], dtype=float)

    # Last resort: try best-effort float conversion
    try:
        return samples.astype(float)
    except Exception:
        # keep as object; consumer can handle
        return samples


class _SignalView:
    def __init__(self, signal: Signal, display_name: Optional[str] = None, force_raw: bool = False):
        self._sig = signal
        self._name = display_name or signal.name

        xs = signal.timestamps
        ys = signal.samples

        # Convert enum/text to raw numeric if needed or if forced
        if force_raw or (hasattr(ys, "dtype") and ys.dtype.kind in ("O", "U", "S")):
            ys = _maybe_text_to_raw(ys, signal)

        # Store the arrays we will expose
        self._x = np.asarray(xs)
        self._y = np.asarray(ys)

    @property
    def x(self):
        return self._x

    @property
    def y(self):
        return self._y

    @property
    def name(self) -> str:
        return self._name

    @property
    def data(self) -> Tuple[Tuple[float, float], ...]:
        n = min(len(self._x), len(self._y))
        return tuple((float(self._x[i]), float(self._y[i])) for i in range(n))


class RecorderResult:
    """
    Created by session.recorder(...). Finalized AFTER the with-block.
    Data source: the MF4 file written by CANape.

    Additional shortcuts:
    - rec.signals -> list of recorded signal names
    - rec.values  -> list of (name, values_array) for recorded signals
    """
    def __init__(self, app, task_per_device: Dict[str, Any], added_per_device: Dict[str, List[str]], vars_list: List[CanapeVariable], mdf_path: str):
        self._app = app
        self._tasks = task_per_device
        self._added = added_per_device
        self._vars = vars_list
        self.filepath = os.path.abspath(mdf_path)

        self._mdf: Optional[MDF] = None
        self._views_by_var: Dict[CanapeVariable, _SignalView] = {}
        self._views_by_name: Dict[str, _SignalView] = {}
        self._ordered_names: List[str] = []  # keep order consistent with vars_list

    def _resolve_signal(self, mdf: MDF, expected_long: str, tail: str, names: List[str]) -> Optional[Signal]:
        # 1) Try exact long name raw
        try:
            return _get_signal_raw_preferred(mdf, expected_long)
        except Exception:
            pass
        # 2) Try exact tail raw
        try:
            return _get_signal_raw_preferred(mdf, tail)
        except Exception:
            pass
        # 3) Case-insensitive exact match
        lower = {n.lower(): n for n in names}
        for cand in (expected_long, tail):
            n = lower.get(cand.lower())
            if n:
                try:
                    return _get_signal_raw_preferred(mdf, n)
                except Exception:
                    pass
        # 4) Unique suffix ":Var" or ".Var"
        for sep in (":", "."):
            suffix = f"{sep}{tail}"
            matches = [n for n in names if n.endswith(suffix)]
            if len(matches) == 1:
                try:
                    return _get_signal_raw_preferred(mdf, matches[0])
                except Exception:
                    pass
        return None

    def _load_views(self):
        self._mdf = MDF(self.filepath)
        try:
            names = list(self._mdf.get_channel_names())
        except Exception:
            names = []

        # Build views for the signals explicitly requested in the recorder
        for v in self._vars:
            sig = self._resolve_signal(self._mdf, v.longname, v.varname, names)
            if sig is not None:
                view = _SignalView(sig, display_name=v.longname)
                self._views_by_var[v] = view
                self._views_by_name[v.longname] = view
                self._ordered_names.append(v.longname)

        # Also allow access by raw MDF names (in case user queries by that)
        for n in names:
            if n not in self._views_by_name:
                try:
                    sig = _get_signal_raw_preferred(self._mdf, n)
                    self._views_by_name[n] = _SignalView(sig, display_name=n)
                except Exception:
                    continue

    def finalize(self):
        # Stop CANape measurement and cleanup channels we added
        try:
            self._app.Measurement.Stop()
        except Exception:
            pass

        for dev, task in self._tasks.items():
            for ch in self._added.get(dev, []):
                try:
                    task.Channels.Remove(ch)
                except Exception:
                    pass

        # Wait until MF4 appears and is stable, then load
        _wait_for_file_stable(self.filepath, timeout_s=30.0, poll_s=0.25)
        self._load_views()

    def __getitem__(self, key: Union[CanapeVariable, str]) -> _SignalView:
        if isinstance(key, CanapeVariable):
            view = self._views_by_var.get(key)
            if view is None:
                raise KeyError(f"No recorded data for {key.longname} in '{self.filepath}'")
            return view
        elif isinstance(key, str):
            if key in self._views_by_name:
                return self._views_by_name[key]
            # Tail-only lookup if unique among the recorded names
            tail = key.split(":", 1)[-1]
            matches = [n for n in self._views_by_name.keys() if n.endswith(":" + tail) or n.endswith("." + tail) or n == tail]
            if len(matches) == 1:
                return self._views_by_name[matches[0]]
            raise KeyError(f"No recorded data for '{key}' in '{self.filepath}'")
        else:
            raise TypeError("Key must be a CanapeVariable or 'Device:Variable' string.")

    @property
    def signals(self) -> List[str]:
        # Only the signals explicitly configured in this recorder (preserve order)
        return list(self._ordered_names)

    @property
    def values(self) -> List[Tuple[str, np.ndarray]]:
        # Names and values for the recorded signals (preserve order)
        out: List[Tuple[str, np.ndarray]] = []
        for name in self._ordered_names:
            view = self._views_by_name.get(name)
            if view is not None:
                out.append((name, view.y))
        return out

    def close(self):
        try:
            if self._mdf is not None:
                self._mdf.close()
        except Exception:
            pass


class CanapeDevice:
    def __init__(self, app, device_com, name: str):
        self.app = app
        self.dev = device_com
        self.name = name


class CanapeAutomation:
    def __init__(self, project_path: Optional[str] = None):
        self.app = _dispatch_canape()
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except Exception:
            pass

        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"

        self.app.Open2(project_path, 1, 100000, 0, 0, 1)
        time.sleep(2)

        self.devices: Dict[str, CanapeDevice] = {}
        self._var_cache: Dict[str, CanapeVariable] = {}

    def add_device(self, name: str, a2l: str, dev_type: str, channel: int) -> CanapeDevice:
        dev_com = self.app.Devices.Add(name, a2l, dev_type, channel)
        dev = CanapeDevice(self.app, dev_com, name)
        self.devices[name] = dev
        return dev

    def go_online_all(self, reconnect: bool = False):
        for dev in self.devices.values():
            try:
                dev.dev.GoOnline(reconnect)
            except Exception:
                pass

    def close(self):
        try:
            for dev in self.devices.values():
                try:
                    dev.dev.GoOffline()
                except Exception:
                    pass
        finally:
            try:
                self.app.Quit()
            except Exception:
                pass

    def __getitem__(self, longname: str) -> CanapeVariable:
        if ":" not in longname:
            raise ValueError('Use "Device:Variable", e.g., "XCPsim:ampl"')
        devname, varname = longname.split(":", 1)
        if devname not in self.devices:
            raise KeyError(f"Device '{devname}' is not added.")
        key = f"{devname}:{varname}"
        if key in self._var_cache:
            return self._var_cache[key]
        var = CanapeVariable(self.app, self.devices[devname].dev, devname, varname)
        self._var_cache[key] = var
        return var

    @contextmanager
    def recorder(
        self,
        *vars_or_longnames: Union[CanapeVariable, str],
        task_name: str = "100ms",
        sampling_time: Optional[int] = 100,
        mdf_path: Optional[str] = None
    ):
        if not vars_or_longnames:
            raise TypeError("Provide at least one variable or 'Device:Variable'.")

        # Normalize to CanapeVariable
        vars_list: List[CanapeVariable] = []
        for item in vars_or_longnames:
            if isinstance(item, CanapeVariable):
                vars_list.append(item)
            elif isinstance(item, str):
                vars_list.append(self[item])
            else:
                raise TypeError("Items must be CanapeVariable or 'Device:Variable'.")

        # Group by device and configure tasks/channels
        by_dev: Dict[str, List[CanapeVariable]] = {}
        for v in vars_list:
            by_dev.setdefault(v.device_name, []).append(v)

        tasks: Dict[str, Any] = {}
        added: Dict[str, List[str]] = {}

        for devname, dev_vars in by_dev.items():
            dev_com = self.devices[devname].dev
            task = dev_com.Tasks(task_name)
            tasks[devname] = task

            if sampling_time is not None:
                try:
                    task.SamplingTime = int(sampling_time)
                except Exception:
                    pass

            added_names: List[str] = []
            for v in dev_vars:
                try:
                    dev_com.CalibrationObjects.Add(v.varname)
                except Exception:
                    pass
                try:
                    task.Channels.Add(v.varname)
                    try:
                        task.Channels(v.varname).Save2MDF = True
                    except Exception:
                        pass
                    added_names.append(v.varname)
                except Exception:
                    pass
            added[devname] = added_names

        # MF4 path
        if mdf_path is None:
            stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            mdf_path = os.path.abspath(f"canape_recording_{stamp}.mf4")
        _ensure_parent_dir(mdf_path)
        try:
            self.app.Measurement.MDFFilename = mdf_path
        except Exception:
            pass

        # Start measurement
        try:
            self.app.Measurement.Start()
        except Exception:
            pass

        rec = RecorderResult(self.app, tasks, added, vars_list, mdf_path)
        try:
            yield rec
        finally:
            rec.finalize()
