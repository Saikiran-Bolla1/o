# Requires:
#   pip install pywin32 asammdf numpy
#
# Features:
# - Direct longname access: var = session["Device:Variable"]
# - Recording uses CANape's MF4 only (no background threads).
# - session.recorder(...) sets CANape.Measurement.MDFFilename to your path and reads the same file.
# - After the with-block:
#     V = rec[var]  or  V = rec["Device:Variable"]
#     V.x -> timestamps (numpy array)
#     V.y -> values (numpy array)
#     V.name -> "Device:Variable" when resolvable (else raw MF4 name)
#     V.data -> ((x0,y0), ..., (xn,yn))
# - rec.signals -> list of all recorded signal names (as provided to the recorder)
# - rec.values() -> list of objects having name, x, y, data
#
# Vector driver support (optional):
# - vector_signals: list of "Device:Signal" or CanapeVariable
# - vector_task: task name for vector signals (default "cyclic")
# - vector_sampling_time: sampling time (ms) for vector_task
#
# Important:
# - This version reads PHYSICAL values by default (matches CANape UI).
# - If a channel is an enum/text and you want the NUMERIC enum VALUE instead of the enum NAME,
#   pass prefer_enum_numeric=True to recorder(...). That will automatically re-read such channels RAW.
# - If you want all channels in RAW form, pass prefer_raw=True.

import os
import re
import time
import win32com.client
import numpy as np
from datetime import datetime
from contextlib import contextmanager
from typing import Dict, List, Optional, Union, Any, Tuple, Iterable

from asammdf import MDF, Signal


def _dispatch_canape():
    try:
        return win32com.client.Dispatch("CANape.Application")
    except Exception:
        return win32com.client.Dispatch("CAMape.Application")


def _ensure_parent_dir(path: str):
    parent = os.path.dirname(os.path.abspath(path))
    if parent and not os.path.exists(parent):
        os.makedirs(parent, exist_ok=True)


def _wait_for_file_stable(path: str, timeout_s: float = 20.0, poll_s: float = 0.25) -> bool:
    end = time.time() + timeout_s
    last = -1
    seen = False
    while time.time() < end:
        if os.path.exists(path):
            size = os.path.getsize(path)
            if seen and size == last and size > 0:
                return True
            last = size
            seen = True
        time.sleep(poll_s)
    return os.path.exists(path)


class CanapeVariable:
    def __init__(self, app, device_com, device_name: str, varname: str):
        self._app = app
        self._dev = device_com
        self.device_name = device_name
        self.varname = varname
        self.longname = f"{device_name}:{varname}"

    @property
    def value(self):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, val):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Value = val
        obj.Write()

    def __repr__(self):
        return f"<CanapeVariable {self.longname}>"


class VectorSignalRef:
    def __init__(self, device_name: str, signal_name: str):
        self.device_name = device_name
        self.signal_name = signal_name

    @property
    def longname(self) -> str:
        return f"{self.device_name}:{self.signal_name}"

    def __repr__(self):
        return f"<VectorSignal {self.longname}>"


def _get_signal_preferred(mdf: MDF, name: str, prefer_raw: bool = False) -> Signal:
    """
    Return Signal from MDF, preferring PHYSICAL (converted) values by default.
    Set prefer_raw=True to force RAW (unconverted) samples.
    """
    if prefer_raw:
        try:
            return mdf.get(name, raw=True)
        except Exception:
            return mdf.get(name)
    else:
        try:
            return mdf.get(name)  # physical/converted
        except Exception:
            return mdf.get(name, raw=True)


def _to_float_safe(val) -> float:
    # Already numeric
    if isinstance(val, (int, float, np.integer, np.floating)):
        return float(val)
    if val is None:
        return np.nan
    # Decode bytes
    if isinstance(val, (bytes, bytearray)):
        try:
            val = val.decode("utf-8", errors="ignore")
        except Exception:
            return np.nan

    s = str(val).strip().replace("\xa0", " ")  # strip NBSP
    if s == "" or s.lower() in ("nan", "none", "null"):
        return np.nan
    # Booleans / common text tokens
    low = s.lower()
    if low in ("true", "on", "high", "yes"):
        return 1.0
    if low in ("false", "off", "low", "no"):
        return 0.0

    # Extract first numeric token (supports comma or dot decimal, scientific notation)
    m = re.search(r"[-+]?\d+(?:[.,]\d+)?(?:[eE][-+]?\d+)?", s)
    if m:
        num = m.group(0).replace(",", ".")  # normalize decimal comma
        try:
            return float(num)
        except Exception:
            pass
    return np.nan


def _maybe_text_to_raw(samples: np.ndarray, signal: Signal) -> np.ndarray:
    # If already numeric, return as-is
    if hasattr(samples, "dtype") and samples.dtype.kind in ("i", "u", "f", "b"):
        return samples

    # Try to use conversion mapping (enum text -> numeric), then fall back to safe parse
    conv = getattr(signal, "conversion", None)
    mapping = None
    if conv is not None:
        # Try common attribute names across asammdf versions
        for attr in ("text_2_value", "text2value", "text_to_value", "value_map", "val_map", "mapping"):
            mapping = getattr(conv, attr, None)
            if mapping:
                break
        # If mapping looks like parallel arrays
        if mapping is None:
            texts = getattr(conv, "texts", None) or getattr(conv, "labels", None)
            values = getattr(conv, "values", None) or getattr(conv, "ids", None)
            if texts is not None and values is not None:
                try:
                    mapping = {t: v for t, v in zip(texts, values)}
                except Exception:
                    mapping = None

    out = []
    if mapping:
        for s in samples:
            # Direct mapping
            if s in mapping:
                v = mapping[s]
                out.append(_to_float_safe(v))
                continue
            # Try decoded/normalized lookup
            if isinstance(s, (bytes, bytearray)):
                try:
                    s2 = s.decode(errors="ignore")
                except Exception:
                    s2 = ""
            else:
                s2 = str(s)
            v = mapping.get(s2, None)
            if v is not None:
                out.append(_to_float_safe(v))
            else:
                out.append(_to_float_safe(s))
    else:
        out = [_to_float_safe(s) for s in samples]

    return np.array(out, dtype=float)


class _SignalView:
    def __init__(self, signal: Signal, display_name: Optional[str] = None, force_text_to_numeric: bool = True):
        self._sig = signal
        self._name = display_name or signal.name

        xs = signal.timestamps
        ys = signal.samples

        # Convert enum/text to numeric if needed
        if force_text_to_numeric and (hasattr(ys, "dtype") and ys.dtype.kind in ("O", "U", "S")):
            ys = _maybe_text_to_raw(ys, signal)

        self._x = np.asarray(xs)
        self._y = np.asarray(ys)

    @property
    def x(self):
        return self._x

    @property
    def y(self):
        return self._y

    @property
    def name(self) -> str:
        return self._name

    @property
    def data(self) -> Tuple[Tuple[float, float], ...]:
        n = min(len(self._x), len(self._y))
        return tuple((float(self._x[i]), float(self._y[i])) for i in range(n))

    def __repr__(self):
        return f"<SignalView name={self._name!r} len={len(self._x)}>"


class RecorderResult:
    """
    Created by session.recorder(...). Finalized AFTER the with-block.
    Data source: the MF4 file written by CANape.

    Shortcuts:
      - rec.signals  -> list of recorded signal names (preserve recorder order)
      - rec.values() -> list of per-signal objects each having name, x, y, data
    """
    def __init__(
        self,
        app,
        cleanup_items: List[Tuple[Any, str]],  # (task_com_object, channel_name)
        var_list: List[CanapeVariable],
        vector_refs: List[VectorSignalRef],
        mdf_path: str,
        prefer_raw: bool = False,
        prefer_enum_numeric: bool = True,
    ):
        self._app = app
        self._cleanup_items = cleanup_items
        self._vars = var_list
        self._vectors = vector_refs
        self.filepath = os.path.abspath(mdf_path)
        self._prefer_raw = prefer_raw
        self._prefer_enum_numeric = prefer_enum_numeric

        self._mdf: Optional[MDF] = None
        self._views_by_var: Dict[CanapeVariable, _SignalView] = {}
        self._views_by_name: Dict[str, _SignalView] = {}
        self._ordered_names: List[str] = []  # keep order consistent with input

    def _resolve_signal(self, mdf: MDF, candidates: List[str]) -> Optional[Signal]:
        # Try candidates in order with preference
        for name in candidates:
            try:
                return _get_signal_preferred(mdf, name, prefer_raw=self._prefer_raw)
            except Exception:
                continue
        # Case-insensitive exact match
        try:
            names = list(mdf.get_channel_names())
        except Exception:
            names = []
        lower = {n.lower(): n for n in names}
        for cand in candidates:
            n = lower.get(cand.lower())
            if n:
                try:
                    return _get_signal_preferred(mdf, n, prefer_raw=self._prefer_raw)
                except Exception:
                    pass
        # Unique suffix matches
        for cand in candidates:
            tail = cand.split(":", 1)[-1]
            for sep in (":", "."):
                suffix = f"{sep}{tail}"
                matches = [n for n in names if n.endswith(suffix)]
                if len(matches) == 1:
                    try:
                        return _get_signal_preferred(mdf, matches[0], prefer_raw=self._prefer_raw)
                    except Exception:
                        pass
        return None

    def _maybe_upgrade_enum_to_raw(self, mdf: MDF, sig: Signal, candidates: List[str]) -> Signal:
        """
        If prefer_enum_numeric is True and the signal contains text samples, re-fetch RAW.
        """
        try:
            ys = sig.samples
            is_text = hasattr(ys, "dtype") and ys.dtype.kind in ("O", "U", "S")
        except Exception:
            is_text = False

        if self._prefer_enum_numeric and is_text:
            # Try to fetch RAW using the same candidate names
            for name in candidates:
                try:
                    raw_sig = _get_signal_preferred(mdf, name, prefer_raw=True)
                    return raw_sig
                except Exception:
                    continue
        return sig

    def _load_views_for_name(self, mdf: MDF, display_name: str, candidates: List[str]):
        sig = self._resolve_signal(mdf, candidates)
        if sig is None:
            return
        sig = self._maybe_upgrade_enum_to_raw(mdf, sig, candidates)
        view = _SignalView(sig, display_name=display_name)
        self._views_by_name[display_name] = view
        self._ordered_names.append(display_name)

    def _load_views(self):
        self._mdf = MDF(self.filepath)

        # Calibration variables
        for v in self._vars:
            candidates = [v.longname, v.varname]
            sig = self._resolve_signal(self._mdf, candidates)
            if sig is None:
                continue
            sig = self._maybe_upgrade_enum_to_raw(self._mdf, sig, candidates)
            view = _SignalView(sig, display_name=v.longname)
            self._views_by_var[v] = view
            self._views_by_name[v.longname] = view
            self._ordered_names.append(v.longname)

        # Vector driver signals
        for ref in self._vectors:
            self._load_views_for_name(self._mdf, ref.longname, [ref.longname, ref.signal_name])

        # Also allow access by raw MDF names
        try:
            names = list(self._mdf.get_channel_names())
        except Exception:
            names = []
        for n in names:
            if n not in self._views_by_name:
                try:
                    sig = _get_signal_preferred(self._mdf, n, prefer_raw=self._prefer_raw)
                    sig = self._maybe_upgrade_enum_to_raw(self._mdf, sig, [n])
                    self._views_by_name[n] = _SignalView(sig, display_name=n)
                except Exception:
                    continue

    def finalize(self):
        # Stop CANape measurement
        try:
            self._app.Measurement.Stop()
        except Exception:
            pass

        # Cleanup: remove channels we added
        for task_obj, ch_name in self._cleanup_items:
            try:
                task_obj.Channels.Remove(ch_name)
            except Exception:
                pass

        # Wait until MF4 appears and is stable, then load
        _wait_for_file_stable(self.filepath, timeout_s=30.0, poll_s=0.25)
        self._load_views()

    def __getitem__(self, key: Union[CanapeVariable, str]) -> _SignalView:
        """
        Access recorded signals by:
          - CanapeVariable object (works for both ECU variables and Vector signals)
          - "Device:Signal" string
          - unique tail name (if unambiguous)
        """
        if isinstance(key, CanapeVariable):
            # First try by identity (ECU variables we tracked)
            view = self._views_by_var.get(key)
            if view is not None:
                return view
            # Fallback: try by its long name (enables rec[var] for Vector driver signals)
            longname = getattr(key, "longname", None)
            if longname and longname in self._views_by_name:
                return self._views_by_name[longname]
            # As a last resort, try tail-based lookup
            if longname:
                tail = longname.split(":", 1)[-1]
                matches = [n for n in self._views_by_name.keys()
                           if n.endswith(":" + tail) or n.endswith("." + tail) or n == tail]
                if len(matches) == 1:
                    return self._views_by_name[matches[0]]
            raise KeyError(f"No recorded data for {getattr(key, 'longname', repr(key))} in '{self.filepath}'")

        elif isinstance(key, str):
            if key in self._views_by_name:
                return self._views_by_name[key]
            # Tail-only lookup if unique among the recorded names
            tail = key.split(":", 1)[-1]
            matches = [n for n in self._views_by_name.keys()
                       if n.endswith(":" + tail) or n.endswith("." + tail) or n == tail]
            if len(matches) == 1:
                return self._views_by_name[matches[0]]
            raise KeyError(f"No recorded data for '{key}' in '{self.filepath}'")

        else:
            raise TypeError("Key must be a CanapeVariable or 'Device:Variable' string.")

    @property
    def signals(self) -> List[str]:
        # Only the signals explicitly configured in this recorder (preserve order)
        return list(self._ordered_names)

    def values(self) -> List[_SignalView]:
        out: List[_SignalView] = []
        for name in self._ordered_names:
            view = self._views_by_name.get(name)
            if view is not None:
                out.append(view)
        return out

    # Backward compatible helper to get names and y-arrays only
    def y_values(self) -> List[Tuple[str, np.ndarray]]:
        out: List[Tuple[str, np.ndarray]] = []
        for name in self._ordered_names:
            view = self._views_by_name.get(name)
            if view is not None:
                out.append((name, view.y))
        return out

    def close(self):
        try:
            if self._mdf is not None:
                self._mdf.close()
        except Exception:
            pass


class CanapeDevice:
    def __init__(self, app, device_com, name: str):
        self.app = app
        self.dev = device_com
        self.name = name


class CanapeAutomation:
    def __init__(self, project_path: Optional[str] = None):
        self.app = _dispatch_canape()
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except Exception:
            pass

        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"

        self.app.Open2(project_path, 1, 100000, 0, 0, 1)
        time.sleep(2)

        self.devices: Dict[str, CanapeDevice] = {}
        self._var_cache: Dict[str, CanapeVariable] = {}

    def add_device(self, name: str, a2l: str, dev_type: str, channel: int) -> CanapeDevice:
        dev_com = self.app.Devices.Add(name, a2l, dev_type, channel)
        dev = CanapeDevice(self.app, dev_com, name)
        self.devices[name] = dev
        return dev

    def go_online_all(self, reconnect: bool = False):
        for dev in self.devices.values():
            try:
                dev.dev.GoOnline(reconnect)
            except Exception:
                pass

    def close(self):
        try:
            for dev in self.devices.values():
                try:
                    dev.dev.GoOffline()
                except Exception:
                    pass
        finally:
            try:
                self.app.Quit()
            except Exception:
                pass

    def __getitem__(self, longname: str) -> CanapeVariable:
        if ":" not in longname:
            raise ValueError('Use "Device:Variable", e.g., "XCPsim:ampl"')
        devname, varname = longname.split(":", 1)
        if devname not in self.devices:
            raise KeyError(f"Device '{devname}' is not added.")
        key = f"{devname}:{varname}"
        if key in self._var_cache:
            return self._var_cache[key]
        var = CanapeVariable(self.app, self.devices[devname].dev, devname, varname)
        self._var_cache[key] = var
        return var

    @staticmethod
    def _normalize_vector_signals(
        vector_signals: Optional[Iterable[Union[str, CanapeVariable]]]
    ) -> List[VectorSignalRef]:
        """
        Accepts strings "Device:Signal" or CanapeVariable. Returns normalized VectorSignalRef list.
        """
        out: List[VectorSignalRef] = []
        if not vector_signals:
            return out
        for item in vector_signals:
            if isinstance(item, CanapeVariable):
                out.append(VectorSignalRef(item.device_name, item.varname))
            elif isinstance(item, str):
                if ":" not in item:
                    raise ValueError(f"Invalid vector signal '{item}', expected 'Device:Signal'")
                dev, sig = item.split(":", 1)
                out.append(VectorSignalRef(dev, sig))
            else:
                raise TypeError("vector_signals entries must be 'Device:Signal' or CanapeVariable")
        return out

    @contextmanager
    def recorder(
        self,
        *signals: Union[CanapeVariable, str],
        task: str = "100ms",
        sampling_time: Optional[int] = 100,
        mdf_path: Optional[str] = None,
        vector_signals: Optional[Iterable[Union[str, CanapeVariable]]] = None,
        vector_task: str = "cyclic",
        vector_sampling_time: Optional[int] = None,
        prefer_raw: bool = False,            # set True to read raw samples from MF4 for all channels
        prefer_enum_numeric: bool = True,    # if True, enum/text channels are re-read RAW to get numeric enum values
    ):
        """
        Start a measurement, add requested calibration variables into `task` (with `sampling_time`),
        and optionally add Vector driver signals into `vector_task` (with `vector_sampling_time`).
        The two groups are independent and can use different tasks/timing.

        prefer_raw: when False (default) reads PHYSICAL values (matches CANape UI);
                    when True reads RAW samples (unconverted) for all channels.
        prefer_enum_numeric: when True (default) converts enum/text channels to their numeric value by re-reading RAW.
        """
        if not signals and not vector_signals:
            raise TypeError("Provide at least one normal signal or vector_signals entry.")

        # Normalize normal signals -> CanapeVariable list
        var_list: List[CanapeVariable] = []
        for item in signals:
            if isinstance(item, CanapeVariable):
                var_list.append(item)
            elif isinstance(item, str):
                var_list.append(self[item])
            else:
                raise TypeError("Signals must be CanapeVariable or 'Device:Variable' strings.")

        # Normalize vector signals
        vector_refs: List[VectorSignalRef] = self._normalize_vector_signals(vector_signals)

        # Group normal vars by device
        cal_by_dev: Dict[str, List[CanapeVariable]] = {}
        for v in var_list:
            cal_by_dev.setdefault(v.device_name, []).append(v)

        # Track channels to clean up later as a simple list of tuples
        cleanup_items: List[Tuple[Any, str]] = []  # (task_com_object, channel_name)

        # Configure normal calibration variables
        for devname, dev_vars in cal_by_dev.items():
            dev_com = self.devices[devname].dev
            tsk = dev_com.Tasks(task)

            if sampling_time is not None:
                try:
                    tsk.SamplingTime = int(sampling_time)
                except Exception:
                    pass

            for v in dev_vars:
                try:
                    dev_com.CalibrationObjects.Add(v.varname)
                except Exception:
                    pass
                try:
                    tsk.Channels.Add(v.varname)
                    try:
                        tsk.Channels(v.varname).Save2MDF = True
                    except Exception:
                        pass
                    cleanup_items.append((tsk, v.varname))
                except Exception:
                    # ignore if already present or not addable
                    pass

        # Configure Vector driver signals (common task & sampling time for all)
        vec_by_dev: Dict[str, List[VectorSignalRef]] = {}
        for ref in vector_refs:
            vec_by_dev.setdefault(ref.device_name, []).append(ref)

        for devname, refs in vec_by_dev.items():
            if devname not in self.devices:
                raise KeyError(f"Vector driver device '{devname}' is not added.")
            dev_com = self.devices[devname].dev
            vtask = dev_com.Tasks(vector_task)

            if vector_sampling_time is not None:
                try:
                    vtask.SamplingTime = int(vector_sampling_time)
                except Exception:
                    pass

            for r in refs:
                try:
                    vtask.Channels.Add(r.signal_name)
                    try:
                        vtask.Channels(r.signal_name).Save2MDF = True
                    except Exception:
                        pass
                    cleanup_items.append((vtask, r.signal_name))
                except Exception:
                    # Ignore if already present or cannot be added
                    pass

        # MF4 path
        if mdf_path is None:
            stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            mdf_path = os.path.abspath(f"canape_recording_{stamp}.mf4")
        _ensure_parent_dir(mdf_path)
        try:
            self.app.Measurement.MDFFilename = mdf_path
        except Exception:
            pass

        # Start measurement
        try:
            self.app.Measurement.Start()
        except Exception:
            pass

        rec = RecorderResult(
            self.app,
            cleanup_items,
            var_list,
            vector_refs,
            mdf_path,
            prefer_raw=prefer_raw,
            prefer_enum_numeric=prefer_enum_numeric,
        )
        try:
            yield rec
        finally:
            rec.finalize()
