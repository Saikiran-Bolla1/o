#!/usr/bin/env python3
"""
Update, extend, and merge A2L files using symbol addresses from an ELF (with DWARF).

Highlights
- Correct member offsets for recursive struct/array traversal (handles DW_AT_data_member_location as constant, exprloc, block*, implicit_const, and bit offsets).
- Updates ECU_ADDRESS, ADDRESS, and VALUE (hex or decimal) in MEASUREMENT/CHARACTERISTIC blocks.
- Adds ALL filtered symbols by default, including containers (struct, array, union) such as:
  ErrStoreMgr, ErrStoreMgr._0_, ErrStoreMgr._0_.StandardFaultDataSet, and all nested leaves.
- Preserves recurring-symbol deltas among multiple A2L blocks with the same SYMBOL_LINK.
- Uppercases all hex addresses it touches.
- Merge multiple A2L files, appending missing MEASUREMENT and CHARACTERISTIC blocks from later files into the first.
  Optionally updates all addresses using an ELF after merging.

Configure behavior
- By default, addvariable includes containers (struct/array/union) in new blocks.
- To revert to old behavior (leaves only), set env A2L_INCLUDE_CONTAINERS=0 or pass CLI flag --leaves-only.

Requires: pip install pyelftools
"""

import sys
import re
import ast
import os
from typing import List, Dict, Optional, Tuple, Set, Union

from elftools.elf.elffile import ELFFile
from elftools.dwarf.descriptions import describe_form_class
from elftools.dwarf.dwarf_expr import DWARFExprParser

# ----------------------------
# Config / Debug
# ----------------------------
A2L_DEBUG = os.environ.get("A2L_DEBUG", "0") not in ("0", "", "false", "False")
DEFAULT_INCLUDE_CONTAINERS = os.environ.get("A2L_INCLUDE_CONTAINERS", "1") not in ("0", "", "false", "False")

# ----------------------------
# DWARF / Symbol helpers
# ----------------------------

MAX_ARRAY = 32

DW_ATE_ADDRESS        = 0x01
DW_ATE_BOOLEAN        = 0x02
DW_ATE_COMPLEX_FLOAT  = 0x03
DW_ATE_FLOAT          = 0x04
DW_ATE_SIGNED         = 0x05
DW_ATE_SIGNED_CHAR    = 0x06
DW_ATE_UNSIGNED       = 0x07
DW_ATE_UNSIGNED_CHAR  = 0x08

def get_symbols(elffile):
    """Return {name: {'addr': int, 'size': int, 'kind': str}} for variables/functions in symbol tables."""
    out = {}
    for secname in ('.symtab', '.dynsym'):
        sec = elffile.get_section_by_name(secname)
        if not sec or not hasattr(sec, "iter_symbols"):
            continue
        for s in sec.iter_symbols():
            name = s.name
            if not name:
                continue
            addr = int(s['st_value'] or 0)
            size = int(s['st_size'] or 0)
            st_type = s['st_info']['type']
            kind = st_type.lower() if isinstance(st_type, str) else str(st_type).lower()
            out[name] = {'addr': addr, 'size': size, 'kind': kind}
    return out

def resolve_typedefs(die):
    """Follow DW_AT_type chain until a concrete type tag."""
    if die is None:
        return None
    seen = set()
    cur = die
    while cur and cur.offset not in seen:
        seen.add(cur.offset)
        if cur.tag in ('DW_TAG_base_type', 'DW_TAG_pointer_type',
                       'DW_TAG_array_type', 'DW_TAG_structure_type', 'DW_TAG_union_type',
                       'DW_TAG_enumeration_type'):
            return cur
        if 'DW_AT_type' in cur.attributes:
            cur = cur.get_DIE_from_attribute('DW_AT_type')
        else:
            break
    return cur

def base_type_info(base_die):
    """Return (type_name, byte_size, encoding) for base/pointer/enum; else (unknown, size, None)."""
    if base_die is None:
        return ('unknown', None, None)
    if base_die.tag == 'DW_TAG_pointer_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('pointer', int(bs.value) if bs else None, None)
    if base_die.tag == 'DW_TAG_base_type':
        nm = base_die.attributes.get('DW_AT_name')
        bs = base_die.attributes.get('DW_AT_byte_size')
        enc = base_die.attributes.get('DW_AT_encoding')
        return (nm.value.decode('utf-8', 'ignore') if nm else 'unknown',
                int(bs.value) if bs else None,
                int(enc.value) if enc else None)
    if base_die.tag == 'DW_TAG_enumeration_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('enum', int(bs.value) if bs else None, DW_ATE_SIGNED)
    bs = base_die.attributes.get('DW_AT_byte_size')
    return ('unknown', int(bs.value) if bs else None, None)

def array_len_first_dim(array_die) -> Optional[int]:
    """Get first dimension length from DW_TAG_array_type."""
    for child in array_die.iter_children():
        if child.tag != 'DW_TAG_subrange_type':
            continue
        cnt = child.attributes.get('DW_AT_count')
        if cnt:
            return int(cnt.value)
        ub = child.attributes.get('DW_AT_upper_bound')
        lb = child.attributes.get('DW_AT_lower_bound')
        if ub and lb:
            return int(ub.value) - int(lb.value) + 1
        if ub:
            return int(ub.value) + 1
    return None

def dwarf_type_to_str(tname, tenc, tsize):
    if tenc == DW_ATE_UNSIGNED and tsize == 4: return "uint32"
    if tenc == DW_ATE_UNSIGNED and tsize == 2: return "ushort"
    if tenc == DW_ATE_UNSIGNED and tsize == 1: return "ubyte"
    if tenc == DW_ATE_SIGNED and tsize == 4: return "int32"
    if tenc == DW_ATE_SIGNED and tsize == 2: return "short"
    if tenc == DW_ATE_SIGNED and tsize == 1: return "byte"
    if tenc == DW_ATE_BOOLEAN: return "bool"
    return tname

def should_emit(name, filter_list, filter_hits):
    """Decide if we should EMIT a row for a given fully-qualified name."""
    if not filter_list:
        return True
    matched = False
    for f in filter_list:
        if name == f or name.startswith(f + ".") or name.startswith(f + "._"):
            matched = True
            if filter_hits is not None and f in filter_hits:
                filter_hits[f] += 1
    return matched

def should_traverse(name, filter_list):
    """Decide if we should TRAVERSE a top-level symbol for potential descendants."""
    if not filter_list:
        return True
    for f in filter_list:
        if name == f or name.startswith(f + ".") or name.startswith(f + "._"):
            return True
        if f.startswith(name + ".") or f.startswith(name + "._"):
            return True
    return False

def _decode_lit(op_name: str) -> Optional[int]:
    """Extract literal value from DW_OP_litN op names."""
    if not op_name.startswith('DW_OP_lit'):
        return None
    try:
        return int(op_name[len('DW_OP_lit'):])
    except Exception:
        return None

def _data_member_offset(member_die) -> int:
    """
    Return the byte offset of a struct/union member.

    Handles:
    - DW_AT_data_member_location class 'constant' or 'implicit_const'
    - DW_AT_data_member_location class 'exprloc' or 'block' (DWARF v2 encodings)
    - Bitfields via DW_AT_data_bit_offset / DW_AT_bit_offset -> add bits//8
    """
    loc_attr = member_die.attributes.get('DW_AT_data_member_location')
    bit_off_attr = member_die.attributes.get('DW_AT_data_bit_offset') or member_die.attributes.get('DW_AT_bit_offset')
    bit_extra = 0
    if bit_off_attr is not None:
        try:
            bit_extra = int(bit_off_attr.value) // 8
        except Exception:
            bit_extra = 0

    if not loc_attr:
        return bit_extra

    cls = describe_form_class(loc_attr.form)
    if cls == 'constant':
        try:
            return int(loc_attr.value) + bit_extra
        except Exception:
            return bit_extra

    if cls in ('exprloc', 'block'):
        try:
            parser = DWARFExprParser(member_die.cu.dwarfinfo.structs)
            ops = parser.parse_expr(loc_attr.value)

            offset = 0
            pending_const: Optional[int] = None

            for op in ops:
                name = op.op_name

                if name == 'DW_OP_plus_uconst':
                    try:
                        offset += int(op.args[0])
                    except Exception:
                        pass
                    continue

                if name in (
                    'DW_OP_constu', 'DW_OP_const1u', 'DW_OP_const2u',
                    'DW_OP_const4u', 'DW_OP_const8u',
                    'DW_OP_consts', 'DW_OP_const1s', 'DW_OP_const2s',
                    'DW_OP_const4s', 'DW_OP_const8s'
                ):
                    try:
                        pending_const = int(op.args[0])
                    except Exception:
                        pending_const = None
                    continue

                lit_val = _decode_lit(name)
                if lit_val is not None:
                    pending_const = lit_val
                    continue

                if name in ('DW_OP_plus', 'DW_OP_add'):
                    if pending_const is not None:
                        offset += pending_const
                        pending_const = None
                    continue

            if offset == 0 and pending_const is not None:
                offset += pending_const

            return int(offset) + bit_extra
        except Exception as e:
            if A2L_DEBUG:
                try:
                    form = str(loc_attr.form)
                except Exception:
                    form = "<unknown>"
                print(f"[A2L_DEBUG] Failed to parse member offset expr (form={form}): {e}")
            return bit_extra

    if A2L_DEBUG:
        try:
            form = str(loc_attr.form)
        except Exception:
            form = "<unknown>"
        print(f"[A2L_DEBUG] Unhandled data_member_location class '{cls}' (form={form}), using bit_extra={bit_extra}")
    return bit_extra

def collect_dwarf_struct_vars(prefix, base_addr, die, rows, symbols_dict, filter_list, filter_hits):
    """Recursively collect members/arrays with full hierarchical names using {prefix}._i_ for arrays."""
    die = resolve_typedefs(die)
    if not die:
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), "unknown", "", "unknown"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": "unknown",
                "byte_size": "",
                "kind": "unknown"
            }
        return

    tag = die.tag

    if tag == 'DW_TAG_array_type':
        elem_die = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
        elem_die = resolve_typedefs(elem_die)
        etname, esize, etenc = base_type_info(elem_die)
        n = array_len_first_dim(die) or 0
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), f"array[{n}]", esize if esize else "", "array"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": f"array[{n}]",
                "byte_size": esize if esize else "",
                "kind": "array"
            }
        n_print = min(n, MAX_ARRAY)
        for i in range(n_print):
            elem_size = esize if esize else 1
            eaddr = base_addr + i * elem_size
            array_elem_prefix = f"{prefix}._{i}_"
            if elem_die and elem_die.tag in ('DW_TAG_structure_type', 'DW_TAG_array_type', 'DW_TAG_union_type'):
                collect_dwarf_struct_vars(array_elem_prefix, eaddr, elem_die, rows, symbols_dict, filter_list, filter_hits)
            else:
                if should_emit(array_elem_prefix, filter_list, filter_hits):
                    row = [array_elem_prefix, hex(eaddr), dwarf_type_to_str(etname, etenc, esize), esize if esize else "", "array_elem"]
                    rows.append(row)
                    symbols_dict[array_elem_prefix] = {
                        "address": hex(eaddr),
                        "type": dwarf_type_to_str(etname, etenc, esize),
                        "byte_size": esize if esize else "",
                        "kind": "array_elem"
                    }
        return

    if tag == 'DW_TAG_structure_type':
        _, tsize, _ = base_type_info(die)
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), "struct", tsize if tsize else "", "struct"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": "struct",
                "byte_size": tsize if tsize else "",
                "kind": "struct"
            }
        for child in die.iter_children():
            if child.tag != 'DW_TAG_member':
                continue
            mname_attr = child.attributes.get('DW_AT_name')
            mname = mname_attr.value.decode('utf-8', 'ignore') if mname_attr else '<anon>'
            off = _data_member_offset(child)
            mt = child.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in child.attributes else None
            if not mt:
                continue
            collect_dwarf_struct_vars(f"{prefix}.{mname}", base_addr + off, mt, rows, symbols_dict, filter_list, filter_hits)
        return

    if tag == 'DW_TAG_union_type':
        _, tsize, _ = base_type_info(die)
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), "union", tsize if tsize else "", "union"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": "union",
                "byte_size": tsize if tsize else "",
                "kind": "union"
            }
        for child in die.iter_children():
            if child.tag != 'DW_TAG_member':
                continue
            mname_attr = child.attributes.get('DW_AT_name')
            mname = mname_attr.value.decode('utf-8', 'ignore') if mname_attr else '<anon>'
            mt = child.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in child.attributes else None
            if not mt:
                continue
            collect_dwarf_struct_vars(f"{prefix}.{mname}", base_addr, mt, rows, symbols_dict, filter_list, filter_hits)
        return

    # leaf/base types
    tname, tsize, tenc = base_type_info(die)
    if should_emit(prefix, filter_list, filter_hits):
        row = [prefix, hex(base_addr), dwarf_type_to_str(tname, tenc, tsize), tsize if tsize else "", "variable"]
        rows.append(row)
        symbols_dict[prefix] = {
            "address": hex(base_addr),
            "type": dwarf_type_to_str(tname, tenc, tsize),
            "byte_size": tsize if tsize else "",
            "kind": "variable"
        }

def build_symbols_dict(elf_path: str, filter_list: Optional[List[str]]) -> Tuple[Dict[str, Dict[str, str]], Set[str]]:
    """
    Use the collector logic to build a symbols_dict filtered by filter_list.
    Returns (symbols_dict, missing_filters)
    """
    with open(elf_path, 'rb') as f:
        elf = ELFFile(f)
        symbols = get_symbols(elf)

        if not elf.has_dwarf_info():
            raise RuntimeError("No DWARF info found in ELF file.")

        if filter_list and len(filter_list) > 0:
            print("Filters provided:", ", ".join(filter_list))
        else:
            print("No filters provided; processing all symbols.")

        dwarfinfo = elf.get_dwarf_info()
        rows = []
        symbols_dict: Dict[str, Dict[str, str]] = {}
        filter_hits = {f: 0 for f in (filter_list or [])}

        for name, meta in sorted(symbols.items(), key=lambda kv: kv[1]['addr']):
            if filter_list and not should_traverse(name, filter_list):
                continue
            addr = meta['addr']
            found = False
            for cu in dwarfinfo.iter_CUs():
                for die in cu.iter_DIEs():
                    if die.tag != 'DW_TAG_variable':
                        continue
                    n = die.attributes.get('DW_AT_name')
                    if not n:
                        continue
                    vname = n.value.decode('utf-8', 'ignore')
                    if vname == name:
                        tdie = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
                        if tdie:
                            collect_dwarf_struct_vars(name, addr, tdie, rows, symbols_dict, filter_list, filter_hits)
                        else:
                            if should_emit(name, filter_list, filter_hits):
                                symbols_dict[name] = {
                                    "address": hex(addr),
                                    "type": "unknown",
                                    "byte_size": "",
                                    "kind": "unknown"
                                }
                        found = True
                        break
                if found:
                    break

        unmatched = {f for f, c in filter_hits.items() if c == 0}
        if filter_list:
            if unmatched:
                print("Warning: the following filters matched no symbols:")
                for f in unmatched:
                    print(f" - {f}")
            else:
                print("All filters matched at least one symbol.")

        return symbols_dict, unmatched

# ----------------------------
# Hex helpers (force uppercase)
# ----------------------------

def _parse_hex_to_int(addr_hex) -> Optional[int]:
    if isinstance(addr_hex, int):
        return addr_hex
    if not isinstance(addr_hex, str):
        return None
    s = addr_hex.strip()
    try:
        if s.lower().startswith("0x"):
            return int(s, 16)
        return int(s, 16)
    except Exception:
        return None

def to_upper_hex(addr_hex: str) -> str:
    """
    Normalize any hex string like '0x1a2b' to '0x1A2B'. Accepts int as well.
    Returns input as string if parsing fails.
    """
    n = _parse_hex_to_int(addr_hex)
    if n is None:
        if isinstance(addr_hex, str) and addr_hex.strip().lower().startswith("0x"):
            return "0x" + addr_hex.strip()[2:].upper()
        return str(addr_hex)
    return f"0x{n:X}"

# ----------------------------
# A2L parsing and updating
# ----------------------------

class A2LBlock:
    def __init__(self,
                 kind: str,
                 name: str,
                 symbol: str,
                 begin_idx: int,
                 end_idx: int,
                 addr_line_idx: Optional[int],
                 old_addr_int: Optional[int],
                 old_addr_hex: Optional[str]):
        self.kind = kind  # "MEASUREMENT" or "CHARACTERISTIC"
        self.name = name
        self.symbol = symbol  # SYMBOL_LINK if present, else block name
        self.begin_idx = begin_idx
        self.end_idx = end_idx
        self.addr_line_idx = addr_line_idx
        self.old_addr_int = old_addr_int
        self.old_addr_hex = old_addr_hex

MEAS_BEGIN_RE = re.compile(r'^\s*/begin\s+MEASUREMENT\s+(\S+)')
CHAR_BEGIN_RE = re.compile(r'^\s*/begin\s+CHARACTERISTIC\s+(\S+)')
SYMBOL_LINK_RE = re.compile(r'^\s*SYMBOL_LINK\s+"([^"]+)"')
END_BLOCK_RE_TMPL = "/end {}"

# Capture and normalize hex in place
ECU_ADDRESS_RE = re.compile(r'^(\s*ECU_ADDRESS\s+)(0x[0-9A-Fa-f]+)(.*)$')
VALUE_ADDR_RE  = re.compile(r'^(\s*VALUE\s+)(0x[0-9A-Fa-f]+)(.*)$')
ADDRESS_RE     = re.compile(r'^(\s*ADDRESS\s+)(0x[0-9A-Fa-f]+)(.*)$')
# Decimal fallback for any of the 3 keywords
DEC_ANY_ADDR_RE = re.compile(r'^(\s*(?:ECU_ADDRESS|VALUE|ADDRESS)\s+)(\d+)(.*)$')

def parse_a2l_blocks(lines: List[str]) -> Tuple[List[A2LBlock], List[str]]:
    """
    Parse A2L lines and return list of blocks with their symbol names and positions.
    Captures the address line index and current address for delta computation.
    Recognizes ECU_ADDRESS, VALUE, and ADDRESS within blocks (first found wins).
    """
    blocks: List[A2LBlock] = []
    filters: List[str] = []

    i = 0
    n = len(lines)
    while i < n:
        line = lines[i]

        m_meas = MEAS_BEGIN_RE.match(line)
        m_char = CHAR_BEGIN_RE.match(line)

        if m_meas or m_char:
            kind = "MEASUREMENT" if m_meas else "CHARACTERISTIC"
            name = (m_meas or m_char).group(1)
            begin_idx = i
            symbol_name = name
            addr_line_idx: Optional[int] = None
            old_addr_hex: Optional[str] = None
            old_addr_int: Optional[int] = None

            # find end of block
            j = i + 1
            end_idx = None
            while j < n:
                l2 = lines[j]
                # capture SYMBOL_LINK if present
                m_sym = SYMBOL_LINK_RE.match(l2)
                if m_sym:
                    symbol_name = m_sym.group(1).strip()

                # capture first address line (any of the known keywords)
                if addr_line_idx is None:
                    m = ECU_ADDRESS_RE.match(l2) or VALUE_ADDR_RE.match(l2) or ADDRESS_RE.match(l2) or DEC_ANY_ADDR_RE.match(l2)
                    if m:
                        addr_line_idx = j
                        old_addr_hex = m.group(2)
                        # parse as hex if 0x, else int base 10
                        try:
                            if isinstance(old_addr_hex, str) and old_addr_hex.lower().startswith("0x"):
                                old_addr_int = int(old_addr_hex, 16)
                            else:
                                old_addr_int = int(old_addr_hex, 10)
                        except Exception:
                            old_addr_int = None

                if l2.strip().lower() == END_BLOCK_RE_TMPL.format(kind.lower()):
                    end_idx = j
                    break
                j += 1
            if end_idx is None:
                end_idx = n - 1  # Unclosed block - treat until EOF

            blocks.append(A2LBlock(kind=kind, name=name, symbol=symbol_name,
                                   begin_idx=begin_idx, end_idx=end_idx,
                                   addr_line_idx=addr_line_idx,
                                   old_addr_int=old_addr_int,
                                   old_addr_hex=old_addr_hex))

            if symbol_name not in filters:
                filters.append(symbol_name)

            i = end_idx + 1
            continue

        i += 1

    return blocks, filters

def force_uppercase_known_address_keywords(lines: List[str]) -> List[str]:
    """
    Ensure all ECU_ADDRESS, ADDRESS, and VALUE lines have uppercase hex for the address field.
    """
    out: List[str] = []
    for line in lines:
        raw = line.rstrip("\n")
        m = ECU_ADDRESS_RE.match(raw)
        if m:
            out.append(f"{m.group(1)}{to_upper_hex(m.group(2))}{m.group(3)}\n")
            continue
        m = ADDRESS_RE.match(raw)
        if m:
            out.append(f"{m.group(1)}{to_upper_hex(m.group(2))}{m.group(3)}\n")
            continue
        m = VALUE_ADDR_RE.match(raw)
        if m:
            out.append(f"{m.group(1)}{to_upper_hex(m.group(2))}{m.group(3)}\n")
            continue
        out.append(line)
    return out

def update_a2l_lines(lines: List[str], blocks: List[A2LBlock], addr_map: Dict[str, str]) -> Tuple[List[str], List[str]]:
    """
    Update the lines for each block using addr_map.

    Recurring symbol handling:
    - For symbols that appear in multiple blocks, we compute each block's original delta
      from the first occurrence's old address and apply that delta to the newly resolved base address.

    Returns updated lines and a list of warnings for blocks without matches.
    Also forces uppercase hex formatting for ECU_ADDRESS/ADDRESS/VALUE lines across the file.
    """
    out_lines = list(lines)
    warnings: List[str] = []

    # Group blocks by symbol to compute deltas per symbol
    symbol_groups: Dict[str, List[A2LBlock]] = {}
    for b in blocks:
        symbol_groups.setdefault(b.symbol, []).append(b)

    for symbol, group in symbol_groups.items():
        addr_hex = addr_map.get(symbol)
        if not addr_hex:
            for b in group:
                warnings.append(f"No address found for symbol '{symbol}' (block {b.kind} {b.name}).")
            continue

        base_new_int = _parse_hex_to_int(addr_hex)
        if base_new_int is None:
            for b in group:
                warnings.append(f"Resolved address for symbol '{symbol}' is invalid: {addr_hex}")
            continue

        # Determine reference old address (first block with an address)
        ref_old_int: Optional[int] = None
        for b in group:
            if b.old_addr_int is not None:
                ref_old_int = b.old_addr_int
                break

        multi = len(group) > 1 and ref_old_int is not None

        for b in group:
            if b.addr_line_idx is None:
                warnings.append(f"No address line found to update for symbol '{symbol}' (block {b.kind} {b.name}).")
                continue

            delta = 0
            if multi and b.old_addr_int is not None and ref_old_int is not None:
                delta = b.old_addr_int - ref_old_int

            new_addr_int = base_new_int + delta
            new_addr_hex = f"0x{new_addr_int:X}"

            old = out_lines[b.addr_line_idx].rstrip("\n")

            # Try all known patterns in order: ECU_ADDRESS, VALUE, ADDRESS, then decimal fallback
            m = ECU_ADDRESS_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{new_addr_hex}{m.group(3)}"
                out_lines[b.addr_line_idx] = new_line + "\n"
                continue

            m = VALUE_ADDR_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{new_addr_hex}{m.group(3)}"
                out_lines[b.addr_line_idx] = new_line + "\n"
                continue

            m = ADDRESS_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{new_addr_hex}{m.group(3)}"
                out_lines[b.addr_line_idx] = new_line + "\n"
                continue

            m = DEC_ANY_ADDR_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{new_addr_hex}{m.group(3)}"
                out_lines[b.addr_line_idx] = new_line + "\n"
                continue

            warnings.append(f"Could not update address line for symbol '{symbol}' (block {b.kind} {b.name}): '{old}'")

    # After updates, ensure all known keywords have uppercase hex addresses
    out_lines = force_uppercase_known_address_keywords(out_lines)

    return out_lines, warnings

# ----------------------------
# Helpers to create new blocks and placement
# ----------------------------

def _guess_datatype_and_limits(meta: Optional[Dict[str, str]]) -> Tuple[str, str, str, str]:
    """
    Guess A2L data keywords and limit ranges from symbol metadata.
    Returns tuple:
      (meas_datatype, char_deposit, lower, upper)
    For container nodes (struct/array/union), prefer ULONG width.
    """
    kind = (meta or {}).get("kind", "")
    if kind in ("struct", "array", "union"):
        return "ULONG", "ULong_Value", "0", "4294967295"

    t = (meta or {}).get("type", "") if meta else ""
    t = (t or "").lower()
    # Defaults
    meas = "UBYTE"
    dep = "UByte_Value"
    lower = "0"
    upper = "255"

    if t in ("bool",):
        meas, dep, lower, upper = "UBYTE", "UByte_Value", "0", "1"
    elif t in ("ubyte", "uint8", "unsigned char"):
        meas, dep, lower, upper = "UBYTE", "UByte_Value", "0", "255"
    elif t in ("byte", "int8", "signed char"):
        meas, dep, lower, upper = "SBYTE", "SByte_Value", "-128", "127"
    elif t in ("ushort", "uint16", "unsigned short"):
        meas, dep, lower, upper = "UWORD", "UWord_Value", "0", "65535"
    elif t in ("short", "int16", "signed short"):
        meas, dep, lower, upper = "SWORD", "SWord_Value", "-32768", "32767"
    elif t in ("uint32", "unsigned int", "unsigned long"):
        meas, dep, lower, upper = "ULONG", "ULong_Value", "0", "4294967295"
    elif t in ("int32", "signed int", "long", "int"):
        meas, dep, lower, upper = "SLONG", "SLong_Value", "-2147483648", "2147483647"
    elif "float" in t:
        meas, dep, lower, upper = "FLOAT32", "Float_Value", "-3.402823e+38", "3.402823e+38"

    return meas, dep, lower, upper

def _render_new_block(variablename: str, kind: str, addr_hex: str, meta: Optional[Dict[str, str]]) -> List[str]:
    """
    Render a minimal A2L block for variablename with given kind ('MEASUREMENT' or 'CHARACTERISTIC').
    Ensures uppercase hex for the address field.
    """
    meas_dt, char_dep, lower, upper = _guess_datatype_and_limits(meta)
    addr_hex_up = to_upper_hex(addr_hex)
    lines: List[str] = []
    if kind == "MEASUREMENT":
        lines.extend([
            f'/begin MEASUREMENT {variablename} ""\n',
            f'  {meas_dt} NO_COMPU_METHOD 0 0 {upper}\n',
            f'  ECU_ADDRESS {addr_hex_up}\n',
            f'  SYMBOL_LINK "{variablename}" 0\n',
            f'/end MEASUREMENT\n',
        ])
    else:  # CHARACTERISTIC
        lines.extend([
            f'/begin CHARACTERISTIC {variablename} ""\n',
            f'  VALUE {addr_hex_up} {char_dep} 0 NO_COMPU_METHOD 0 {upper}\n',
            f'  SYMBOL_LINK "{variablename}" 0\n',
            f'/end CHARACTERISTIC\n',
        ])
    return lines

def _normalize_variablename_input(variablename: Union[str, List[str]]) -> List[str]:
    """
    Accepts:
      - a list/tuple/set of names
      - a comma-separated string "A,B,C"
      - a Python/JSON-like list string '["A","B"]'
      - a single string "A"
    Returns a deduplicated list of trimmed names.
    """
    names: List[str] = []
    if isinstance(variablename, (list, tuple, set)):
        names = [str(x).strip() for x in variablename if str(x).strip()]
    elif isinstance(variablename, str):
        s = variablename.strip()
        if s.startswith("[") and s.endswith("]"):
            try:
                parsed = ast.literal_eval(s)
                if isinstance(parsed, (list, tuple, set)):
                    names = [str(x).strip() for x in parsed if str(x).strip()]
                else:
                    names = [s]
            except Exception:
                names = [p.strip() for p in s.strip("[]").split(",") if p.strip()]
        elif "," in s:
            names = [p.strip() for p in s.split(",") if p.strip()]
        elif s:
            names = [s]
    # Deduplicate preserving order
    seen = set()
    uniq = []
    for n in names:
        if n not in seen:
            seen.add(n)
            uniq.append(n)
    return uniq

def _find_insert_position_after_kind(lines: List[str], blocks: List[A2LBlock], kind: str) -> int:
    """
    Returns the line index to insert new blocks right after the last existing block of 'kind'.
    If none exist, returns len(lines) to append at the end.
    """
    last_end = -1
    for b in blocks:
        if b.kind == kind and b.end_idx > last_end:
            last_end = b.end_idx
    if last_end >= 0:
        return last_end + 1
    return len(lines)

# ----------------------------
# Public APIs
# ----------------------------

def Updatea2l(olda2l: str, elf: str, newa2l: str) -> None:
    """
    Read MEASUREMENT and CHARACTERISTIC symbols from olda2l,
    resolve addresses from elf (DWARF + symtab) using the collector with filtering,
    and write updated a2l to newa2l.
    """
    with open(olda2l, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    blocks, filters = parse_a2l_blocks(lines)
    if not blocks:
        print("No MEASUREMENT or CHARACTERISTIC blocks found in A2L.")
    else:
        print(f"Found {len(blocks)} blocks to process.")
    if filters:
        print("Symbols to resolve from ELF:")
        for s in filters:
            print(f" - {s}")

    symbols_dict, missing_filters = build_symbols_dict(elf, filters)
    # Uppercase addresses in map
    addr_map = {name: to_upper_hex(meta["address"]) for name, meta in symbols_dict.items()}
    print(f"Resolved {len(addr_map)} symbol addresses from ELF/DWARF.")

    updated_lines, warnings = update_a2l_lines(lines, blocks, addr_map)

    for w in warnings:
        print("Warning:", w)
    if missing_filters:
        print("These A2L symbols were not found in ELF/DWARF:")
        for s in sorted(missing_filters):
            print(f" - {s}")

    with open(newa2l, "w", encoding="utf-8", errors="ignore") as f:
        f.writelines(updated_lines)
    print(f"Saved updated A2L to: {newa2l}")

def addvariable(olda2l: str, elf: str, variablename: Union[str, List[str]], vartype: str, outputfile: str, include_containers: Optional[bool] = None) -> None:
    """
    Add new variables (ALL filtered, missing from A2L) and update all existing addresses.

    Placement:
    - MEASUREMENT additions are inserted right after the last existing MEASUREMENT block.
    - CHARACTERISTIC additions are inserted right after the last existing CHARACTERISTIC block.
    - Ensure exactly one blank line between new blocks, and one blank line before the first inserted block if needed.

    Parameters:
    - olda2l: path to existing A2L file
    - elf: path to ELF file (with DWARF)
    - variablename: a symbol filter or list of filters (supports members/array elements like Var._0_)
    - vartype: 'characteristic' or 'measurement' (case-insensitive) used for ALL new blocks appended
    - outputfile: path to write updated A2L
    - include_containers: include struct/array/union nodes as A2L entries (default: env A2L_INCLUDE_CONTAINERS, default True)
    """
    kind = (vartype or "").strip().upper()
    if kind not in ("CHARACTERISTIC", "MEASUREMENT"):
        raise ValueError("vartype must be 'characteristic' or 'measurement'")

    if include_containers is None:
        include_containers = DEFAULT_INCLUDE_CONTAINERS

    with open(olda2l, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    # Parse existing blocks and build base filters from A2L
    blocks, filters = parse_a2l_blocks(lines)
    existing_symbols = {b.symbol for b in blocks}

    # Normalize variablename into a list of tokens and add to filters
    extra_filters = _normalize_variablename_input(variablename)
    for tok in extra_filters:
        if tok not in filters:
            filters.append(tok)

    print(f"Starting 'addvariable' with {len(filters)} filter token(s).")
    if extra_filters:
        print("- Added filter token(s):", ", ".join(extra_filters))
    print(f"- include_containers = {include_containers}")

    # Resolve all symbols for these filters
    symbols_dict, missing_filters = build_symbols_dict(elf, filters)
    # Uppercase addresses in map
    addr_map = {name: to_upper_hex(meta["address"]) for name, meta in symbols_dict.items()}
    print(f"Resolved {len(addr_map)} addresses from ELF.")

    # 1) Update addresses for existing blocks (with recurring symbol delta handling)
    updated_lines, warnings = update_a2l_lines(lines, blocks, addr_map)
    for w in warnings:
        print("Warning:", w)

    # 2) Append ALL filtered symbols that are not already present in the A2L
    if include_containers:
        missing_symbols = [
            name for name in symbols_dict.keys()
            if name not in existing_symbols
        ]
    else:
        missing_symbols = [
            name for name, meta in symbols_dict.items()
            if name not in existing_symbols and meta.get("kind") not in ("struct", "array", "union")
        ]

    if not missing_symbols:
        print("No new filtered symbols to add; only addresses were updated.")
        with open(outputfile, "w", encoding="utf-8", errors="ignore") as f:
            f.writelines(updated_lines)
        print(f"Saved updated A2L to: {outputfile}")
        return

    print(f"Adding {len(missing_symbols)} new {kind} block(s) for filtered symbols not present in A2L.")

    # Build the block text with one blank line between blocks
    insert_lines: List[str] = []
    for idx, name in enumerate(sorted(missing_symbols)):
        meta = symbols_dict.get(name, {})
        addr_hex = to_upper_hex(meta.get("address", "0x0"))
        block_lines = _render_new_block(name, kind, addr_hex, meta)
        insert_lines.extend(block_lines)
        if idx != len(missing_symbols) - 1:
            insert_lines.append("\n")  # one blank line between new variables

    # Find insertion point after the last block of the given kind
    insert_idx = _find_insert_position_after_kind(updated_lines, blocks, kind)

    # Ensure exactly one blank line before the first inserted block (if not at start)
    if insert_idx > 0:
        prev_line = updated_lines[insert_idx - 1]
        if prev_line.strip() != "":
            updated_lines[insert_idx:insert_idx] = ["\n"]
            insert_idx += 1
        else:
            # If there are multiple blank lines, collapse to a single one
            k = insert_idx - 1
            while k - 1 >= 0 and updated_lines[k - 1].strip() == "":
                del updated_lines[k - 1]
                insert_idx -= 1
                k -= 1

    # Insert the new blocks at the computed position
    updated_lines[insert_idx:insert_idx] = insert_lines

    # Final pass: ensure uppercase hex on known keywords everywhere
    updated_lines = force_uppercase_known_address_keywords(updated_lines)

    with open(outputfile, "w", encoding="utf-8", errors="ignore") as f:
        f.writelines(updated_lines)
    print(f"Appended {len(missing_symbols)} new {kind} block(s) after last {kind} section and saved to: {outputfile}")

def mergea2l(a2l_files: Union[str, List[str]], outputfile: str, elf: Optional[str] = None) -> None:
    """
    Merge MEASUREMENT and CHARACTERISTIC blocks from multiple A2L files.

    Behavior:
    - Uses the first A2L file as the base.
    - Appends missing MEASUREMENT blocks from subsequent files immediately after the last MEASUREMENT in the first file.
    - Appends missing CHARACTERISTIC blocks after the last CHARACTERISTIC in the first file.
    - Missing is determined by the pair (block kind, SYMBOL_LINK name). If SYMBOL_LINK is absent, the block name is used.
    - Ensures exactly one blank line between inserted blocks and a single blank line before the first inserted block per kind.
    - Forces uppercase hex formatting for ECU_ADDRESS/ADDRESS/VALUE lines.
    - If an ELF is provided, resolves addresses for all symbols present in the merged file and updates them.

    Parameters:
    - a2l_files: list of input A2L file paths (first is base).
    - outputfile: path to write merged A2L.
    - elf: optional path to ELF file with DWARF for address updates.
    """
    # Normalize a2l_files to a list
    if isinstance(a2l_files, (str,)):
        a2l_files = [a2l_files]
    a2l_files = [p for p in a2l_files if str(p).strip()]

    if len(a2l_files) < 1:
        raise ValueError("At least one A2L file must be provided to merge.")
    if len(a2l_files) == 1:
        # Single file: copy and optionally update with ELF
        print("Only one A2L file provided; copying as base.")
        with open(a2l_files[0], "r", encoding="utf-8", errors="ignore") as f:
            base_lines = f.readlines()
    else:
        with open(a2l_files[0], "r", encoding="utf-8", errors="ignore") as f:
            base_lines = f.readlines()

    base_blocks, _ = parse_a2l_blocks(base_lines)
    # De-dup by (kind, symbol)
    existing_pairs: Set[Tuple[str, str]] = {(b.kind, b.symbol) for b in base_blocks}

    added_meas_blocks: List[List[str]] = []
    added_char_blocks: List[List[str]] = []

    # Collect blocks from subsequent files
    for path in a2l_files[1:]:
        print(f"Scanning A2L file for merge: {path}")
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()
        except Exception as e:
            print(f"Warning: Failed to read '{path}': {e}")
            continue

        blocks, _ = parse_a2l_blocks(lines)
        for b in blocks:
            key = (b.kind, b.symbol)
            if key in existing_pairs:
                continue
            # Slice the original block text (inclusive of begin/end lines)
            block_lines = lines[b.begin_idx:b.end_idx + 1]
            # Ensure block closes with newline (lines are already newline-terminated)
            if b.kind == "MEASUREMENT":
                added_meas_blocks.append(block_lines)
            else:
                added_char_blocks.append(block_lines)
            existing_pairs.add(key)

    # Insert MEASUREMENT blocks first
    if added_meas_blocks:
        print(f"Adding {len(added_meas_blocks)} MEASUREMENT block(s) to base A2L.")
        # Build insertion payload with one blank line between blocks
        insert_lines_meas: List[str] = []
        for idx, bl in enumerate(added_meas_blocks):
            insert_lines_meas.extend(bl)
            if idx != len(added_meas_blocks) - 1:
                insert_lines_meas.append("\n")

        insert_idx_meas = _find_insert_position_after_kind(base_lines, base_blocks, "MEASUREMENT")
        # Ensure exactly one blank line before insertion (if not at start)
        if insert_idx_meas > 0:
            if base_lines[insert_idx_meas - 1].strip() != "":
                base_lines[insert_idx_meas:insert_idx_meas] = ["\n"]
                insert_idx_meas += 1
            else:
                # Collapse multiple blank lines to one
                k = insert_idx_meas - 1
                while k - 1 >= 0 and base_lines[k - 1].strip() == "":
                    del base_lines[k - 1]
                    insert_idx_meas -= 1
                    k -= 1
        base_lines[insert_idx_meas:insert_idx_meas] = insert_lines_meas

        # Re-parse blocks after MEAS insertion to get accurate indexes for CHARACTERISTIC insertion
        base_blocks, _ = parse_a2l_blocks(base_lines)

    # Insert CHARACTERISTIC blocks
    if added_char_blocks:
        print(f"Adding {len(added_char_blocks)} CHARACTERISTIC block(s) to base A2L.")
        insert_lines_char: List[str] = []
        for idx, bl in enumerate(added_char_blocks):
            insert_lines_char.extend(bl)
            if idx != len(added_char_blocks) - 1:
                insert_lines_char.append("\n")

        insert_idx_char = _find_insert_position_after_kind(base_lines, base_blocks, "CHARACTERISTIC")
        # Ensure exactly one blank line before insertion (if not at start)
        if insert_idx_char > 0:
            if base_lines[insert_idx_char - 1].strip() != "":
                base_lines[insert_idx_char:insert_idx_char] = ["\n"]
                insert_idx_char += 1
            else:
                # Collapse multiple blank lines to one
                k = insert_idx_char - 1
                while k - 1 >= 0 and base_lines[k - 1].strip() == "":
                    del base_lines[k - 1]
                    insert_idx_char -= 1
                    k -= 1
        base_lines[insert_idx_char:insert_idx_char] = insert_lines_char

    # Normalize hex formatting for known address keywords
    base_lines = force_uppercase_known_address_keywords(base_lines)

    # If ELF provided, resolve and update all addresses in merged file
    if elf:
        print(f"Updating addresses in merged A2L using ELF: {elf}")
        merged_blocks, filters = parse_a2l_blocks(base_lines)
        if not filters:
            print("No symbols found to update in merged A2L.")
        else:
            try:
                symbols_dict, missing_filters = build_symbols_dict(elf, filters)
                addr_map = {name: to_upper_hex(meta["address"]) for name, meta in symbols_dict.items()}
                base_lines, warnings = update_a2l_lines(base_lines, merged_blocks, addr_map)
                for w in warnings:
                    print("Warning:", w)
                if missing_filters:
                    print("These A2L symbols were not found in ELF/DWARF:")
                    for s in sorted(missing_filters):
                        print(f" - {s}")
            except Exception as e:
                print(f"Warning: Failed to update addresses from ELF: {e}")

    with open(outputfile, "w", encoding="utf-8", errors="ignore") as f:
        f.writelines(base_lines)

    print(f"Merged A2L saved to: {outputfile}")

# ----------------------------
# CLI
# ----------------------------

def _main(argv: List[str]) -> int:
    if len(argv) < 2:
        print(f"Usage:\n"
              f"  {argv[0]} update <olda2l> <elf> <newa2l>\n"
              f"  {argv[0]} add <olda2l> <elf> <variablename|list> <characteristic|measurement> <outputfile> [--leaves-only|--include-containers]\n"
              f"  {argv[0]} merge <outputfile> <a2l1> [<a2l2> ...] [--elf <elf>]\n\n"
              f"Notes:\n"
              f"- 'add' updates addresses for existing blocks AND appends filtered symbols missing from the A2L.\n"
              f"- Filters = all symbols referenced in the A2L + provided variablename(s).\n"
              f"- variablename can be comma-separated (A,B,C) or a JSON-like list string (e.g., [\"A\",\"B\"]).\n"
              f"- New blocks are inserted right after the last block of the same kind.\n"
              f"- All ECU_ADDRESS/ADDRESS/VALUE addresses are emitted in uppercase hex.\n"
              f"- Recurring symbols: per-block address deltas relative to the first occurrence are preserved on update.\n"
              f"- By default, containers (struct/array/union) are included; use --leaves-only or A2L_INCLUDE_CONTAINERS=0 to skip them.\n"
              f"- 'merge' uses the first A2L as base, appends missing MEASUREMENTs and CHARACTERISTICs from others,\n"
              f"  and optionally updates addresses using --elf.")
        return 1

    cmd = argv[1].lower()
    if cmd == "update":
        if len(argv) < 5:
            print(f"Usage: {argv[0]} update <olda2l> <elf> <newa2l>")
            return 1
        _, _, olda2l, elf, newa2l = argv[:5]
        Updatea2l(olda2l, elf, newa2l)
        return 0

    if cmd == "add":
        if len(argv) < 7:
            print(f"Usage: {argv[0]} add <olda2l> <elf> <variablename|list> <characteristic|measurement> <outputfile> [--leaves-only|--include-containers]")
            return 1
        _, _, olda2l, elf, variablename_arg, vartype, outputfile = argv[:7]
        flags = set(a.lower() for a in argv[7:])
        include_containers = DEFAULT_INCLUDE_CONTAINERS
        if "--leaves-only" in flags:
            include_containers = False
        if "--include-containers" in flags:
            include_containers = True
        variablename_list = _normalize_variablename_input(variablename_arg)
        addvariable(olda2l, elf, variablename_list, vartype, outputfile, include_containers=include_containers)
        return 0

    if cmd == "merge":
        if len(argv) < 5:
            print(f"Usage: {argv[0]} merge <outputfile> <a2l1> [<a2l2> ...] [--elf <elf>]")
            return 1
        # Parse args: outputfile + a2l files (+ optional --elf <elf>)
        args = argv[2:]
        # Extract --elf if present
        elf_path: Optional[str] = None
        if "--elf" in args:
            idx = args.index("--elf")
            if idx + 1 >= len(args):
                print(f"Usage: {argv[0]} merge <outputfile> <a2l1> [<a2l2> ...] [--elf <elf>]")
                return 1
            elf_path = args[idx + 1]
            # Remove flag and value
            args = args[:idx] + args[idx + 2:]

        if len(args) < 2:
            print(f"Usage: {argv[0]} merge <outputfile> <a2l1> [<a2l2> ...] [--elf <elf>]")
            return 1

        outputfile = args[0]
        a2l_files = args[1:]
        mergea2l(a2l_files, outputfile, elf=elf_path)
        return 0

    print(f"Unknown command: {cmd}")
    return 1

if __name__ == "__main__":
    sys.exit(_main(sys.argv))
