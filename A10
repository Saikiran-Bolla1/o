#!/usr/bin/env python3
import sys
from elftools.elf.elffile import ELFFile
from elftools.dwarf.descriptions import describe_form_class

MAX_ARRAY = 32

# DWARF encodings
DW_ATE_ADDRESS        = 0x01
DW_ATE_BOOLEAN        = 0x02
DW_ATE_COMPLEX_FLOAT  = 0x03
DW_ATE_FLOAT          = 0x04
DW_ATE_SIGNED         = 0x05
DW_ATE_SIGNED_CHAR    = 0x06
DW_ATE_UNSIGNED       = 0x07
DW_ATE_UNSIGNED_CHAR  = 0x08


def get_object_symbols(elffile):
    """Return {name: {'addr': int, 'size': int}} for variables from .symtab + .dynsym"""
    out = {}
    for secname in ('.symtab', '.dynsym'):
        sec = elffile.get_section_by_name(secname)
        if not sec or not hasattr(sec, "iter_symbols"):
            continue
        for s in sec.iter_symbols():
            if s['st_info']['type'] != 'STT_OBJECT':
                continue
            if not s.name:
                continue
            addr = int(s['st_value'] or 0)
            if addr == 0:
                continue  # skip undef/ABS
            out[s.name] = {'addr': addr, 'size': int(s['st_size'] or 0)}
    return out


def iter_dwarf_variables(dwarfinfo):
    """Map variable name -> DIE (only those with a type)."""
    out = {}
    for cu in dwarfinfo.iter_CUs():
        for die in cu.iter_DIEs():
            if die.tag != 'DW_TAG_variable':
                continue
            n = die.attributes.get('DW_AT_name')
            if not n:
                continue
            if 'DW_AT_type' not in die.attributes:
                continue
            name = n.value.decode('utf-8', 'ignore')
            out[name] = die
    return out


def resolve_typedefs(die):
    """Follow DW_AT_type until a concrete type tag."""
    seen = set()
    cur = die
    while cur and cur.offset not in seen:
        seen.add(cur.offset)
        if cur.tag in ('DW_TAG_base_type', 'DW_TAG_pointer_type',
                       'DW_TAG_array_type', 'DW_TAG_structure_type', 'DW_TAG_union_type',
                       'DW_TAG_enumeration_type'):
            return cur
        if 'DW_AT_type' in cur.attributes:
            cur = cur.get_DIE_from_attribute('DW_AT_type')
        else:
            break
    return cur


def base_type_info(base_die):
    """Return (type_name, byte_size, encoding) for a DW_TAG_base_type or pointer; else (unknown, size, None)."""
    if base_die is None:
        return ('unknown', None, None)

    if base_die.tag == 'DW_TAG_pointer_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('pointer', int(bs.value) if bs else None, None)

    if base_die.tag == 'DW_TAG_base_type':
        nm = base_die.attributes.get('DW_AT_name')
        bs = base_die.attributes.get('DW_AT_byte_size')
        enc = base_die.attributes.get('DW_AT_encoding')
        return (nm.value.decode('utf-8', 'ignore') if nm else 'unknown',
                int(bs.value) if bs else None,
                int(enc.value) if enc else None)

    # enums: treat as signed int with its byte size
    if base_die.tag == 'DW_TAG_enumeration_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('enum', int(bs.value) if bs else None, DW_ATE_SIGNED)

    # unknown composite: no size known
    bs = base_die.attributes.get('DW_AT_byte_size')
    return ('unknown', int(bs.value) if bs else None, None)


def array_len_first_dim(array_die):
    """Get first dimension length from DW_TAG_array_type."""
    for child in array_die.iter_children():
        if child.tag != 'DW_TAG_subrange_type':
            continue
        cnt = child.attributes.get('DW_AT_count')
        if cnt:
            return int(cnt.value)
        ub = child.attributes.get('DW_AT_upper_bound')
        lb = child.attributes.get('DW_AT_lower_bound')
        if ub and lb:
            return int(ub.value) - int(lb.value) + 1
        if ub:
            return int(ub.value) + 1
    return None


def int_min_max(encoding, byte_size):
    if byte_size is None:
        return (None, None)
    bits = 8 * byte_size
    if encoding in (DW_ATE_UNSIGNED, DW_ATE_UNSIGNED_CHAR):
        return (0, (1 << bits) - 1)
    if encoding in (DW_ATE_SIGNED, DW_ATE_SIGNED_CHAR):
        return (-(1 << (bits - 1)), (1 << (bits - 1)) - 1)
    if encoding == DW_ATE_BOOLEAN:
        return (0, 1)
    return (None, None)  # floats/pointers/unknown


def member_offset(member_die):
    """Return member byte offset if it is a constant; otherwise None (skip complex exprloc)."""
    loc = member_die.attributes.get('DW_AT_data_member_location')
    if not loc:
        return 0
    # Many compilers encode this as a constant data form
    if describe_form_class(loc.form) == 'constant':
        return int(loc.value)
    # exprloc often means base + const; we keep it simple and skip if not constant
    return None


def emit_leaf(name, addr, base_die):
    tname, tsize, tenc = base_type_info(base_die)
    vmin, vmax = int_min_max(tenc, tsize)
    print(f"{name}  type={tname} addr=0x{addr:x} size={tsize if tsize is not None else ''} min={vmin} max={vmax}")


def emit_type_recursive(prefix, base_addr, type_die):
    """Recursively emit fields/elements for a given type."""
    type_die = resolve_typedefs(type_die)
    if not type_die:
        print(f"{prefix}  type=unknown addr=0x{base_addr:x}")
        return

    tag = type_die.tag

    # 1) Array
    if tag == 'DW_TAG_array_type':
        elem_die = type_die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in type_die.attributes else None
        elem_die = resolve_typedefs(elem_die)
        etname, esize, _ = base_type_info(elem_die)
        if not esize or esize == 0:
            esize = 1
        n = array_len_first_dim(type_die) or 0
        n_print = min(n, MAX_ARRAY)
        for i in range(n_print):
            eaddr = base_addr + i * esize
            # If the element itself is composite (struct/array), recurse; otherwise print leaf
            if elem_die and elem_die.tag in ('DW_TAG_structure_type', 'DW_TAG_array_type'):
                emit_type_recursive(f"{prefix}._{i}_", eaddr, elem_die)
            else:
                print(f"{prefix}._{i}_  type={etname} addr=0x{eaddr:x} size={esize}")
        # Array summary line (like tools show the node)
        print(f"{prefix}  type=array[{n}] of {etname} base_addr=0x{base_addr:x} elem_size={esize}")
        return

    # 2) Struct
    if tag == 'DW_TAG_structure_type':
        # Optional: a struct summary line
        print(f"{prefix}  type=struct base_addr=0x{base_addr:x}")
        for child in type_die.iter_children():
            if child.tag != 'DW_TAG_member':
                continue
            mname_attr = child.attributes.get('DW_AT_name')
            mname = mname_attr.value.decode('utf-8', 'ignore') if mname_attr else '<anon>'
            off = member_offset(child)
            if off is None:
                # Cannot resolve complex offset → skip safely
                continue
            mt = child.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in child.attributes else None
            if not mt:
                continue
            emit_type_recursive(f"{prefix}.{mname}", base_addr + off, mt)
        return

    # 3) Union — emit members at same address
    if tag == 'DW_TAG_union_type':
        print(f"{prefix}  type=union base_addr=0x{base_addr:x}")
        for child in type_die.iter_children():
            if child.tag != 'DW_TAG_member':
                continue
            mname_attr = child.attributes.get('DW_AT_name')
            mname = mname_attr.value.decode('utf-8', 'ignore') if mname_attr else '<anon>'
            mt = child.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in child.attributes else None
            if not mt:
                continue
            emit_type_recursive(f"{prefix}.{mname}", base_addr, mt)
        return

    # 4) Pointer / Base / Enum → leaf
    emit_leaf(prefix, base_addr, type_die)


def main(path):
    with open(path, 'rb') as f:
        elf = ELFFile(f)
        symmap = get_object_symbols(elf)

        if not elf.has_dwarf_info():
            for name, meta in sorted(symmap.items(), key=lambda kv: kv[1]['addr']):
                print(f"{name}  type=unknown addr=0x{meta['addr']:x} size={meta['size']}")
            return

        dwarfinfo = elf.get_dwarf_info()
        dwarf_vars = iter_dwarf_variables(dwarfinfo)

        for name, meta in sorted(symmap.items(), key=lambda kv: kv[1]['addr']):
            die = dwarf_vars.get(name)
            if not die:
                # No DWARF for symbol → show basic info
                print(f"{name}  type=unknown addr=0x{meta['addr']:x} size={meta['size']}")
                continue
            tdie = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
            if not tdie:
                print(f"{name}  type=unknown addr=0x{meta['addr']:x} size={meta['size']}")
                continue

            # Expand recursively from the top-level variable
            emit_type_recursive(name, meta['addr'], tdie)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <elf-file>")
        sys.exit(1)
    main(sys.argv[1])
