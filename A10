#!/usr/bin/env python3
import sys
import csv
from elftools.elf.elffile import ELFFile
from elftools.dwarf.descriptions import describe_form_class

MAX_ARRAY = 32

DW_ATE_ADDRESS        = 0x01
DW_ATE_BOOLEAN        = 0x02
DW_ATE_COMPLEX_FLOAT  = 0x03
DW_ATE_FLOAT          = 0x04
DW_ATE_SIGNED         = 0x05
DW_ATE_SIGNED_CHAR    = 0x06
DW_ATE_UNSIGNED       = 0x07
DW_ATE_UNSIGNED_CHAR  = 0x08

def get_symbols(elffile):
    """Return {name: {'addr': int, 'size': int, 'kind': str}} for variables/functions in symbol tables."""
    out = {}
    for secname in ('.symtab', '.dynsym'):
        sec = elffile.get_section_by_name(secname)
        if not sec or not hasattr(sec, "iter_symbols"):
            continue
        for s in sec.iter_symbols():
            name = s.name
            if not name: continue
            addr = int(s['st_value'] or 0)
            size = int(s['st_size'] or 0)
            st_type = s['st_info']['type']
            kind = st_type.lower()
            out[name] = {'addr': addr, 'size': size, 'kind': kind}
    return out

def resolve_typedefs(die):
    """Follow DW_AT_type chain until a concrete type tag."""
    seen = set()
    cur = die
    while cur and cur.offset not in seen:
        seen.add(cur.offset)
        if cur.tag in ('DW_TAG_base_type', 'DW_TAG_pointer_type',
                       'DW_TAG_array_type', 'DW_TAG_structure_type', 'DW_TAG_union_type',
                       'DW_TAG_enumeration_type'):
            return cur
        if 'DW_AT_type' in cur.attributes:
            cur = cur.get_DIE_from_attribute('DW_AT_type')
        else:
            break
    return cur

def base_type_info(base_die):
    """Return (type_name, byte_size, encoding) for a DW_TAG_base_type or pointer; else (unknown, size, None)."""
    if base_die is None:
        return ('unknown', None, None)
    if base_die.tag == 'DW_TAG_pointer_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('pointer', int(bs.value) if bs else None, None)
    if base_die.tag == 'DW_TAG_base_type':
        nm = base_die.attributes.get('DW_AT_name')
        bs = base_die.attributes.get('DW_AT_byte_size')
        enc = base_die.attributes.get('DW_AT_encoding')
        return (nm.value.decode('utf-8', 'ignore') if nm else 'unknown',
                int(bs.value) if bs else None,
                int(enc.value) if enc else None)
    if base_die.tag == 'DW_TAG_enumeration_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('enum', int(bs.value) if bs else None, DW_ATE_SIGNED)
    bs = base_die.attributes.get('DW_AT_byte_size')
    return ('unknown', int(bs.value) if bs else None, None)

def array_len_first_dim(array_die):
    """Get first dimension length from DW_TAG_array_type."""
    for child in array_die.iter_children():
        if child.tag != 'DW_TAG_subrange_type':
            continue
        cnt = child.attributes.get('DW_AT_count')
        if cnt:
            return int(cnt.value)
        ub = child.attributes.get('DW_AT_upper_bound')
        lb = child.attributes.get('DW_AT_lower_bound')
        if ub and lb:
            return int(ub.value) - int(lb.value) + 1
        if ub:
            return int(ub.value) + 1
    return None

def dwarf_type_to_str(tname, tenc, tsize):
    if tenc == DW_ATE_UNSIGNED and tsize == 4: return "uint32"
    if tenc == DW_ATE_UNSIGNED and tsize == 2: return "ushort"
    if tenc == DW_ATE_UNSIGNED and tsize == 1: return "ubyte"
    if tenc == DW_ATE_SIGNED and tsize == 4: return "int32"
    if tenc == DW_ATE_SIGNED and tsize == 2: return "short"
    if tenc == DW_ATE_SIGNED and tsize == 1: return "byte"
    if tenc == DW_ATE_BOOLEAN: return "bool"
    return tname

def collect_dwarf_struct_vars(prefix, base_addr, die, rows):
    """Recursively collect all members, arrays, and fields with full hierarchical name."""
    die = resolve_typedefs(die)
    if not die:
        rows.append([prefix, hex(base_addr), "unknown", "", "unknown"])
        return

    tag = die.tag

    if tag == 'DW_TAG_array_type':
        elem_die = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
        elem_die = resolve_typedefs(elem_die)
        etname, esize, etenc = base_type_info(elem_die)
        n = array_len_first_dim(die) or 0
        n_print = min(n, MAX_ARRAY)
        for i in range(n_print):
            eaddr = base_addr + i * (esize if esize else 1)
            # Recursively collect element members if struct/array
            if elem_die and elem_die.tag in ('DW_TAG_structure_type', 'DW_TAG_array_type'):
                collect_dwarf_struct_vars(f"{prefix}_{i}_", eaddr, elem_die, rows)
            else:
                rows.append([f"{prefix}_{i}_", hex(eaddr), dwarf_type_to_str(etname, etenc, esize), esize if esize else "", "array_elem"])
        rows.append([prefix, hex(base_addr), f"array[{n}]", esize if esize else "", "array"])
        return

    if tag == 'DW_TAG_structure_type':
        for child in die.iter_children():
            if child.tag != 'DW_TAG_member':
                continue
            mname_attr = child.attributes.get('DW_AT_name')
            mname = mname_attr.value.decode('utf-8', 'ignore') if mname_attr else '<anon>'
            loc = child.attributes.get('DW_AT_data_member_location')
            off = 0
            if loc and describe_form_class(loc.form) == 'constant':
                off = int(loc.value)
            mt = child.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in child.attributes else None
            if not mt:
                continue
            collect_dwarf_struct_vars(f"{prefix}.{mname}", base_addr + off, mt, rows)
        return

    # For base/pointer types, add leaf
    tname, tsize, tenc = base_type_info(die)
    rows.append([prefix, hex(base_addr), dwarf_type_to_str(tname, tenc, tsize), tsize if tsize else "", "variable"])

def main(path, filter_prefix=None, csv_filename="output.csv"):
    with open(path, 'rb') as f:
        elf = ELFFile(f)
        symbols = get_symbols(elf)

        if not elf.has_dwarf_info():
            print("No DWARF info found in ELF file.")
            sys.exit(1)

        dwarfinfo = elf.get_dwarf_info()
        rows = []
        for name, meta in sorted(symbols.items(), key=lambda kv: kv[1]['addr']):
            if filter_prefix and filter_prefix not in name:
                continue
            addr = meta['addr']
            # Find matching variable in DWARF
            found = False
            for cu in dwarfinfo.iter_CUs():
                for die in cu.iter_DIEs():
                    if die.tag != 'DW_TAG_variable':
                        continue
                    n = die.attributes.get('DW_AT_name')
                    if not n:
                        continue
                    vname = n.value.decode('utf-8', 'ignore')
                    if vname == name:
                        tdie = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
                        if tdie:
                            collect_dwarf_struct_vars(name, addr, tdie, rows)
                        else:
                            rows.append([name, hex(addr), "unknown", "", "unknown"])
                        found = True
                        break
                if found:
                    break
        # Write to CSV
        with open(csv_filename, "w", newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["Name", "Address", "Type", "Byte Size", "Kind"])
            writer.writerows(rows)
        print(f"Saved to {csv_filename}")

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <elf-file> [filter_prefix] [csv_filename]")
        sys.exit(1)
    elf_path = sys.argv[1]
    filter_prefix = sys.argv[2] if len(sys.argv) > 2 else None
    csv_filename = sys.argv[3] if len(sys.argv) > 3 else "output.csv"
    main(elf_path, filter_prefix, csv_filename)
