#!/usr/bin/env python3
"""
Update and extend A2L files using symbol addresses from an ELF (with DWARF).

What it does:
- Updatea2l(olda2l, elf, newa2l):
  Reads all MEASUREMENT and CHARACTERISTIC blocks, resolves their addresses from the ELF,
  and writes an updated A2L with corrected ECU_ADDRESS (MEASUREMENT) or VALUE (CHARACTERISTIC).
- addvariable(olda2l, elf, variablename, vartype, outputfile):
  Adds new MEASUREMENT or CHARACTERISTIC block(s) for ALL filtered symbols that are not
  already present in the A2L. The filter set is:
    - Every symbol referenced in the existing A2L (via SYMBOL_LINK or block name), plus
    - The provided 'variablename' token(s) (supporting hierarchical names and array
      elements like Var._0_). 'variablename' can be:
        * a single string (e.g., "MyVar" or "MyArray._0_")
        * a comma-separated string (e.g., "MyVar,MyArray._0_")
        * a Python/JSON-like list string (e.g., '["MyVar", "MyArray._0_"]')
        * an actual Python list of strings when using the function directly.

New in this version:
- All hex addresses written to ECU_ADDRESS, ADDRESS, and VALUE are forced to uppercase hex
  (e.g., 0x1a2b -> 0x1A2B), both for updated values and any existing ones in the file.
- addvariable accepts a list of variable names and will append ALL filtered symbols (leaves)
  missing from the A2L.
- Placement rule: when adding new variables, MEASUREMENT blocks are inserted immediately
  after the last existing MEASUREMENT block; CHARACTERISTIC blocks are inserted immediately
  after the last existing CHARACTERISTIC block. One blank line is kept between each new block
  and there is one blank line before the first inserted block if needed.

Notes:
- Uses hierarchical symbol resolution (supports names like VarName._0_ and Var.Struct.Member).
- Array elements are named as {prefix}._i_ (with trailing underscore), e.g., MyArray._0_.
- Prints warnings in console for any filters/symbols that matched nothing.
- Requires: pip install pyelftools
"""

import sys
import re
import ast
from typing import List, Dict, Optional, Tuple, Set, Union

from elftools.elf.elffile import ELFFile
from elftools.dwarf.descriptions import describe_form_class

# ----------------------------
# DWARF / Symbol helpers
# ----------------------------

MAX_ARRAY = 32

DW_ATE_ADDRESS        = 0x01
DW_ATE_BOOLEAN        = 0x02
DW_ATE_COMPLEX_FLOAT  = 0x03
DW_ATE_FLOAT          = 0x04
DW_ATE_SIGNED         = 0x05
DW_ATE_SIGNED_CHAR    = 0x06
DW_ATE_UNSIGNED       = 0x07
DW_ATE_UNSIGNED_CHAR  = 0x08

def get_symbols(elffile):
    """Return {name: {'addr': int, 'size': int, 'kind': str}} for variables/functions in symbol tables."""
    out = {}
    for secname in ('.symtab', '.dynsym'):
        sec = elffile.get_section_by_name(secname)
        if not sec or not hasattr(sec, "iter_symbols"):
            continue
        for s in sec.iter_symbols():
            name = s.name
            if not name:
                continue
            addr = int(s['st_value'] or 0)
            size = int(s['st_size'] or 0)
            st_type = s['st_info']['type']
            kind = st_type.lower() if isinstance(st_type, str) else str(st_type).lower()
            out[name] = {'addr': addr, 'size': size, 'kind': kind}
    return out

def resolve_typedefs(die):
    """Follow DW_AT_type chain until a concrete type tag."""
    if die is None:
        return None
    seen = set()
    cur = die
    while cur and cur.offset not in seen:
        seen.add(cur.offset)
        if cur.tag in ('DW_TAG_base_type', 'DW_TAG_pointer_type',
                       'DW_TAG_array_type', 'DW_TAG_structure_type', 'DW_TAG_union_type',
                       'DW_TAG_enumeration_type'):
            return cur
        if 'DW_AT_type' in cur.attributes:
            cur = cur.get_DIE_from_attribute('DW_AT_type')
        else:
            break
    return cur

def base_type_info(base_die):
    """Return (type_name, byte_size, encoding) for base/pointer/enum; else (unknown, size, None)."""
    if base_die is None:
        return ('unknown', None, None)
    if base_die.tag == 'DW_TAG_pointer_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('pointer', int(bs.value) if bs else None, None)
    if base_die.tag == 'DW_TAG_base_type':
        nm = base_die.attributes.get('DW_AT_name')
        bs = base_die.attributes.get('DW_AT_byte_size')
        enc = base_die.attributes.get('DW_AT_encoding')
        return (nm.value.decode('utf-8', 'ignore') if nm else 'unknown',
                int(bs.value) if bs else None,
                int(enc.value) if enc else None)
    if base_die.tag == 'DW_TAG_enumeration_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('enum', int(bs.value) if bs else None, DW_ATE_SIGNED)
    bs = base_die.attributes.get('DW_AT_byte_size')
    return ('unknown', int(bs.value) if bs else None, None)

def array_len_first_dim(array_die) -> Optional[int]:
    """Get first dimension length from DW_TAG_array_type."""
    for child in array_die.iter_children():
        if child.tag != 'DW_TAG_subrange_type':
            continue
        cnt = child.attributes.get('DW_AT_count')
        if cnt:
            return int(cnt.value)
        ub = child.attributes.get('DW_AT_upper_bound')
        lb = child.attributes.get('DW_AT_lower_bound')
        if ub and lb:
            return int(ub.value) - int(lb.value) + 1
        if ub:
            return int(ub.value) + 1
    return None

def dwarf_type_to_str(tname, tenc, tsize):
    if tenc == DW_ATE_UNSIGNED and tsize == 4: return "uint32"
    if tenc == DW_ATE_UNSIGNED and tsize == 2: return "ushort"
    if tenc == DW_ATE_UNSIGNED and tsize == 1: return "ubyte"
    if tenc == DW_ATE_SIGNED and tsize == 4: return "int32"
    if tenc == DW_ATE_SIGNED and tsize == 2: return "short"
    if tenc == DW_ATE_SIGNED and tsize == 1: return "byte"
    if tenc == DW_ATE_BOOLEAN: return "bool"
    return tname

# Decide if we should EMIT a row for a given fully-qualified name.
# Also record which filter tokens actually matched a real symbol.
def should_emit(name, filter_list, filter_hits):
    if not filter_list:
        return True
    matched = False
    for f in filter_list:
        if name == f or name.startswith(f + ".") or name.startswith(f + "._"):
            matched = True
            if filter_hits is not None and f in filter_hits:
                filter_hits[f] += 1
    return matched

# Decide if we should TRAVERSE a top-level symbol for potential descendants.
# Note: traversal does NOT count as a "hit"; we only count actual emitted names.
def should_traverse(name, filter_list):
    if not filter_list:
        return True
    for f in filter_list:
        if name == f or name.startswith(f + ".") or name.startswith(f + "._"):
            return True
        if f.startswith(name + ".") or f.startswith(name + "._"):
            return True
    return False

def collect_dwarf_struct_vars(prefix, base_addr, die, rows, symbols_dict, filter_list, filter_hits):
    """Recursively collect members/arrays with full hierarchical names using {prefix}._i_ for arrays."""
    die = resolve_typedefs(die)
    if not die:
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), "unknown", "", "unknown"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": "unknown",
                "byte_size": "",
                "kind": "unknown"
            }
        return

    tag = die.tag

    if tag == 'DW_TAG_array_type':
        elem_die = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
        elem_die = resolve_typedefs(elem_die)
        etname, esize, etenc = base_type_info(elem_die)
        n = array_len_first_dim(die) or 0
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), f"array[{n}]", esize if esize else "", "array"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": f"array[{n}]",
                "byte_size": esize if esize else "",
                "kind": "array"
            }
        n_print = min(n, MAX_ARRAY)
        for i in range(n_print):
            eaddr = base_addr + i * (esize if esize else 1)
            array_elem_prefix = f"{prefix}._{i}_"
            if elem_die and elem_die.tag in ('DW_TAG_structure_type', 'DW_TAG_array_type'):
                collect_dwarf_struct_vars(array_elem_prefix, eaddr, elem_die, rows, symbols_dict, filter_list, filter_hits)
            else:
                if should_emit(array_elem_prefix, filter_list, filter_hits):
                    row = [array_elem_prefix, hex(eaddr), dwarf_type_to_str(etname, etenc, esize), esize if esize else "", "array_elem"]
                    rows.append(row)
                    symbols_dict[array_elem_prefix] = {
                        "address": hex(eaddr),
                        "type": dwarf_type_to_str(etname, etenc, esize),
                        "byte_size": esize if esize else "",
                        "kind": "array_elem"
                    }
        return

    if tag == 'DW_TAG_structure_type':
        # record the struct itself if needed
        _, tsize, _ = base_type_info(die)
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), "struct", tsize if tsize else "", "struct"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": "struct",
                "byte_size": tsize if tsize else "",
                "kind": "struct"
            }
        for child in die.iter_children():
            if child.tag != 'DW_TAG_member':
                continue
            mname_attr = child.attributes.get('DW_AT_name')
            mname = mname_attr.value.decode('utf-8', 'ignore') if mname_attr else '<anon>'
            loc = child.attributes.get('DW_AT_data_member_location')
            off = 0
            if loc and describe_form_class(loc.form) == 'constant':
                off = int(loc.value)
            mt = child.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in child.attributes else None
            if not mt:
                continue
            collect_dwarf_struct_vars(f"{prefix}.{mname}", base_addr + off, mt, rows, symbols_dict, filter_list, filter_hits)
        return

    # leaf/base types
    tname, tsize, tenc = base_type_info(die)
    if should_emit(prefix, filter_list, filter_hits):
        row = [prefix, hex(base_addr), dwarf_type_to_str(tname, tenc, tsize), tsize if tsize else "", "variable"]
        rows.append(row)
        symbols_dict[prefix] = {
            "address": hex(base_addr),
            "type": dwarf_type_to_str(tname, tenc, tsize),
            "byte_size": tsize if tsize else "",
            "kind": "variable"
        }

def build_symbols_dict(elf_path: str, filter_list: Optional[List[str]]) -> Tuple[Dict[str, Dict[str, str]], Set[str]]:
    """
    Use the collector logic to build a symbols_dict filtered by filter_list.
    Returns (symbols_dict, missing_filters)
    """
    with open(elf_path, 'rb') as f:
        elf = ELFFile(f)
        symbols = get_symbols(elf)

        if not elf.has_dwarf_info():
            raise RuntimeError("No DWARF info found in ELF file.")

        if filter_list and len(filter_list) > 0:
            print("Filters provided:", ", ".join(filter_list))
        else:
            print("No filters provided; processing all symbols.")

        dwarfinfo = elf.get_dwarf_info()
        rows = []  # not writing CSV here, but keep for parity
        symbols_dict: Dict[str, Dict[str, str]] = {}
        filter_hits = {f: 0 for f in (filter_list or [])}

        for name, meta in sorted(symbols.items(), key=lambda kv: kv[1]['addr']):
            if filter_list and not should_traverse(name, filter_list):
                continue
            addr = meta['addr']
            found = False
            for cu in dwarfinfo.iter_CUs():
                for die in cu.iter_DIEs():
                    if die.tag != 'DW_TAG_variable':
                        continue
                    n = die.attributes.get('DW_AT_name')
                    if not n:
                        continue
                    vname = n.value.decode('utf-8', 'ignore')
                    if vname == name:
                        tdie = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
                        if tdie:
                            collect_dwarf_struct_vars(name, addr, tdie, rows, symbols_dict, filter_list, filter_hits)
                        else:
                            if should_emit(name, filter_list, filter_hits):
                                symbols_dict[name] = {
                                    "address": hex(addr),
                                    "type": "unknown",
                                    "byte_size": "",
                                    "kind": "unknown"
                                }
                        found = True
                        break
                if found:
                    break

        unmatched = {f for f, c in filter_hits.items() if c == 0}
        if filter_list:
            if unmatched:
                print("Warning: the following filters matched no symbols:")
                for f in unmatched:
                    print(f" - {f}")
            else:
                print("All filters matched at least one symbol.")

        return symbols_dict, unmatched

# ----------------------------
# Hex helpers (force uppercase)
# ----------------------------

def _parse_hex_to_int(addr_hex) -> Optional[int]:
    if isinstance(addr_hex, int):
        return addr_hex
    if not isinstance(addr_hex, str):
        return None
    s = addr_hex.strip()
    try:
        if s.lower().startswith("0x"):
            return int(s, 16)
        return int(s, 16)
    except Exception:
        return None

def to_upper_hex(addr_hex: str) -> str:
    """
    Normalize any hex string like '0x1a2b' to '0x1A2B'. Accepts int as well.
    Returns input as string if parsing fails.
    """
    n = _parse_hex_to_int(addr_hex)
    if n is None:
        if isinstance(addr_hex, str) and addr_hex.strip().lower().startswith("0x"):
            return "0x" + addr_hex.strip()[2:].upper()
        return str(addr_hex)
    return f"0x{n:X}"

# ----------------------------
# A2L parsing and updating
# ----------------------------

class A2LBlock:
    def __init__(self, kind: str, name: str, symbol: str, begin_idx: int, end_idx: int, addr_line_idx: Optional[int]):
        self.kind = kind  # "MEASUREMENT" or "CHARACTERISTIC"
        self.name = name
        self.symbol = symbol  # SYMBOL_LINK if present, else block name
        self.begin_idx = begin_idx
        self.end_idx = end_idx
        self.addr_line_idx = addr_line_idx

MEAS_BEGIN_RE = re.compile(r'^\s*/begin\s+MEASUREMENT\s+(\S+)')
CHAR_BEGIN_RE = re.compile(r'^\s*/begin\s+CHARACTERISTIC\s+(\S+)')
SYMBOL_LINK_RE = re.compile(r'^\s*SYMBOL_LINK\s+"([^"]+)"')
END_BLOCK_RE_TMPL = "/end {}"

# Capture and normalize hex in place
ECU_ADDRESS_RE = re.compile(r'^(\s*ECU_ADDRESS\s+)(0x[0-9A-Fa-f]+)(.*)$')
VALUE_ADDR_RE  = re.compile(r'^(\s*VALUE\s+)(0x[0-9A-Fa-f]+)(.*)$')
ADDRESS_RE     = re.compile(r'^(\s*ADDRESS\s+)(0x[0-9A-Fa-f]+)(.*)$')

def parse_a2l_blocks(lines: List[str]) -> Tuple[List[A2LBlock], List[str]]:
    """
    Parse A2L lines and return list of blocks with their symbol names and positions.
    Also return a list of symbols (filters) to look up.
    Preference: use SYMBOL_LINK if available, otherwise the block name.
    """
    blocks: List[A2LBlock] = []
    filters: List[str] = []

    i = 0
    n = len(lines)
    while i < n:
        line = lines[i]

        m_meas = MEAS_BEGIN_RE.match(line)
        m_char = CHAR_BEGIN_RE.match(line)

        if m_meas or m_char:
            kind = "MEASUREMENT" if m_meas else "CHARACTERISTIC"
            name = (m_meas or m_char).group(1)
            begin_idx = i
            symbol_name = name
            addr_line_idx: Optional[int] = None

            # find end of block
            j = i + 1
            end_idx = None
            while j < n:
                l2 = lines[j]
                # capture SYMBOL_LINK if present
                m_sym = SYMBOL_LINK_RE.match(l2)
                if m_sym:
                    symbol_name = m_sym.group(1).strip()

                # capture address line
                if kind == "MEASUREMENT":
                    if ECU_ADDRESS_RE.match(l2):
                        addr_line_idx = j
                else:  # CHARACTERISTIC
                    if VALUE_ADDR_RE.match(l2):
                        addr_line_idx = j

                if l2.strip().lower() == END_BLOCK_RE_TMPL.format(kind.lower()):
                    end_idx = j
                    break
                j += 1
            if end_idx is None:
                end_idx = n - 1  # Unclosed block - treat until EOF

            blocks.append(A2LBlock(kind=kind, name=name, symbol=symbol_name,
                                   begin_idx=begin_idx, end_idx=end_idx,
                                   addr_line_idx=addr_line_idx))

            if symbol_name not in filters:
                filters.append(symbol_name)

            i = end_idx + 1
            continue

        i += 1

    return blocks, filters

def force_uppercase_known_address_keywords(lines: List[str]) -> List[str]:
    """
    Ensure all ECU_ADDRESS, ADDRESS, and VALUE lines have uppercase hex for the address field.
    """
    out: List[str] = []
    for line in lines:
        raw = line.rstrip("\n")
        m = ECU_ADDRESS_RE.match(raw)
        if m:
            out.append(f"{m.group(1)}{to_upper_hex(m.group(2))}{m.group(3)}\n")
            continue
        m = ADDRESS_RE.match(raw)
        if m:
            out.append(f"{m.group(1)}{to_upper_hex(m.group(2))}{m.group(3)}\n")
            continue
        m = VALUE_ADDR_RE.match(raw)
        if m:
            out.append(f"{m.group(1)}{to_upper_hex(m.group(2))}{m.group(3)}\n")
            continue
        out.append(line)
    return out

def update_a2l_lines(lines: List[str], blocks: List[A2LBlock], addr_map: Dict[str, str]) -> Tuple[List[str], List[str]]:
    """
    Update the lines for each block using addr_map.
    Returns updated lines and a list of warnings for blocks without matches.
    Also forces uppercase hex formatting for ECU_ADDRESS/ADDRESS/VALUE lines across the file.
    """
    out_lines = list(lines)
    warnings: List[str] = []

    for b in blocks:
        addr_hex = addr_map.get(b.symbol)
        if not addr_hex:
            warnings.append(f"No address found for symbol '{b.symbol}' (block {b.kind} {b.name}).")
            continue

        if b.addr_line_idx is None:
            warnings.append(f"No address line found to update for symbol '{b.symbol}' (block {b.kind} {b.name}).")
            continue

        old = out_lines[b.addr_line_idx].rstrip("\n")
        addr_hex_up = to_upper_hex(addr_hex)

        if b.kind == "MEASUREMENT":
            # Replace ECU_ADDRESS hex
            m = ECU_ADDRESS_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{addr_hex_up}{m.group(3)}"
            else:
                # fallback
                new_line = re.sub(r'^(\s*ECU_ADDRESS\s+)(0x[0-9A-Fa-f]+)',
                                  lambda mm: mm.group(1) + addr_hex_up,
                                  old)
        else:
            # Replace VALUE hex
            m = VALUE_ADDR_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{addr_hex_up}{m.group(3)}"
            else:
                new_line = re.sub(r'^(\s*VALUE\s+)(0x[0-9A-Fa-f]+)',
                                  lambda mm: mm.group(1) + addr_hex_up,
                                  old)

        out_lines[b.addr_line_idx] = new_line + "\n"

    # After updates, ensure all known keywords have uppercase hex addresses
    out_lines = force_uppercase_known_address_keywords(out_lines)

    return out_lines, warnings

# ----------------------------
# Helpers to create new blocks and placement
# ----------------------------

def _guess_datatype_and_limits(meta: Optional[Dict[str, str]]) -> Tuple[str, str, str, str]:
    """
    Guess A2L data keywords and limit ranges from symbol metadata.
    Returns tuple:
      (meas_datatype, char_deposit, lower, upper)
    """
    t = (meta or {}).get("type", "") if meta else ""
    t = (t or "").lower()
    # Defaults
    meas = "UBYTE"
    dep = "UByte_Value"
    lower = "0"
    upper = "255"

    if t in ("bool",):
        meas, dep, lower, upper = "UBYTE", "UByte_Value", "0", "1"
    elif t in ("ubyte", "uint8", "unsigned char"):
        meas, dep, lower, upper = "UBYTE", "UByte_Value", "0", "255"
    elif t in ("byte", "int8", "signed char"):
        meas, dep, lower, upper = "SBYTE", "SByte_Value", "-128", "127"
    elif t in ("ushort", "uint16", "unsigned short"):
        meas, dep, lower, upper = "UWORD", "UWord_Value", "0", "65535"
    elif t in ("short", "int16", "signed short"):
        meas, dep, lower, upper = "SWORD", "SWord_Value", "-32768", "32767"
    elif t in ("uint32", "unsigned int", "unsigned long"):
        meas, dep, lower, upper = "ULONG", "ULong_Value", "0", "4294967295"
    elif t in ("int32", "signed int", "long", "int"):
        meas, dep, lower, upper = "SLONG", "SLong_Value", "-2147483648", "2147483647"
    elif "float" in t:
        meas, dep, lower, upper = "FLOAT32", "Float_Value", "-3.402823e+38", "3.402823e+38"

    return meas, dep, lower, upper

def _render_new_block(variablename: str, kind: str, addr_hex: str, meta: Optional[Dict[str, str]]) -> List[str]:
    """
    Render a minimal A2L block for variablename with given kind ('MEASUREMENT' or 'CHARACTERISTIC').
    Ensures uppercase hex for the address field.
    """
    meas_dt, char_dep, lower, upper = _guess_datatype_and_limits(meta)
    addr_hex_up = to_upper_hex(addr_hex)
    lines: List[str] = []
    if kind == "MEASUREMENT":
        lines.extend([
            f'/begin MEASUREMENT {variablename} ""\n',
            f'  {meas_dt} NO_COMPU_METHOD 0 0 {upper}\n',
            f'  ECU_ADDRESS {addr_hex_up}\n',
            f'  SYMBOL_LINK "{variablename}" 0\n',
            f'/end MEASUREMENT\n',
        ])
    else:  # CHARACTERISTIC
        lines.extend([
            f'/begin CHARACTERISTIC {variablename} ""\n',
            f'  VALUE {addr_hex_up} {char_dep} 0 NO_COMPU_METHOD 0 {upper}\n',
            f'  SYMBOL_LINK "{variablename}" 0\n',
            f'/end CHARACTERISTIC\n',
        ])
    return lines

def _normalize_variablename_input(variablename: Union[str, List[str]]) -> List[str]:
    """
    Accepts:
      - a list/tuple/set of names
      - a comma-separated string "A,B,C"
      - a Python/JSON-like list string '["A","B"]'
      - a single string "A"
    Returns a deduplicated list of trimmed names.
    """
    names: List[str] = []
    if isinstance(variablename, (list, tuple, set)):
        names = [str(x).strip() for x in variablename if str(x).strip()]
    elif isinstance(variablename, str):
        s = variablename.strip()
        if s.startswith("[") and s.endswith("]"):
            try:
                parsed = ast.literal_eval(s)
                if isinstance(parsed, (list, tuple, set)):
                    names = [str(x).strip() for x in parsed if str(x).strip()]
                else:
                    names = [s]
            except Exception:
                names = [p.strip() for p in s.strip("[]").split(",") if p.strip()]
        elif "," in s:
            names = [p.strip() for p in s.split(",") if p.strip()]
        elif s:
            names = [s]
    # Deduplicate preserving order
    seen = set()
    uniq = []
    for n in names:
        if n not in seen:
            seen.add(n)
            uniq.append(n)
    return uniq

def _find_insert_position_after_kind(lines: List[str], blocks: List[A2LBlock], kind: str) -> int:
    """
    Returns the line index to insert new blocks right after the last existing block of 'kind'.
    If none exist, returns len(lines) to append at the end.
    """
    last_end = -1
    for b in blocks:
        if b.kind == kind and b.end_idx > last_end:
            last_end = b.end_idx
    if last_end >= 0:
        return last_end + 1
    return len(lines)

# ----------------------------
# Public APIs
# ----------------------------

def Updatea2l(olda2l: str, elf: str, newa2l: str) -> None:
    """
    Read MEASUREMENT and CHARACTERISTIC symbols from olda2l,
    resolve addresses from elf (DWARF + symtab) using the collector with filtering,
    and write updated a2l to newa2l.
    All ECU_ADDRESS/ADDRESS/VALUE lines use uppercase hex for addresses.
    """
    with open(olda2l, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    blocks, filters = parse_a2l_blocks(lines)
    if not blocks:
        print("No MEASUREMENT or CHARACTERISTIC blocks found in A2L.")
    else:
        print(f"Found {len(blocks)} blocks to process.")
    if filters:
        print("Symbols to resolve from ELF:")
        for s in filters:
            print(f" - {s}")

    symbols_dict, missing_filters = build_symbols_dict(elf, filters)
    # Uppercase addresses in map
    addr_map = {name: to_upper_hex(meta["address"]) for name, meta in symbols_dict.items()}
    print(f"Resolved {len(addr_map)} symbol addresses from ELF/DWARF.")

    updated_lines, warnings = update_a2l_lines(lines, blocks, addr_map)

    for w in warnings:
        print("Warning:", w)
    if missing_filters:
        print("These A2L symbols were not found in ELF/DWARF:")
        for s in sorted(missing_filters):
            print(f" - {s}")

    with open(newa2l, "w", encoding="utf-8", errors="ignore") as f:
        f.writelines(updated_lines)
    print(f"Saved updated A2L to: {newa2l}")

def addvariable(olda2l: str, elf: str, variablename: Union[str, List[str]], vartype: str, outputfile: str) -> None:
    """
    Add new variables (ALL filtered, missing from A2L) and update all existing addresses.

    Placement:
    - MEASUREMENT additions are inserted right after the last existing MEASUREMENT block.
    - CHARACTERISTIC additions are inserted right after the last existing CHARACTERISTIC block.
    - Ensure exactly one blank line between new blocks, and one blank line before the first inserted block if needed.

    Parameters:
    - olda2l: path to existing A2L file
    - elf: path to ELF file (with DWARF)
    - variablename: a symbol filter or list of filters (supports members/array elements like Var._0_)
    - vartype: 'characteristic' or 'measurement' (case-insensitive) used for ALL new blocks appended
    - outputfile: path to write updated A2L
    """
    kind = (vartype or "").strip().upper()
    if kind not in ("CHARACTERISTIC", "MEASUREMENT"):
        raise ValueError("vartype must be 'characteristic' or 'measurement'")

    with open(olda2l, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    # Parse existing blocks and build base filters from A2L
    blocks, filters = parse_a2l_blocks(lines)
    existing_symbols = {b.symbol for b in blocks}

    # Normalize variablename into a list of tokens and add to filters
    extra_filters = _normalize_variablename_input(variablename)
    for tok in extra_filters:
        if tok not in filters:
            filters.append(tok)

    print(f"Starting 'addvariable' with {len(filters)} filter token(s).")
    if extra_filters:
        print("- Added filter token(s):", ", ".join(extra_filters))

    # Resolve all symbols for these filters
    symbols_dict, missing_filters = build_symbols_dict(elf, filters)
    # Uppercase addresses in map
    addr_map = {name: to_upper_hex(meta["address"]) for name, meta in symbols_dict.items()}
    print(f"Resolved {len(addr_map)} addresses from ELF.")

    # 1) Update addresses for existing blocks
    updated_lines, warnings = update_a2l_lines(lines, blocks, addr_map)
    for w in warnings:
        print("Warning:", w)

    # 2) Append ALL filtered symbols that are not already present in the A2L
    #    Skip container-only nodes (struct/array); include leaves like variables and array elements.
    missing_symbols = [
        name for name, meta in symbols_dict.items()
        if name not in existing_symbols and meta.get("kind") not in ("struct", "array")
    ]

    if not missing_symbols:
        print("No new filtered symbols to add; only addresses were updated.")
        with open(outputfile, "w", encoding="utf-8", errors="ignore") as f:
            f.writelines(updated_lines)
        print(f"Saved updated A2L to: {outputfile}")
        return

    print(f"Adding {len(missing_symbols)} new {kind} block(s) for filtered symbols not present in A2L.")

    # Build the block text with one blank line between blocks
    insert_lines: List[str] = []
    for idx, name in enumerate(sorted(missing_symbols)):
        meta = symbols_dict.get(name, {})
        addr_hex = to_upper_hex(meta.get("address", "0x0"))
        block_lines = _render_new_block(name, kind, addr_hex, meta)
        insert_lines.extend(block_lines)
        if idx != len(missing_symbols) - 1:
            insert_lines.append("\n")  # one blank line between new variables

    # Find insertion point after the last block of the given kind
    insert_idx = _find_insert_position_after_kind(updated_lines, blocks, kind)

    # Ensure exactly one blank line before the first inserted block (if not at start)
    if insert_idx > 0:
        prev_line = updated_lines[insert_idx - 1]
        if prev_line.strip() != "":
            updated_lines[insert_idx:insert_idx] = ["\n"]
            insert_idx += 1
        else:
            # If there are multiple blank lines, collapse to a single one
            # Remove extra blank lines directly before insert_idx leaving one
            k = insert_idx - 1
            while k - 1 >= 0 and updated_lines[k - 1].strip() == "":
                del updated_lines[k - 1]
                insert_idx -= 1
                k -= 1

    # Insert the new blocks at the computed position
    updated_lines[insert_idx:insert_idx] = insert_lines

    # Final pass: ensure uppercase hex on known keywords everywhere
    updated_lines = force_uppercase_known_address_keywords(updated_lines)

    with open(outputfile, "w", encoding="utf-8", errors="ignore") as f:
        f.writelines(updated_lines)
    print(f"Appended {len(missing_symbols)} new {kind} block(s) after last {kind} section and saved to: {outputfile}")

# ----------------------------
# CLI
# ----------------------------

def _main(argv: List[str]) -> int:
    if len(argv) < 2:
        print(f"Usage:\n"
              f"  {argv[0]} update <olda2l> <elf> <newa2l>\n"
              f"  {argv[0]} add <olda2l> <elf> <variablename|list> <characteristic|measurement> <outputfile>\n\n"
              f"Notes:\n"
              f"- 'add' updates addresses for existing blocks AND appends ALL filtered symbols missing from the A2L.\n"
              f"- Filters = all symbols referenced in the A2L + provided variablename(s).\n"
              f"- variablename can be a comma-separated list (A,B,C) or a JSON-like list string (e.g., [\"A\",\"B\"]).\n"
              f"- New MEASUREMENT/CHARACTERISTIC blocks are inserted right after the last block of the same kind.\n"
              f"- All ECU_ADDRESS/ADDRESS/VALUE addresses are emitted in uppercase hex.")
        return 1

    cmd = argv[1].lower()
    if cmd == "update":
        if len(argv) < 5:
            print(f"Usage: {argv[0]} update <olda2l> <elf> <newa2l>")
            return 1
        _, _, olda2l, elf, newa2l = argv[:5]
        Updatea2l(olda2l, elf, newa2l)
        return 0

    if cmd == "add":
        if len(argv) < 7:
            print(f"Usage: {argv[0]} add <olda2l> <elf> <variablename|list> <characteristic|measurement> <outputfile>")
            return 1
        _, _, olda2l, elf, variablename_arg, vartype, outputfile = argv[:7]
        variablename_list = _normalize_variablename_input(variablename_arg)
        addvariable(olda2l, elf, variablename_list, vartype, outputfile)
        return 0

    print(f"Unknown command: {cmd}")
    return 1

if __name__ == "__main__":
    sys.exit(_main(sys.argv))
