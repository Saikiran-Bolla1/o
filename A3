#!/usr/bin/env python3
"""
Merge/refresh ECU addresses in an A2L using symbols from an ELF file.

This script updates CHARACTERISTIC, AXIS_PTS, and MEASUREMENT blocks in the A2L file:
- If SYMBOL_LINK is present, use its symbol and offset.
- Otherwise, match by block name (and optionally strip prefixes).
- For CHARACTERISTIC and AXIS_PTS, replace the address field in header line.
- For MEASUREMENT, replace or insert ECU_ADDRESS inside the block.

If the symbol is found in ELF, the address is replaced, even if the name matches.
Handles single-line and multi-line headers.

Dependencies:
  pip install pyelftools

Usage:
  python scripts/merge_a2l_with_elf.py --a2l-in input.a2l --elf app.elf --a2l-out output.a2l \
      [--strategy symbol-link,name] [--strip-prefix foo_] [--addr-adjust 0]
"""

import argparse
import re
from pathlib import Path
from typing import Dict, List, Optional, Tuple

from elftools.elf.elffile import ELFFile

def load_elf_symbols(elf_path: Path) -> Dict[str, int]:
    """Return symbol -> address dictionary."""
    symbols: Dict[str, int] = {}
    with elf_path.open("rb") as f:
        elffile = ELFFile(f)
        for sec_name in (".symtab", ".dynsym"):
            sec = elffile.get_section_by_name(sec_name)
            if not sec:
                continue
            for sym in sec.iter_symbols():
                st_type = sym["st_info"]["type"]
                name = sym.name
                if not name:
                    continue
                if st_type not in ("STT_FUNC", "STT_OBJECT"):
                    continue
                addr = int(sym["st_value"])
                if name not in symbols or (symbols[name] == 0 and addr != 0):
                    symbols[name] = addr
    return symbols

HEADER_RE = re.compile(r"^\s*(CHARACTERISTIC|AXIS_PTS)\s+(\S+)\s+\"")  # block type and identifier
MEAS_START_RE = re.compile(r"^\s*MEASUREMENT\s+(\S+)\s+\"")  # identifier
END_RE = re.compile(r"^\s*END\s+(CHARACTERISTIC|AXIS_PTS|MEASUREMENT)\s*$", re.IGNORECASE)
SYMBOL_LINK_RE = re.compile(r'^\s*SYMBOL_LINK\s+("?)([A-Za-z0-9_.$@?]+)\1(?:\s+([\-+]?(?:0x[0-9A-Fa-f]+|\d+)))?')
ECU_ADDRESS_RE = re.compile(r"^\s*ECU_ADDRESS\s+([\-+]?(?:0x[0-9A-Fa-f]+|\d+))\s*$", re.IGNORECASE)

def parse_int_literal(s: str) -> int:
    s = s.strip()
    if s.lower().startswith("0x"):
        return int(s, 16)
    return int(s, 10)

def format_addr(addr: int) -> str:
    return f"0x{addr:X}"

def find_symbol_link(lines: List[str], start_idx: int, end_idx: int) -> Optional[Tuple[str, int]]:
    for i in range(start_idx, end_idx):
        m = SYMBOL_LINK_RE.match(lines[i])
        if m:
            sym = m.group(2)
            off = m.group(3)
            offset = parse_int_literal(off) if off else 0
            return sym, offset
    return None

def find_ecu_address_line(lines: List[str], start_idx: int, end_idx: int) -> Optional[int]:
    for i in range(start_idx, end_idx):
        if ECU_ADDRESS_RE.match(lines[i]):
            return i
    return None

def update_header_address(lines: List[str], idx: int, new_addr: int) -> None:
    """
    Handles both single-line and multi-line header.
    For single-line, replace address field.
    For multi-line, find VALUE line and replace address.
    """
    line = lines[idx]
    # Single-line header: address literal after TYPE token
    split = split_header_address_line(line)
    if split is not None:
        prefix, _old_addr_lit, suffix = split
        lines[idx] = f"{prefix}{format_addr(new_addr)}{suffix}"
        return
    # Multi-line header: look for VALUE line
    block_end = idx + 1
    while block_end < len(lines) and not END_RE.match(lines[block_end]):
        block_end += 1
    for i in range(idx+1, block_end):
        if lines[i].lstrip().startswith("VALUE"):
            fields = lines[i].split()
            # VALUE <address> [rest]
            if len(fields) >= 2:
                fields[1] = format_addr(new_addr)
                lines[i] = " ".join(fields)
            return

def split_header_address_line(line: str) -> Optional[Tuple[str, str, str]]:
    """
    Split a header line for CHARACTERISTIC or AXIS_PTS into (prefix, address_literal, suffix).
    Assumes longIdentifier is quoted and single-line. Returns None if cannot parse.
    """
    try:
        kw_end = line.index('"')
        closing = line.index('"', kw_end + 1)
    except ValueError:
        return None
    rest = line[closing + 1 :]
    m = re.match(r"\s*(\S+)\s+(\S+)(.*)$", rest)
    if not m:
        return None
    _type_token = m.group(1)
    addr_literal = m.group(2)
    suffix = m.group(3)
    prefix = line[: closing + 1] + rest[: m.start(2)]
    return prefix, addr_literal, suffix

def compute_address(name: str, lines: List[str], blk_start: int, blk_end: int, symbols: Dict[str, int], strategy: List[str], strip_prefixes: List[str], addr_adjust: int) -> Optional[int]:
    for strat in strategy:
        if strat == "symbol-link":
            sl = find_symbol_link(lines, blk_start, blk_end)
            if sl:
                sym, offset = sl
                addr = symbols.get(sym)
                if addr is not None:
                    return int(addr) + int(offset) + int(addr_adjust)
        elif strat == "name":
            addr = symbols.get(name)
            if addr is None and strip_prefixes:
                for p in strip_prefixes:
                    if name.startswith(p):
                        addr = symbols.get(name[len(p) :])
                        if addr is not None:
                            break
            if addr is not None:
                return int(addr) + int(addr_adjust)
    return None

def merge_a2l_with_elf(a2l_in: Path, elf: Path, a2l_out: Path, strategy: List[str], strip_prefixes: List[str], addr_adjust: int, only: Optional[List[str]], dry_run: bool = False) -> Dict[str, int]:
    symbols = load_elf_symbols(elf)
    content = a2l_in.read_text(encoding="latin-1", errors="ignore").splitlines(keepends=False)
    lines = content
    updated_counts = {"CHARACTERISTIC": 0, "AXIS_PTS": 0, "MEASUREMENT": 0}
    i = 0
    total_lines = len(lines)
    def skip_type(t):
        return only is not None and t.lower() not in {x.lower() for x in only}
    while i < total_lines:
        line = lines[i]
        m_hdr = HEADER_RE.match(line)
        if m_hdr:
            blk_type, ident = m_hdr.group(1), m_hdr.group(2)
            if skip_type(blk_type):
                i += 1
                continue
            j = i + 1
            while j < total_lines:
                if END_RE.match(lines[j]):
                    break
                j += 1
            blk_end = j if j < total_lines else total_lines
            new_addr = compute_address(
                name=ident,
                lines=lines,
                blk_start=i + 1,
                blk_end=blk_end,
                symbols=symbols,
                strategy=strategy,
                strip_prefixes=strip_prefixes,
                addr_adjust=addr_adjust,
            )
            if new_addr is not None:
                update_header_address(lines, i, new_addr)
                updated_counts[blk_type] += 1
            i = blk_end + 1
            continue
        m_meas = MEAS_START_RE.match(line)
        if m_meas:
            blk_type = "MEASUREMENT"
            ident = m_meas.group(1)
            if skip_type(blk_type):
                j = i + 1
                while j < total_lines and not END_RE.match(lines[j]):
                    j += 1
                i = j + 1
                continue
            j = i + 1
            while j < total_lines and not END_RE.match(lines[j]):
                j += 1
            blk_end = j if j < total_lines else total_lines
            new_addr = compute_address(
                name=ident,
                lines=lines,
                blk_start=i + 1,
                blk_end=blk_end,
                symbols=symbols,
                strategy=strategy,
                strip_prefixes=strip_prefixes,
                addr_adjust=addr_adjust,
            )
            if new_addr is not None:
                ecu_line_idx = find_ecu_address_line(lines, i + 1, blk_end)
                ecu_line_text = f"  ECU_ADDRESS {format_addr(new_addr)}"
                if ecu_line_idx is not None:
                    lines[ecu_line_idx] = ecu_line_text
                else:
                    lines.insert(blk_end, ecu_line_text)
                    total_lines += 1
                    blk_end += 1
                updated_counts[blk_type] += 1
            i = blk_end + 1
            continue
        i += 1
    if not dry_run:
        a2l_out.write_text("\n".join(lines) + "\n", encoding="latin-1", errors="ignore")
    return updated_counts

def main():
    parser = argparse.ArgumentParser(description="Merge/refresh A2L addresses from ELF symbols.")
    parser.add_argument("--a2l-in", required=True, type=Path, help="Input A2L path")
    parser.add_argument("--elf", required=True, type=Path, help="ELF file path")
    parser.add_argument("--a2l-out", required=True, type=Path, help="Output A2L path")
    parser.add_argument(
        "--strategy",
        default="symbol-link,name",
        help="Comma-separated strategies in priority order: symbol-link,name",
    )
    parser.add_argument(
        "--strip-prefix",
        action="append",
        default=[],
        help="Strip this prefix from A2L object name when matching by name (can be given multiple times)",
    )
    parser.add_argument(
        "--addr-adjust",
        type=lambda x: int(x, 0),
        default=0,
        help="Add this constant to all resolved ELF addresses (e.g., --addr-adjust 0x8000000)",
    )
    parser.add_argument(
        "--only",
        choices=["characteristic", "axis_pts", "measurement"],
        action="append",
        help="Restrict to one or more block types. Can be specified multiple times.",
    )
    parser.add_argument("--dry-run", action="store_true", help="Do not write output, just report changes.")
    args = parser.parse_args()
    strategies = [s.strip() for s in args.strategy.split(",") if s.strip()]
    stats = merge_a2l_with_elf(
        a2l_in=args.a2l_in,
        elf=args.elf,
        a2l_out=args.a2l_out,
        strategy=strategies,
        strip_prefixes=args.strip_prefix,
        addr_adjust=args.addr_adjust,
        only=args.only,
        dry_run=args.dry_run,
    )
    print("Updates applied:", stats)
    if args.dry_run:
        print("Dry run: no output written.")
    else:
        print(f"Wrote merged A2L to: {args.a2l_out}")

if __name__ == "__main__":
    main()
