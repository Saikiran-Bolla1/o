# Requires:
#   pip install pywin32 asammdf numpy
#
# Features:
# - Direct longname access: var = session["Device:Variable"]
# - Automatically goes online before reading/writing a variable value.
# - Recorder ensures ALL project devices are online BEFORE starting measurement (best-effort; can be made strict).
# - Recording uses CANape's MF4 only (no background threads).
# - session.recorder(...) sets CANape.Measurement.MDFFilename to your path and reads the same file.
# - After the with-block:
#     V = rec[var]  or  V = rec["Device:Variable"]
#     V.x -> timestamps (numpy array)
#     V.y -> values (numpy array)
#     V.name -> "Device:Variable" when resolvable (else raw MF4 name)
#     V.data -> ((x0,y0), ..., (xn,yn))
# - rec.signals -> list of all recorded signal names (as provided to the recorder)
# - rec.values() -> list of objects having name, x, y, data
#
# Recorder safety:
# - Before Start(): disables Save2MDF on ALL channels in ALL tasks for ALL devices in the project,
#   then enables only the channels requested for this run (prevents leftover Vector channels).
# - Restores original Save2MDF states for all devices/tasks/channels after Stop().
# - Uses a fresh MF4 path; attempts to disable append and absolute time (best-effort).
#
# Example:
#   sess = CanapeAutomation(r"C:\path\to\CANapeProject")
#   ecu = sess.add_xcp_on_dap_ecu("ECU", r"C:\my.ecu.a2l")
#   sess.go_online_all()
#   amp = sess["ECU:ampl"]    # CanapeVariable
#   print("ampl=", amp.value) # reads after ensuring ECU is online
#   amp.value = 2.5           # writes after ensuring ECU is online
#
#   with sess.recorder("ECU:EngSpd", mdf_path=r"C:\logs\run1.mf4") as rec:
#       import time; time.sleep(5.0)
#   print(rec["ECU:EngSpd"].y[:5])
#
import os
import re
import time
import win32com.client
import numpy as np
from datetime import datetime
from contextlib import contextmanager
from typing import Dict, List, Optional, Union, Any, Tuple, Iterable

from asammdf import MDF, Signal


def _dispatch_canape():
    return win32com.client.Dispatch("CANape.Application")


def _ensure_parent_dir(path: str):
    parent = os.path.dirname(os.path.abspath(path))
    if parent and not os.path.exists(parent):
        os.makedirs(parent, exist_ok=True)


def _wait_for_file_stable(path: str, timeout_s: float = 30.0, poll_s: float = 0.25) -> bool:
    end = time.time() + timeout_s
    last = -1
    seen = False
    while time.time() < end:
        if os.path.exists(path):
            size = os.path.getsize(path)
            if seen and size == last and size > 0:
                return True
            last = size
            seen = True
        time.sleep(poll_s)
    return os.path.exists(path)


def _iter_collection(coll):
    try:
        for item in coll:
            yield item
        return
    except Exception:
        pass
    try:
        n = coll.Count
    except Exception:
        n = 0
    for i in range(1, int(n) + 1):
        try:
            yield coll.Item(i)
        except Exception:
            pass


def _device_is_online(dev) -> bool:
    """
    Best-effort check using common COM members:
    - Method/property: IsOnline (preferred)
    - Fallbacks: isOnline, Online, or numeric State/Status
    """
    try:
        attr = getattr(dev, "IsOnline", None)
        if attr is None:
            attr = getattr(dev, "isOnline", None) or getattr(dev, "Online", None)
        if callable(attr):
            return bool(attr())
        if attr is not None:
            return bool(attr)
    except Exception:
        pass
    for name in ("State", "Status"):
        try:
            val = getattr(dev, name)
            if isinstance(val, (int, float)) and int(val) != 0:
                return True
        except Exception:
            pass
    return False


def _get_signal_preferred(mdf: MDF, name: str, prefer_raw: bool = False) -> Signal:
    if prefer_raw:
        try:
            return mdf.get(name, raw=True)
        except Exception:
            return mdf.get(name)
    else:
        try:
            return mdf.get(name)
        except Exception:
            return mdf.get(name, raw=True)


def _to_float_safe(val) -> float:
    if isinstance(val, (int, float, np.integer, np.floating)):
        return float(val)
    if val is None:
        return np.nan
    if isinstance(val, (bytes, bytearray)):
        try:
            val = val.decode("utf-8", errors="ignore")
        except Exception:
            return np.nan
    s = str(val).strip().replace("\xa0", " ")
    if s == "" or s.lower() in ("nan", "none", "null"):
        return np.nan
    low = s.lower()
    if low in ("true", "on", "high", "yes"):
        return 1.0
    if low in ("false", "off", "low", "no"):
        return 0.0
    m = re.search(r"[-+]?\d+(?:[.,]\d+)?(?:[eE][-+]?\d+)?", s)
    if m:
        num = m.group(0).replace(",", ".")
        try:
            return float(num)
        except Exception:
            pass
    return np.nan


def _maybe_text_to_raw(samples: np.ndarray, signal: Signal) -> np.ndarray:
    if hasattr(samples, "dtype") and samples.dtype.kind in ("i", "u", "f", "b"):
        return samples
    conv = getattr(signal, "conversion", None)
    mapping = None
    if conv is not None:
        for attr in ("text_2_value", "text2value", "text_to_value", "value_map", "val_map", "mapping"):
            mapping = getattr(conv, attr, None)
            if mapping:
                break
        if mapping is None:
            texts = getattr(conv, "texts", None) or getattr(conv, "labels", None)
            values = getattr(conv, "values", None) or getattr(conv, "ids", None)
            if texts is not None and values is not None:
                try:
                    mapping = {t: v for t, v in zip(texts, values)}
                except Exception:
                    mapping = None
    out = []
    if mapping:
        for s in samples:
            if s in mapping:
                v = mapping[s]
                out.append(_to_float_safe(v))
                continue
            if isinstance(s, (bytes, bytearray)):
                try:
                    s2 = s.decode(errors="ignore")
                except Exception:
                    s2 = ""
            else:
                s2 = str(s)
            v = mapping.get(s2, None)
            if v is not None:
                out.append(_to_float_safe(v))
            else:
                out.append(_to_float_safe(s))
    else:
        out = [_to_float_safe(s) for s in samples]
    return np.array(out, dtype=float)


class CanapeVariable:
    def __init__(self, app, device_com, device_name: str, varname: str):
        self._app = app
        self._dev = device_com
        self.device_name = device_name
        self.varname = varname
        self.longname = f"{self.device_name}:{self.varname}"

    def _ensure_online(self, timeout_s: float = 5.0, poll_s: float = 0.05):
        if _device_is_online(self._dev):
            return
        try:
            self._dev.GoOnline(False)
        except Exception:
            try:
                self._dev.GoOnline()
            except Exception:
                pass
        end = time.time() + timeout_s
        while time.time() < end:
            if _device_is_online(self._dev):
                return
            time.sleep(poll_s)
        try:
            self._dev.GoOnline()
        except Exception:
            pass
        if not _device_is_online(self._dev):
            raise RuntimeError(f"Device '{self.device_name}' failed to go online for reading/writing '{self.varname}'")

    @property
    def value(self):
        self._ensure_online()
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, val):
        self._ensure_online()
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Value = val
        obj.Write()

    def __repr__(self):
        return f"<CanapeVariable {self.longname}>"


class _TaskSignalRef:
    def __init__(self, device_name: str, signal_name: str):
        self.device_name = device_name
        self.signal_name = signal_name

    @property
    def longname(self) -> str:
        return f"{self.device_name}:{self.signal_name}"

    def __repr__(self):
        return f"<TaskSignal {self.longname}>"


class _SignalView:
    def __init__(self, signal: Signal, display_name: Optional[str] = None, force_text_to_numeric: bool = True):
        self._sig = signal
        self._name = display_name or signal.name
        xs = signal.timestamps
        ys = signal.samples
        if force_text_to_numeric and (hasattr(ys, "dtype") and ys.dtype.kind in ("O", "U", "S")):
            ys = _maybe_text_to_raw(ys, signal)
        self._x = np.asarray(xs)
        self._y = np.asarray(ys)

    @property
    def x(self):
        return self._x

    @property
    def y(self):
        return self._y

    @property
    def name(self) -> str:
        return self._name

    @property
    def data(self) -> Tuple[Tuple[float, float], ...]:
        n = min(len(self._x), len(self._y))
        return tuple((float(self._x[i]), float(self._y[i])) for i in range(n))

    def __repr__(self):
        return f"<SignalView name={self._name!r} len={len(self._x)}>"


class RecorderResult:
    def __init__(
        self,
        app,
        touched_items: List[Dict[str, Any]],
        disabled_items: List[Dict[str, Any]],
        var_list: List[CanapeVariable],
        vector_refs: List[_TaskSignalRef],
        can_refs: List[_TaskSignalRef],
        mdf_path: str,
        prefer_raw: bool = False,
        prefer_enum_numeric: bool = True,
        normalize_time_zero: bool = True,
    ):
        self._app = app
        self._touched_items = touched_items
        self._disabled_items = disabled_items
        self._vars = var_list
        self._vectors = vector_refs
        self._can_refs = can_refs
        self.filepath = os.path.abspath(mdf_path)
        self._prefer_raw = prefer_raw
        self._prefer_enum_numeric = prefer_enum_numeric
        self._normalize_time_zero = normalize_time_zero

        self._mdf: Optional[MDF] = None
        self._views_by_var: Dict[CanapeVariable, _SignalView] = {}
        self._views_by_name: Dict[str, _SignalView] = {}
        self._ordered_names: List[str] = []

    def _resolve_signal(self, mdf: MDF, candidates: List[str]) -> Optional[Signal]:
        for name in candidates:
            try:
                return _get_signal_preferred(mdf, name, prefer_raw=self._prefer_raw)
            except Exception:
                continue
        try:
            names = list(mdf.get_channel_names())
        except Exception:
            names = []
        lower = {n.lower(): n for n in names}
        for cand in candidates:
            n = lower.get(cand.lower())
            if n:
                try:
                    return _get_signal_preferred(mdf, n, prefer_raw=self._prefer_raw)
                except Exception:
                    pass
        for cand in candidates:
            tail = cand.split(":", 1)[-1]
            for sep in (":", "."):
                suffix = f"{sep}{tail}"
                matches = [n for n in names if n.endswith(suffix)]
                if len(matches) == 1:
                    try:
                        return _get_signal_preferred(mdf, matches[0], prefer_raw=self._prefer_raw)
                    except Exception:
                        pass
        return None

    def _maybe_upgrade_enum_to_raw(self, mdf: MDF, sig: Signal, candidates: List[str]) -> Signal:
        try:
            ys = sig.samples
            is_text = hasattr(ys, "dtype") and ys.dtype.kind in ("O", "U", "S")
        except Exception:
            is_text = False
        if self._prefer_enum_numeric and is_text:
            for name in candidates:
                try:
                    raw_sig = _get_signal_preferred(mdf, name, prefer_raw=True)
                    return raw_sig
                except Exception:
                    continue
        return sig

    def _load_views_for_name(self, mdf: MDF, display_name: str, candidates: List[str]):
        sig = self._resolve_signal(mdf, candidates)
        if sig is None:
            return
        sig = self._maybe_upgrade_enum_to_raw(mdf, sig, candidates)
        view = _SignalView(sig, display_name=display_name)
        self._views_by_name[display_name] = view
        self._ordered_names.append(display_name)

    def _normalize_time_zero_in_views(self):
        t0 = None
        for view in self._views_by_name.values():
            if hasattr(view, "_x") and view._x.size:
                t0 = view._x[0] if t0 is None else min(t0, view._x[0])
        if t0 is not None and t0 != 0.0:
            for view in self._views_by_name.values():
                if hasattr(view, "_x") and view._x.size:
                    view._x = view._x - t0

    def _load_views(self):
        self._mdf = MDF(self.filepath)

        for v in self._vars:
            candidates = [v.longname, v.varname]
            sig = self._resolve_signal(self._mdf, candidates)
            if sig is None:
                continue
            sig = self._maybe_upgrade_enum_to_raw(self._mdf, sig, candidates)
            view = _SignalView(sig, display_name=v.longname)
            self._views_by_var[v] = view
            self._views_by_name[v.longname] = view
            self._ordered_names.append(v.longname)

        for ref in self._vectors:
            self._load_views_for_name(self._mdf, ref.longname, [ref.longname, ref.signal_name])

        for ref in self._can_refs:
            self._load_views_for_name(self._mdf, ref.longname, [ref.longname, ref.signal_name])

        try:
            names = list(self._mdf.get_channel_names())
        except Exception:
            names = []
        for n in names:
            if n not in self._views_by_name:
                try:
                    sig = _get_signal_preferred(self._mdf, n, prefer_raw=self._prefer_raw)
                    sig = self._maybe_upgrade_enum_to_raw(self._mdf, sig, [n])
                    self._views_by_name[n] = _SignalView(sig, display_name=n)
                except Exception:
                    continue

        if self._normalize_time_zero:
            self._normalize_time_zero_in_views()

    def finalize(self):
        try:
            self._app.Measurement.Stop()
        except Exception:
            pass

        t_end = time.time() + 5.0
        while time.time() < t_end:
            try:
                active = bool(getattr(self._app.Measurement, "Active"))
                if not active:
                    break
            except Exception:
                break
            time.sleep(0.05)

        for entry in self._touched_items:
            dev_name = entry.get('dev_name')
            task_name = entry.get('task_name')
            ch_name = entry.get('ch_name')
            existed = entry.get('existed_before', False)
            prev_save = entry.get('prev_save2mdf', None)
            try:
                try:
                    dev_com = self._app.Devices.Item(dev_name)
                except Exception:
                    dev_com = self._app.Project.Devices.Item(dev_name)
                tsk = dev_com.Tasks(task_name)
                chs = tsk.Channels
                if existed:
                    try:
                        if prev_save is not None:
                            chs(ch_name).Save2MDF = bool(prev_save)
                        else:
                            chs(ch_name).Save2MDF = False
                    except Exception:
                        pass
                else:
                    try:
                        chs.Remove(ch_name)
                    except Exception:
                        try:
                            chs(ch_name).Save2MDF = False
                        except Exception:
                            pass
            except Exception:
                pass

        touched_keys = {(e['dev_name'], e['task_name'], e['ch_name']) for e in self._touched_items}
        for entry in self._disabled_items:
            key = (entry.get('dev_name'), entry.get('task_name'), entry.get('ch_name'))
            if key in touched_keys:
                continue
            if not entry.get('prev_save2mdf', False):
                continue
            try:
                dev_name = entry['dev_name']
                task_name = entry['task_name']
                ch_name = entry['ch_name']
                try:
                    dev_com = self._app.Devices.Item(dev_name)
                except Exception:
                    dev_com = self._app.Project.Devices.Item(dev_name)
                tsk = dev_com.Tasks(task_name)
                tsk.Channels(ch_name).Save2MDF = True
            except Exception:
                pass

        _wait_for_file_stable(self.filepath, timeout_s=30.0, poll_s=0.25)
        self._load_views()

    def __getitem__(self, key: Union[CanapeVariable, str]) -> _SignalView:
        if isinstance(key, CanapeVariable):
            view = self._views_by_var.get(key)
            if view is not None:
                return view
            longname = getattr(key, "longname", None)
            if longname and longname in self._views_by_name:
                return self._views_by_name[longname]
            if longname:
                tail = longname.split(":", 1)[-1]
                matches = [n for n in self._views_by_name.keys()
                           if n.endswith(":" + tail) or n.endswith("." + tail) or n == tail]
                if len(matches) == 1:
                    return self._views_by_name[matches[0]]
            raise KeyError(f"No recorded data for {getattr(key, 'longname', repr(key))} in '{self.filepath}'")
        elif isinstance(key, str):
            if key in self._views_by_name:
                return self._views_by_name[key]
            tail = key.split(":", 1)[-1]
            matches = [n for n in self._views_by_name.keys()
                       if n.endswith(":" + tail) or n.endswith("." + tail) or n == tail]
            if len(matches) == 1:
                return self._views_by_name[matches[0]]
            raise KeyError(f"No recorded data for '{key}' in '{self.filepath}'")
        else:
            raise TypeError("Key must be a CanapeVariable or 'Device:Variable' string.")

    @property
    def signals(self) -> List[str]:
        return list(self._ordered_names)

    def values(self) -> List[_SignalView]:
        out: List[_SignalView] = []
        for name in self._ordered_names:
            view = self._views_by_name.get(name)
            if view is not None:
                out.append(view)
        return out

    def y_values(self) -> List[Tuple[str, np.ndarray]]:
        out: List[Tuple[str, np.ndarray]] = []
        for name in self._ordered_names:
            view = self._views_by_name.get(name)
            if view is not None:
                out.append((name, view.y))
        return out

    def close(self):
        try:
            if self._mdf is not None:
                self._mdf.close()
        except Exception:
            pass


class CanapeDevice:
    def __init__(self, app, device_com, name: str):
        self.app = app
        self.dev = device_com
        self.name = name


class CanapeAutomation:
    def __init__(self, project_path: Optional[str] = None):
        self.app = _dispatch_canape()
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except Exception:
            pass

        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"

        try:
            self.app.Open2(project_path, 1, 100000, 0, 0, 1)
        except Exception:
            self.app.Open(project_path)
        time.sleep(2)

        self.devices: Dict[str, CanapeDevice] = {}
        self._var_cache: Dict[str, CanapeVariable] = {}

    def add_device(self, name: str, a2l_or_dbc: str, dev_type: str, channel: int = 1) -> CanapeDevice:
        dev_com = self.app.Devices.Add(name, a2l_or_dbc, dev_type, channel)
        dev = CanapeDevice(self.app, dev_com, name)
        self.devices[name] = dev
        return dev

    def add_xcp_on_dap_ecu(
        self,
        name: str,
        a2l_path: str,
        channel: int = 1,
        *,
        transport: str = "VX1000",
        serial: str = "",
        dap_port: int = 1,
        mcu: str = "AURIX",
        jtag_clock_hz: int = 10_000_000,
    ) -> CanapeDevice:
        dev = self.add_device(name, a2l_path, "XCP", channel)
        try:
            dev.dev.Protocol = "XCP"
        except Exception:
            pass
        xcp = getattr(dev.dev, "XCP", None) or getattr(dev.dev, "ProtocolObject", None)
        if xcp is not None:
            for prop in ("Transport", "Driver"):
                try:
                    setattr(xcp, prop, transport)
                    break
                except Exception:
                    continue
            vx = getattr(xcp, "VX1000", None)
            if vx is not None:
                try:
                    try:
                        vx.Device = transport
                    except Exception:
                        pass
                    if serial:
                        vx.SerialNumber = serial
                    vx.DapPort = dap_port
                    vx.MCU = mcu
                    vx.JtagClockHz = int(jtag_clock_hz)
                except Exception:
                    pass
            else:
                params = getattr(xcp, "Parameters", None)
                if params is not None:
                    def set_param(k, v):
                        try:
                            params.Item(k).Value = v
                        except Exception:
                            pass
                    set_param("Transport", transport)
                    if serial:
                        set_param("SerialNumber", serial)
                    set_param("DAPPort", dap_port)
                    set_param("MCU", mcu)
                    set_param("JtagClockHz", int(jtag_clock_hz))
        return dev

    def is_online(self, device_name: str) -> bool:
        dev = self.devices.get(device_name)
        if dev is None:
            try:
                dev_com = self.app.Project.Devices.Item(device_name)
            except Exception:
                return False
            return _device_is_online(dev_com)
        return _device_is_online(dev.dev)

    def go_online(self, device_name: str, timeout_s: float = 5.0) -> bool:
        dev = self.devices.get(device_name)
        dev_com = dev.dev if dev else None
        if dev_com is None:
            try:
                dev_com = self.app.Project.Devices.Item(device_name)
            except Exception:
                return False
        if _device_is_online(dev_com):
            return True
        try:
            dev_com.GoOnline(False)
        except Exception:
            try:
                dev_com.GoOnline()
            except Exception:
                pass
        end = time.time() + timeout_s
        while time.time() < end:
            if _device_is_online(dev_com):
                return True
            time.sleep(0.05)
        return _device_is_online(dev_com)

    def go_online_all(self, reconnect: bool = False):
        for dev in self.devices.values():
            try:
                dev.dev.GoOnline(reconnect)
            except Exception:
                pass

    def close(self):
        try:
            for dev in self.devices.values():
                try:
                    dev.dev.GoOffline()
                except Exception:
                    pass
        finally:
            try:
                self.app.Quit()
            except Exception:
                pass

    def __getitem__(self, longname: str) -> CanapeVariable:
        if ":" not in longname:
            raise ValueError('Use "Device:Variable", e.g., "XCPsim:ampl"')
        devname, varname = longname.split(":", 1)
        if devname not in self.devices:
            try:
                dev_com = self.app.Project.Devices.Item(devname)
                self.devices[devname] = CanapeDevice(self.app, dev_com, devname)
            except Exception:
                raise KeyError(f"Device '{devname}' is not added and not found in project.")
        key = f"{devname}:{varname}"
        if key in self._var_cache:
            return self._var_cache[key]
        var = CanapeVariable(self.app, self.devices[devname].dev, devname, varname)
        self._var_cache[key] = var
        return var

    @staticmethod
    def _normalize_task_signals(
        signals: Optional[Iterable[Union[str, CanapeVariable]]],
        kind: str,
    ) -> List[_TaskSignalRef]:
        out: List[_TaskSignalRef] = []
        if not signals:
            return out
        for item in signals:
            if item is None:
                continue
            if isinstance(item, CanapeVariable):
                out.append(_TaskSignalRef(item.device_name, item.varname))
            elif isinstance(item, str):
                if ":" not in item:
                    raise ValueError(f"Invalid {kind} signal '{item}', expected 'Device:Signal'")
                dev, sig = item.split(":", 1)
                out.append(_TaskSignalRef(dev, sig))
            else:
                raise TypeError(f"{kind}_signals entries must be 'Device:Signal' or CanapeVariable")
        return out

    @contextmanager
    def recorder(
        self,
        *signals: Union[CanapeVariable, str],
        task: str = "100ms",
        sampling_time: Optional[int] = 100,
        mdf_path: Optional[str] = None,
        vector_signals: Optional[Iterable[Union[str, CanapeVariable]]] = None,
        vector_task: str = "cyclic",
        vector_sampling_time: Optional[int] = None,
        can_signals: Optional[Iterable[Union[str, CanapeVariable]]] = None,
        can_task: str = "can",
        can_sampling_time: Optional[int] = None,
        prefer_raw: bool = False,
        prefer_enum_numeric: bool = True,
        normalize_time_zero: bool = True,
        debug_leak_check: bool = False,
        ensure_all_devices_online: bool = True,  # NEW: bring all project devices online before Start()
        require_all_online: bool = False,        # NEW: if True, raise if any device cannot go online
        online_timeout_s: float = 5.0,           # timeout per device to go online
    ):
        # Normalize ECU/XCP signals
        var_list: List[CanapeVariable] = []
        for item in signals:
            if item is None:
                continue
            if isinstance(item, CanapeVariable):
                var_list.append(item)
            elif isinstance(item, str):
                var_list.append(self[item])
            else:
                raise TypeError("signals must be CanapeVariable or 'Device:Variable' strings.")

        # Normalize vector + CAN signals
        vector_refs: List[_TaskSignalRef] = self._normalize_task_signals(vector_signals, "vector")
        can_refs: List[_TaskSignalRef] = self._normalize_task_signals(can_signals, "can")

        if (len(var_list) + len(vector_refs) + len(can_refs)) == 0:
            raise TypeError("Provide at least one of 'signals', 'vector_signals', or 'can_signals' to the recorder.")

        # Helpers
        def _ensure_task(dev_com, task_name: str, st: Optional[int]):
            tsk = dev_com.Tasks(task_name)
            if st is not None:
                try:
                    tsk.SamplingTime = int(st)
                except Exception:
                    pass
            return tsk

        def _disable_all_channels_in_task(dev_com, task_name: str) -> List[Tuple[str, str, bool]]:
            disabled: List[Tuple[str, str, bool]] = []
            try:
                tsk = dev_com.Tasks(task_name)
            except Exception:
                return disabled
            try:
                chs = tsk.Channels
            except Exception:
                return disabled
            for ch in _iter_collection(chs):
                try:
                    prev = bool(getattr(ch, "Save2MDF"))
                except Exception:
                    prev = False
                try:
                    ch.Save2MDF = False
                except Exception:
                    pass
                try:
                    name = getattr(ch, "Name")
                except Exception:
                    name = None
                if name:
                    disabled.append((task_name, name, prev))
            return disabled

        def _disable_all_channels_all_tasks_for_device(dev_com, dev_name: str) -> List[Dict[str, Any]]:
            out: List[Dict[str, Any]] = []
            tasks = getattr(dev_com, "Tasks", None)
            if tasks is None:
                return out
            for t in _iter_collection(tasks):
                try:
                    tname = getattr(t, "Name")
                except Exception:
                    continue
                for task_name, ch_name, prev in _disable_all_channels_in_task(dev_com, tname):
                    out.append({'dev_name': dev_name, 'task_name': task_name, 'ch_name': ch_name, 'prev_save2mdf': prev})
            return out

        # Stop any running measurement and reset time base (best-effort)
        try:
            self.app.Measurement.Stop()
        except Exception:
            pass
        for meth in ("ResetTime", "ResetTimeBase", "ResetTimeOrigin", "ResetMeasurementTime", "SetTimeZero"):
            try:
                fn = getattr(self.app.Measurement, meth)
                if callable(fn):
                    fn()
            except Exception:
                pass

        # NEW: Ensure ALL project devices are online before we touch tasks/channels
        if ensure_all_devices_online:
            proj = getattr(self.app, "Project", None)
            devices_coll = getattr(proj, "Devices", None) if proj else None
            offline: List[str] = []
            if devices_coll is not None:
                for dev in _iter_collection(devices_coll):
                    try:
                        dev_name = getattr(dev, "Name")
                    except Exception:
                        continue
                    if _device_is_online(dev):
                        continue
                    # Try to go online
                    try:
                        dev.GoOnline(False)
                    except Exception:
                        try:
                            dev.GoOnline()
                        except Exception:
                            pass
                    end = time.time() + float(online_timeout_s)
                    while time.time() < end and not _device_is_online(dev):
                        time.sleep(0.05)
                    if not _device_is_online(dev):
                        offline.append(dev_name)
            if offline:
                msg = f"Could not bring these devices online: {', '.join(offline)}"
                if require_all_online:
                    raise RuntimeError(msg)
                else:
                    print("WARN:", msg)

        # Globally disable Save2MDF across ALL project devices (prevents stray channels)
        disabled_items: List[Dict[str, Any]] = []
        proj = getattr(self.app, "Project", None)
        devices_coll = getattr(proj, "Devices", None) if proj else None
        if devices_coll is not None:
            for dev in _iter_collection(devices_coll):
                try:
                    dev_name = getattr(dev, "Name")
                except Exception:
                    continue
                disabled_items.extend(_disable_all_channels_all_tasks_for_device(dev, dev_name))

        # Prepare list of channels we explicitly touch (to restore/remove)
        touched_items: List[Dict[str, Any]] = []

        # Add/enable requested channels
        def _add_or_prepare_channel(dev_name: str, task_name: str, ch_name: str, st: Optional[int]):
            # Resolve device COM: prefer our registry, else project devices
            dev_com = None
            dev_obj = self.devices.get(dev_name)
            if dev_obj is not None:
                dev_com = dev_obj.dev
            else:
                try:
                    dev_com = self.app.Project.Devices.Item(dev_name)
                except Exception:
                    raise KeyError(f"Device '{dev_name}' not found in self.devices or Project.Devices")

            tsk = _ensure_task(dev_com, task_name, st)

            existed_before = False
            prev_save = None
            try:
                ch = tsk.Channels(ch_name)  # if exists
                existed_before = True
                try:
                    prev_save = bool(ch.Save2MDF)
                except Exception:
                    prev_save = None
                try:
                    ch.Save2MDF = True
                except Exception:
                    pass
            except Exception:
                # Add the channel
                try:
                    tsk.Channels.Add(ch_name)
                    try:
                        tsk.Channels(ch_name).Save2MDF = True
                    except Exception:
                        pass
                except Exception:
                    # If add failed, try enabling if it suddenly exists
                    try:
                        tsk.Channels(ch_name).Save2MDF = True
                        existed_before = True
                    except Exception:
                        pass

            touched_items.append({
                'dev_name': dev_name,
                'task_name': task_name,
                'ch_name': ch_name,
                'existed_before': existed_before,
                'prev_save2mdf': prev_save
            })

        # ECU vars by device
        cal_by_dev: Dict[str, List[CanapeVariable]] = {}
        for v in var_list:
            cal_by_dev.setdefault(v.device_name, []).append(v)

        for devname, dev_vars in cal_by_dev.items():
            # Ensure sampling time once
            if devname in self.devices:
                dev_com = self.devices[devname].dev
            else:
                try:
                    dev_com = self.app.Project.Devices.Item(devname)
                except Exception:
                    raise KeyError(f"Device '{devname}' not found.")
            _ensure_task(dev_com, task, sampling_time)
            for v in dev_vars:
                try:
                    dev_com.CalibrationObjects.Add(v.varname)
                except Exception:
                    pass
                _add_or_prepare_channel(devname, task, v.varname, None)

        # Vector driver signals
        vec_by_dev: Dict[str, List[_TaskSignalRef]] = {}
        for r in vector_refs:
            vec_by_dev.setdefault(r.device_name, []).append(r)
        for devname, refs in vec_by_dev.items():
            if devname in self.devices:
                dev_com = self.devices[devname].dev
            else:
                try:
                    dev_com = self.app.Project.Devices.Item(devname)
                except Exception:
                    raise KeyError(f"Vector device '{devname}' not found.")
            _ensure_task(dev_com, vector_task, vector_sampling_time)
            for r in refs:
                _add_or_prepare_channel(devname, vector_task, r.signal_name, None)

        # CAN bus signals
        can_by_dev: Dict[str, List[_TaskSignalRef]] = {}
        for r in can_refs:
            can_by_dev.setdefault(r.device_name, []).append(r)
        for devname, refs in can_by_dev.items():
            if devname in self.devices:
                dev_com = self.devices[devname].dev
            else:
                try:
                    dev_com = self.app.Project.Devices.Item(devname)
                except Exception:
                    raise KeyError(f"CAN device '{devname}' not found.")
            if can_sampling_time is not None:
                _ensure_task(dev_com, can_task, can_sampling_time)
            for r in refs:
                _add_or_prepare_channel(devname, can_task, r.signal_name, None)

        # Optional leak check: any enabled channel not requested?
        if debug_leak_check and devices_coll is not None:
            touched_keys = {(e['dev_name'], e['task_name'], e['ch_name']) for e in touched_items}
            leaks: List[Tuple[str, str, str]] = []
            for dev in _iter_collection(devices_coll):
                try:
                    dev_name = getattr(dev, "Name")
                except Exception:
                    continue
                tasks = getattr(dev, "Tasks", None)
                if tasks is None:
                    continue
                for t in _iter_collection(tasks):
                    try:
                        tname = t.Name
                    except Exception:
                        continue
                    chs = getattr(t, "Channels", None)
                    if chs is None:
                        continue
                    for ch in _iter_collection(chs):
                        try:
                            name = ch.Name
                            s2m = bool(ch.Save2MDF)
                        except Exception:
                            continue
                        if s2m and (dev_name, tname, name) not in touched_keys:
                            leaks.append((dev_name, tname, name))
            if leaks:
                print("WARN: Save2MDF still enabled for non-requested channels before Start():")
                for d, t, c in leaks:
                    print(f"  - {d}.{t}:{c}")

        # MDF path handling
        if mdf_path is None:
            stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            mdf_path = os.path.abspath(f"canape_recording_{stamp}.mf4")
        _ensure_parent_dir(mdf_path)
        if os.path.exists(mdf_path):
            try:
                os.remove(mdf_path)
            except Exception:
                base, ext = os.path.splitext(mdf_path)
                mdf_path = f"{base}_{int(time.time())}{ext}"

        # Try to force overwrite/no-append and relative time when available
        for prop, val in (("AppendToMDF", False), ("OverwriteMDF", True), ("OverwriteMDFFiles", True)):
            try:
                setattr(self.app.Measurement, prop, val)
            except Exception:
                pass
        for prop, val in (
            ("UseAbsoluteTime", False),
            ("AbsoluteTimeInMDF", False),
            ("MDFAbsoluteTime", False),
            ("StoreAbsoluteTime", False),
            ("TimeMode", "Relative"),
        ):
            try:
                setattr(self.app.Measurement, prop, val)
            except Exception:
                pass
        try:
            self.app.Measurement.MDFFilename = mdf_path
        except Exception:
            pass

        time.sleep(0.05)
        try:
            self.app.Measurement.Start()
        except Exception:
            pass

        rec = RecorderResult(
            self.app,
            touched_items,
            disabled_items,
            var_list,
            vector_refs,
            can_refs,
            mdf_path,
            prefer_raw=prefer_raw,
            prefer_enum_numeric=prefer_enum_numeric,
            normalize_time_zero=normalize_time_zero,
        )
        try:
            yield rec
        finally:
            rec.finalize()
