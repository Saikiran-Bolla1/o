# Requires:
#   pip install pywin32 asammdf numpy
#
# Features:
# - Direct longname access: var = session["Device:Variable"]
# - Recording uses CANape's MF4 only (no background threads).
# - session.recorder(...) sets CANape.Measurement.MDFFilename to your path and reads the same file.
# - After the with-block:
#     V = rec[var]  or  V = rec["Device:Variable"]
#     V.x -> timestamps (numpy array)
#     V.y -> values (numpy array)
#     V.name -> "Device:Variable" when resolvable (else raw MF4 name)
#     V.data -> ((x0,y0), ..., (xn,yn))
# - rec.signals -> list of all recorded signal names (as provided to the recorder)
# - rec.values() -> list of objects having name, x, y, data
#
# Vector driver AND CAN bus support:
# - vector_signals: list of "Device:Signal" or CanapeVariable
#   vector_task: task name for vector signals (default "cyclic")
#   vector_sampling_time: sampling time (ms) for vector_task
# - can_signals: list of "Device:Signal" strings (or CanapeVariable, if you mapped one). Adds to CAN task.
#   can_task: task name for CAN signals (default "can")
#   can_sampling_time: optional sampling time (ms) for can_task (many CAN tasks are event-driven; keep None)
#
# XCP/CCP (ECU) signals:
# - Pass XCP/CCP measurement variables or calibration objects as "*signals" (CanapeVariable or "Device:Variable").
#   They are added to 'task' with 'sampling_time'.
#
# Important:
# - This version reads PHYSICAL values by default (matches CANape UI).
# - If a channel is an enum/text and you want the NUMERIC enum VALUE instead of the enum NAME,
#   pass prefer_enum_numeric=True to recorder(...). That will automatically re-read such channels RAW.
# - If you want all channels in RAW form, pass prefer_raw=True.
#
# Recorder safety (to avoid "ghost" channels and time offsets):
# - Before Start(): disables Save2MDF on ALL channels in the used tasks for the involved devices.
#   Then it enables Save2MDF only for the requested signals. This prevents leftover Vector channels from leaking in.
# - Creates/overwrites the MDF file. If a property is available, attempts to disable Append mode.
# - Optionally normalizes timestamps to start at 0 in the returned arrays (normalize_time_zero=True).
#
# Requirement:
# - The recorder requires at least one of: signals, vector_signals, or can_signals.
#   If all are empty/None (or lists containing only None), it raises TypeError.
#
# Example:
#   sess = CanapeAutomation(r"C:\path\to\CANapeProject")
#   ecu = sess.add_xcp_on_dap_ecu("ECU", r"C:\my.ecu.a2l")   # or add_device("ECU", a2l, "XCP", 1)
#   can = sess.add_device("CAN1", r"C:\bus.dbc", "CAN", 1)
#   sess.go_online_all()
#
#   with sess.recorder(
#       "ECU:EngSpd", "ECU:PedalPos",         # ECU/XCP signals (optional group)
#       vector_signals=["VectorDev:SigA"],    # optional vector driver signals
#       can_signals=["CAN1:VIN1.Kanal1", "CAN1:VIN1.Kanal2"],  # optional CAN DBC signals
#       task="10ms", sampling_time=10,
#       can_task="can", can_sampling_time=None,
#       mdf_path=r"C:\logs\run1.mf4",
#       prefer_enum_numeric=True,
#       normalize_time_zero=False
#   ) as rec:
#       import time; time.sleep(5.0)
#
#   spd = rec["ECU:EngSpd"]
#   print(spd.x[:5], spd.y[:5])
#
import os
import re
import time
import win32com.client
import numpy as np
from datetime import datetime
from contextlib import contextmanager
from typing import Dict, List, Optional, Union, Any, Tuple, Iterable

from asammdf import MDF, Signal


def _dispatch_canape():
    # Create the CANape COM application
    return win32com.client.Dispatch("CANape.Application")


def _ensure_parent_dir(path: str):
    parent = os.path.dirname(os.path.abspath(path))
    if parent and not os.path.exists(parent):
        os.makedirs(parent, exist_ok=True)


def _wait_for_file_stable(path: str, timeout_s: float = 30.0, poll_s: float = 0.25) -> bool:
    end = time.time() + timeout_s
    last = -1
    seen = False
    while time.time() < end:
        if os.path.exists(path):
            size = os.path.getsize(path)
            if seen and size == last and size > 0:
                return True
            last = size
            seen = True
        time.sleep(poll_s)
    return os.path.exists(path)


class CanapeVariable:
    def __init__(self, app, device_com, device_name: str, varname: str):
        self._app = app
        self._dev = device_com
        self.device_name = device_name
        self.varname = varname
        self.longname = f"{device_name}:{varname}"

    @property
    def value(self):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, val):
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Value = val
        obj.Write()

    def __repr__(self):
        return f"<CanapeVariable {self.longname}>"


class _TaskSignalRef:
    """
    A generic reference to a device's channel/signal that is added to a CANape task.
    Used for Vector driver signals and CAN bus signals alike.
    """
    def __init__(self, device_name: str, signal_name: str):
        self.device_name = device_name
        self.signal_name = signal_name

    @property
    def longname(self) -> str:
        return f"{self.device_name}:{self.signal_name}"

    def __repr__(self):
        return f"<TaskSignal {self.longname}>"


def _get_signal_preferred(mdf: MDF, name: str, prefer_raw: bool = False) -> Signal:
    """
    Return Signal from MDF, preferring PHYSICAL (converted) values by default.
    Set prefer_raw=True to force RAW (unconverted) samples.
    """
    if prefer_raw:
        try:
            return mdf.get(name, raw=True)
        except Exception:
            return mdf.get(name)
    else:
        try:
            return mdf.get(name)  # physical/converted
        except Exception:
            return mdf.get(name, raw=True)


def _to_float_safe(val) -> float:
    # Already numeric
    if isinstance(val, (int, float, np.integer, np.floating)):
        return float(val)
    if val is None:
        return np.nan
    # Decode bytes
    if isinstance(val, (bytes, bytearray)):
        try:
            val = val.decode("utf-8", errors="ignore")
        except Exception:
            return np.nan

    s = str(val).strip().replace("\xa0", " ")  # strip NBSP
    if s == "" or s.lower() in ("nan", "none", "null"):
        return np.nan
    # Booleans / common text tokens
    low = s.lower()
    if low in ("true", "on", "high", "yes"):
        return 1.0
    if low in ("false", "off", "low", "no"):
        return 0.0

    # Extract first numeric token (supports comma or dot decimal, scientific notation)
    m = re.search(r"[-+]?\d+(?:[.,]\d+)?(?:[eE][-+]?\d+)?", s)
    if m:
        num = m.group(0).replace(",", ".")  # normalize decimal comma
        try:
            return float(num)
        except Exception:
            pass
    return np.nan


def _maybe_text_to_raw(samples: np.ndarray, signal: Signal) -> np.ndarray:
    # If already numeric, return as-is
    if hasattr(samples, "dtype") and samples.dtype.kind in ("i", "u", "f", "b"):
        return samples

    # Try to use conversion mapping (enum text -> numeric), then fall back to safe parse
    conv = getattr(signal, "conversion", None)
    mapping = None
    if conv is not None:
        # Try common attribute names across asammdf versions
        for attr in ("text_2_value", "text2value", "text_to_value", "value_map", "val_map", "mapping"):
            mapping = getattr(conv, attr, None)
            if mapping:
                break
        # If mapping looks like parallel arrays
        if mapping is None:
            texts = getattr(conv, "texts", None) or getattr(conv, "labels", None)
            values = getattr(conv, "values", None) or getattr(conv, "ids", None)
            if texts is not None and values is not None:
                try:
                    mapping = {t: v for t, v in zip(texts, values)}
                except Exception:
                    mapping = None

    out = []
    if mapping:
        for s in samples:
            # Direct mapping
            if s in mapping:
                v = mapping[s]
                out.append(_to_float_safe(v))
                continue
            # Try decoded/normalized lookup
            if isinstance(s, (bytes, bytearray)):
                try:
                    s2 = s.decode(errors="ignore")
                except Exception:
                    s2 = ""
            else:
                s2 = str(s)
            v = mapping.get(s2, None)
            if v is not None:
                out.append(_to_float_safe(v))
            else:
                out.append(_to_float_safe(s))
    else:
        out = [_to_float_safe(s) for s in samples]

    return np.array(out, dtype=float)


class _SignalView:
    def __init__(self, signal: Signal, display_name: Optional[str] = None, force_text_to_numeric: bool = True):
        self._sig = signal
        self._name = display_name or signal.name

        xs = signal.timestamps
        ys = signal.samples

        # Convert enum/text to numeric if needed
        if force_text_to_numeric and (hasattr(ys, "dtype") and ys.dtype.kind in ("O", "U", "S")):
            ys = _maybe_text_to_raw(ys, signal)

        self._x = np.asarray(xs)
        self._y = np.asarray(ys)

    @property
    def x(self):
        return self._x

    @property
    def y(self):
        return self._y

    @property
    def name(self) -> str:
        return self._name

    @property
    def data(self) -> Tuple[Tuple[float, float], ...]:
        n = min(len(self._x), len(self._y))
        return tuple((float(self._x[i]), float(self._y[i])) for i in range(n))

    def __repr__(self):
        return f"<SignalView name={self._name!r} len={len(self._x)}>"


class RecorderResult:
    """
    Created by session.recorder(...). Finalized AFTER the with-block.
    Data source: the MF4 file written by CANape.

    Shortcuts:
      - rec.signals  -> list of recorded signal names (preserve recorder order)
      - rec.values() -> list of per-signal objects each having name, x, y, data
    """
    def __init__(
        self,
        app,
        cleanup_items: List[Dict[str, Any]],  # entries with dev_name, task_name, ch_name, existed_before, prev_save2mdf
        var_list: List[CanapeVariable],
        vector_refs: List[_TaskSignalRef],
        can_refs: List[_TaskSignalRef],
        mdf_path: str,
        prefer_raw: bool = False,
        prefer_enum_numeric: bool = True,
        normalize_time_zero: bool = False,
    ):
        self._app = app
        self._cleanup_items = cleanup_items
        self._vars = var_list
        self._vectors = vector_refs
        self._can_refs = can_refs
        self.filepath = os.path.abspath(mdf_path)
        self._prefer_raw = prefer_raw
        self._prefer_enum_numeric = prefer_enum_numeric
        self._normalize_time_zero = normalize_time_zero

        self._mdf: Optional[MDF] = None
        self._views_by_var: Dict[CanapeVariable, _SignalView] = {}
        self._views_by_name: Dict[str, _SignalView] = {}
        self._ordered_names: List[str] = []  # keep order consistent with input

    def _resolve_signal(self, mdf: MDF, candidates: List[str]) -> Optional[Signal]:
        # Try candidates in order with preference
        for name in candidates:
            try:
                return _get_signal_preferred(mdf, name, prefer_raw=self._prefer_raw)
            except Exception:
                continue
        # Case-insensitive exact match
        try:
            names = list(mdf.get_channel_names())
        except Exception:
            names = []
        lower = {n.lower(): n for n in names}
        for cand in candidates:
            n = lower.get(cand.lower())
            if n:
                try:
                    return _get_signal_preferred(mdf, n, prefer_raw=self._prefer_raw)
                except Exception:
                    pass
        # Unique suffix matches
        for cand in candidates:
            tail = cand.split(":", 1)[-1]
            for sep in (":", "."):
                suffix = f"{sep}{tail}"
                matches = [n for n in names if n.endswith(suffix)]
                if len(matches) == 1:
                    try:
                        return _get_signal_preferred(mdf, matches[0], prefer_raw=self._prefer_raw)
                    except Exception:
                        pass
        return None

    def _maybe_upgrade_enum_to_raw(self, mdf: MDF, sig: Signal, candidates: List[str]) -> Signal:
        """
        If prefer_enum_numeric is True and the signal contains text samples, re-fetch RAW.
        """
        try:
            ys = sig.samples
            is_text = hasattr(ys, "dtype") and ys.dtype.kind in ("O", "U", "S")
        except Exception:
            is_text = False

        if self._prefer_enum_numeric and is_text:
            # Try to fetch RAW using the same candidate names
            for name in candidates:
                try:
                    raw_sig = _get_signal_preferred(mdf, name, prefer_raw=True)
                    return raw_sig
                except Exception:
                    continue
        return sig

    def _load_views_for_name(self, mdf: MDF, display_name: str, candidates: List[str]):
        sig = self._resolve_signal(mdf, candidates)
        if sig is None:
            return
        sig = self._maybe_upgrade_enum_to_raw(mdf, sig, candidates)
        view = _SignalView(sig, display_name=display_name)
        self._views_by_name[display_name] = view
        self._ordered_names.append(display_name)

    def _normalize_time_zero_in_views(self):
        t0 = None
        for view in self._views_by_name.values():
            if hasattr(view, "_x") and view._x.size:
                t0 = view._x[0] if t0 is None else min(t0, view._x[0])
        if t0 is not None and t0 != 0.0:
            for view in self._views_by_name.values():
                if hasattr(view, "_x") and view._x.size:
                    view._x = view._x - t0

    def _load_views(self):
        self._mdf = MDF(self.filepath)

        # Calibration / XCP variables
        for v in self._vars:
            candidates = [v.longname, v.varname]
            sig = self._resolve_signal(self._mdf, candidates)
            if sig is None:
                continue
            sig = self._maybe_upgrade_enum_to_raw(self._mdf, sig, candidates)
            view = _SignalView(sig, display_name=v.longname)
            self._views_by_var[v] = view
            self._views_by_name[v.longname] = view
            self._ordered_names.append(v.longname)

        # Vector driver signals
        for ref in self._vectors:
            self._load_views_for_name(self._mdf, ref.longname, [ref.longname, ref.signal_name])

        # CAN bus signals
        for ref in self._can_refs:
            self._load_views_for_name(self._mdf, ref.longname, [ref.longname, ref.signal_name])

        # Also allow access by raw MDF names
        try:
            names = list(self._mdf.get_channel_names())
        except Exception:
            names = []
        for n in names:
            if n not in self._views_by_name:
                try:
                    sig = _get_signal_preferred(self._mdf, n, prefer_raw=self._prefer_raw)
                    sig = self._maybe_upgrade_enum_to_raw(self._mdf, sig, [n])
                    self._views_by_name[n] = _SignalView(sig, display_name=n)
                except Exception:
                    continue

        if self._normalize_time_zero:
            self._normalize_time_zero_in_views()

    def finalize(self):
        # Stop CANape measurement
        try:
            self._app.Measurement.Stop()
        except Exception:
            pass

        # Wait until measurement is really inactive
        t_end = time.time() + 5.0
        while time.time() < t_end:
            try:
                active = bool(getattr(self._app.Measurement, "Active"))
                if not active:
                    break
            except Exception:
                break
            time.sleep(0.05)

        # Cleanup: for each channel we touched, restore/remove
        for entry in self._cleanup_items:
            dev_name = entry.get('dev_name')
            task_name = entry.get('task_name')
            ch_name = entry.get('ch_name')
            existed = entry.get('existed_before', False)
            prev_save = entry.get('prev_save2mdf', None)

            try:
                # Reacquire COM objects freshly
                dev_com = None
                try:
                    dev_com = self._app.Devices.Item(dev_name)
                except Exception:
                    dev_com = self._app.Project.Devices.Item(dev_name)

                tsk = dev_com.Tasks(task_name)
                chs = tsk.Channels

                if existed:
                    # Restore Save2MDF to previous state (or default False)
                    try:
                        if prev_save is not None:
                            chs(ch_name).Save2MDF = bool(prev_save)
                        else:
                            chs(ch_name).Save2MDF = False
                    except Exception:
                        pass
                else:
                    # We added this channel, remove it completely
                    try:
                        chs.Remove(ch_name)
                    except Exception:
                        # As a fallback, disable Save2MDF
                        try:
                            chs(ch_name).Save2MDF = False
                        except Exception:
                            pass
            except Exception:
                # Best effort; ignore cleanup errors
                pass

        # Wait for MF4 file to appear and stabilize, then load signals
        _wait_for_file_stable(self.filepath, timeout_s=30.0, poll_s=0.25)
        self._load_views()

    def __getitem__(self, key: Union[CanapeVariable, str]) -> _SignalView:
        """
        Access recorded signals by:
          - CanapeVariable object (works for both ECU variables and Vector/CAN signals when resolvable)
          - "Device:Signal" string
          - unique tail name (if unambiguous)
        """
        if isinstance(key, CanapeVariable):
            # First try by identity (ECU variables we tracked)
            view = self._views_by_var.get(key)
            if view is not None:
                return view
            # Fallback: try by its long name (enables rec[var] for Vector/CAN signals too)
            longname = getattr(key, "longname", None)
            if longname and longname in self._views_by_name:
                return self._views_by_name[longname]
            # As a last resort, try tail-based lookup
            if longname:
                tail = longname.split(":", 1)[-1]
                matches = [n for n in self._views_by_name.keys()
                           if n.endswith(":" + tail) or n.endswith("." + tail) or n == tail]
                if len(matches) == 1:
                    return self._views_by_name[matches[0]]
            raise KeyError(f"No recorded data for {getattr(key, 'longname', repr(key))} in '{self.filepath}'")

        elif isinstance(key, str):
            if key in self._views_by_name:
                return self._views_by_name[key]
            # Tail-only lookup if unique among the recorded names
            tail = key.split(":", 1)[-1]
            matches = [n for n in self._views_by_name.keys()
                       if n.endswith(":" + tail) or n.endswith("." + tail) or n == tail]
            if len(matches) == 1:
                return self._views_by_name[matches[0]]
            raise KeyError(f"No recorded data for '{key}' in '{self.filepath}'")

        else:
            raise TypeError("Key must be a CanapeVariable or 'Device:Variable' string.")

    @property
    def signals(self) -> List[str]:
        # Only the signals explicitly configured in this recorder (preserve order)
        return list(self._ordered_names)

    def values(self) -> List[_SignalView]:
        out: List[_SignalView] = []
        for name in self._ordered_names:
            view = self._views_by_name.get(name)
            if view is not None:
                out.append(view)
        return out

    # Backward compatible helper to get names and y-arrays only
    def y_values(self) -> List[Tuple[str, np.ndarray]]:
        out: List[Tuple[str, np.ndarray]] = []
        for name in self._ordered_names:
            view = self._views_by_name.get(name)
            if view is not None:
                out.append((name, view.y))
        return out

    def close(self):
        try:
            if self._mdf is not None:
                self._mdf.close()
        except Exception:
            pass


class CanapeDevice:
    def __init__(self, app, device_com, name: str):
        self.app = app
        self.dev = device_com
        self.name = name


class CanapeAutomation:
    def __init__(self, project_path: Optional[str] = None):
        self.app = _dispatch_canape()
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except Exception:
            pass

        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"

        # Open project (Open2 args are version-dependent; keep common defaults)
        try:
            self.app.Open2(project_path, 1, 100000, 0, 0, 1)
        except Exception:
            # Fallback to Open
            self.app.Open(project_path)
        time.sleep(2)

        self.devices: Dict[str, CanapeDevice] = {}
        self._var_cache: Dict[str, CanapeVariable] = {}

    def add_device(self, name: str, a2l_or_dbc: str, dev_type: str, channel: int = 1) -> CanapeDevice:
        """
        Add a device to the opened project.

        dev_type examples:
          - "XCP" (or ECU-specific type)
          - "CAN" (DBC-based bus device)
          - Vector driver device kinds (depends on CANape setup)

        a2l_or_dbc: path to A2L for ECU, DBC for CAN, etc.
        """
        dev_com = self.app.Devices.Add(name, a2l_or_dbc, dev_type, channel)
        dev = CanapeDevice(self.app, dev_com, name)
        self.devices[name] = dev
        return dev

    def add_xcp_on_dap_ecu(
        self,
        name: str,
        a2l_path: str,
        channel: int = 1,
        *,
        transport: str = "VX1000",
        serial: str = "",
        dap_port: int = 1,
        mcu: str = "AURIX",
        jtag_clock_hz: int = 10_000_000,
    ) -> CanapeDevice:
        """
        Adds an ECU configured for XCP on DAP (Vector VX1000).
        After adding, you can go_online_all() and use recorder(...) with ECU signals.
        """
        dev = self.add_device(name, a2l_path, "XCP", channel)

        # Ensure protocol is XCP
        try:
            dev.dev.Protocol = "XCP"
        except Exception:
            pass

        # Access XCP object
        xcp = getattr(dev.dev, "XCP", None)
        if xcp is None:
            xcp = getattr(dev.dev, "ProtocolObject", None)

        if xcp is not None:
            # Transport selection
            for prop in ("Transport", "Driver"):
                try:
                    setattr(xcp, prop, transport)
                    break
                except Exception:
                    continue

            # Try strong-typed VX1000 sub-object
            vx = getattr(xcp, "VX1000", None)
            if vx is not None:
                try:
                    try:
                        vx.Device = transport  # sometimes accepts 'VX1000'
                    except Exception:
                        pass
                    if serial:
                        vx.SerialNumber = serial
                    vx.DapPort = dap_port
                    vx.MCU = mcu
                    vx.JtagClockHz = int(jtag_clock_hz)
                except Exception:
                    pass
            else:
                # Fallback: parameter bag
                params = getattr(xcp, "Parameters", None)
                if params is not None:
                    def set_param(key, value):
                        try:
                            params.Item(key).Value = value
                        except Exception:
                            pass
                    set_param("Transport", transport)
                    if serial:
                        set_param("SerialNumber", serial)
                    set_param("DAPPort", dap_port)
                    set_param("MCU", mcu)
                    set_param("JtagClockHz", int(jtag_clock_hz))

        return dev

    def go_online_all(self, reconnect: bool = False):
        for dev in self.devices.values():
            try:
                dev.dev.GoOnline(reconnect)
            except Exception:
                pass

    def close(self):
        try:
            for dev in self.devices.values():
                try:
                    dev.dev.GoOffline()
                except Exception:
                    pass
        finally:
            try:
                self.app.Quit()
            except Exception:
                pass

    def __getitem__(self, longname: str) -> CanapeVariable:
        if ":" not in longname:
            raise ValueError('Use "Device:Variable", e.g., "XCPsim:ampl"')
        devname, varname = longname.split(":", 1)
        if devname not in self.devices:
            raise KeyError(f"Device '{devname}' is not added.")
        key = f"{devname}:{varname}"
        if key in self._var_cache:
            return self._var_cache[key]
        var = CanapeVariable(self.app, self.devices[devname].dev, devname, varname)
        self._var_cache[key] = var
        return var

    @staticmethod
    def _normalize_task_signals(
        signals: Optional[Iterable[Union[str, CanapeVariable]]],
        kind: str,
    ) -> List[_TaskSignalRef]:
        """
        Normalize inputs (strings "Device:Signal" or CanapeVariable) into _TaskSignalRef objects.

        kind is only used in error messages to indicate which group (vector/can) failed.
        """
        out: List[_TaskSignalRef] = []
        if not signals:
            return out
        for item in signals:
            if item is None:
                continue
            if isinstance(item, CanapeVariable):
                out.append(_TaskSignalRef(item.device_name, item.varname))
            elif isinstance(item, str):
                if ":" not in item:
                    raise ValueError(f"Invalid {kind} signal '{item}', expected 'Device:Signal'")
                dev, sig = item.split(":", 1)
                out.append(_TaskSignalRef(dev, sig))
            else:
                raise TypeError(f"{kind}_signals entries must be 'Device:Signal' or CanapeVariable")
        return out

    @contextmanager
    def recorder(
        self,
        *signals: Union[CanapeVariable, str],
        # ECU/XCP task
        task: str = "100ms",
        sampling_time: Optional[int] = 100,
        # Output file
        mdf_path: Optional[str] = None,
        # Vector driver signals
        vector_signals: Optional[Iterable[Union[str, CanapeVariable]]] = None,
        vector_task: str = "cyclic",
        vector_sampling_time: Optional[int] = None,
        # CAN bus signals (DBC-backed device)
        can_signals: Optional[Iterable[Union[str, CanapeVariable]]] = None,
        can_task: str = "can",
        can_sampling_time: Optional[int] = None,
        # Reading preferences
        prefer_raw: bool = False,            # set True to read raw samples from MF4 for all channels
        prefer_enum_numeric: bool = True,    # if True, enum/text channels are re-read RAW to get numeric enum values
        normalize_time_zero: bool = False,   # if True, returned arrays are shifted so the earliest timestamp is 0
    ):
        """
        Start a measurement, add requested signals into their respective tasks, and record MF4.

        Safety:
          - Disables Save2MDF on all channels in the tasks being used, then enables only requested channels.
          - Ensures MDF is a fresh file; attempts to turn off Append mode when supported.

        Requirement: Provide at least one of: signals, vector_signals, or can_signals.
        """
        # Normalize "signals" -> CanapeVariable list (XCP/ECU)
        var_list: List[CanapeVariable] = []
        for item in signals:
            if item is None:
                continue
            if isinstance(item, CanapeVariable):
                var_list.append(item)
            elif isinstance(item, str):
                var_list.append(self[item])
            else:
                raise TypeError("signals must be CanapeVariable or 'Device:Variable' strings.")

        # Normalize vector + CAN signals
        vector_refs: List[_TaskSignalRef] = self._normalize_task_signals(vector_signals, "vector")
        can_refs: List[_TaskSignalRef] = self._normalize_task_signals(can_signals, "can")

        # Enforce requirement: at least one signal in any group
        if (len(var_list) + len(vector_refs) + len(can_refs)) == 0:
            raise TypeError("Provide at least one of 'signals', 'vector_signals', or 'can_signals' to the recorder.")

        # Helper: ensure task sampling time
        def _ensure_task(dev_com, task_name: str, st: Optional[int]):
            tsk = dev_com.Tasks(task_name)
            if st is not None:
                try:
                    tsk.SamplingTime = int(st)
                except Exception:
                    pass
            return tsk

        # Helper: disable Save2MDF for all channels in a task (prevent "ghost" channels)
        def _disable_all_channels(dev_com, task_name: str):
            try:
                tsk = dev_com.Tasks(task_name)
            except Exception:
                return
            try:
                chs = tsk.Channels
            except Exception:
                return
            # Generic iteration
            try:
                for ch in chs:
                    try:
                        ch.Save2MDF = False
                    except Exception:
                        pass
            except Exception:
                # Index-based fallback
                try:
                    n = chs.Count
                except Exception:
                    n = 0
                for i in range(1, n + 1):  # COM collections are often 1-based
                    try:
                        chs.Item(i).Save2MDF = False
                    except Exception:
                        pass

        # Build a cleanup plan per channel we will touch
        cleanup_items: List[Dict[str, Any]] = []

        # Prepare involved devices and disable all channels on used tasks
        devices_to_touch = set()
        devices_by_group: Dict[str, Dict[str, bool]] = {}  # dev -> which tasks used

        for v in var_list:
            devices_to_touch.add(v.device_name)
            devices_by_group.setdefault(v.device_name, {}).setdefault(task, True)

        for r in vector_refs:
            devices_to_touch.add(r.device_name)
            devices_by_group.setdefault(r.device_name, {}).setdefault(vector_task, True)

        for r in can_refs:
            devices_to_touch.add(r.device_name)
            devices_by_group.setdefault(r.device_name, {}).setdefault(can_task, True)

        for devname in devices_to_touch:
            dev = self.devices.get(devname)
            if not dev:
                raise KeyError(f"Device '{devname}' is not added.")
            # Disable all channels on each used task
            for used_task in devices_by_group.get(devname, {}).keys():
                _disable_all_channels(dev.dev, used_task)

        # Add/enable requested channels, remembering prior Save2MDF state if the channel existed
        def _add_or_prepare_channel(dev_name: str, task_name: str, ch_name: str, st: Optional[int]):
            dev = self.devices.get(dev_name)
            if dev is None:
                raise KeyError(f"Device '{dev_name}' is not added.")
            dev_com = dev.dev
            tsk = _ensure_task(dev_com, task_name, st)

            existed_before = False
            prev_save = None

            # Check if channel exists already
            try:
                ch = tsk.Channels(ch_name)  # indexer access
                existed_before = True
                try:
                    prev_save = bool(ch.Save2MDF)
                except Exception:
                    prev_save = None
                # Ensure recording for this run
                try:
                    ch.Save2MDF = True
                except Exception:
                    pass
            except Exception:
                # Add channel
                try:
                    tsk.Channels.Add(ch_name)
                    try:
                        tsk.Channels(ch_name).Save2MDF = True
                    except Exception:
                        pass
                except Exception:
                    # If add failed because it suddenly exists (race), try to enable
                    try:
                        tsk.Channels(ch_name).Save2MDF = True
                        existed_before = True
                    except Exception:
                        pass

            cleanup_items.append({
                'dev_name': dev_name,
                'task_name': task_name,
                'ch_name': ch_name,
                'existed_before': existed_before,
                'prev_save2mdf': prev_save
            })

        # ECU vars by device
        cal_by_dev: Dict[str, List[CanapeVariable]] = {}
        for v in var_list:
            cal_by_dev.setdefault(v.device_name, []).append(v)

        for devname, dev_vars in cal_by_dev.items():
            dev_com = self.devices[devname].dev
            # ensure sampling time set once
            _ensure_task(dev_com, task, sampling_time)
            for v in dev_vars:
                # Ensure calibration object exists (for calibration objects)
                try:
                    dev_com.CalibrationObjects.Add(v.varname)
                except Exception:
                    pass
                _add_or_prepare_channel(devname, task, v.varname, None)  # sampling time already applied

        # Vector driver signals
        vec_by_dev: Dict[str, List[_TaskSignalRef]] = {}
        for r in vector_refs:
            vec_by_dev.setdefault(r.device_name, []).append(r)
        for devname, refs in vec_by_dev.items():
            dev_com = self.devices[devname].dev
            _ensure_task(dev_com, vector_task, vector_sampling_time)
            for r in refs:
                _add_or_prepare_channel(devname, vector_task, r.signal_name, None)

        # CAN bus signals
        can_by_dev: Dict[str, List[_TaskSignalRef]] = {}
        for r in can_refs:
            can_by_dev.setdefault(r.device_name, []).append(r)
        for devname, refs in can_by_dev.items():
            dev_com = self.devices[devname].dev
            # Many CAN tasks are event-driven; set sampling time only if provided
            if can_sampling_time is not None:
                _ensure_task(dev_com, can_task, can_sampling_time)
            for r in refs:
                _add_or_prepare_channel(devname, can_task, r.signal_name, None)

        # MDF path
        if mdf_path is None:
            stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            mdf_path = os.path.abspath(f"canape_recording_{stamp}.mf4")
        _ensure_parent_dir(mdf_path)

        # Prefer a fresh file; if exists, remove or uniquify
        if os.path.exists(mdf_path):
            try:
                os.remove(mdf_path)
            except Exception:
                base, ext = os.path.splitext(mdf_path)
                mdf_path = f"{base}_{int(time.time())}{ext}"

        # Try to force overwrite/no-append and relative time when available
        for prop, val in (("AppendToMDF", False), ("OverwriteMDF", True), ("OverwriteMDFFiles", True)):
            try:
                setattr(self.app.Measurement, prop, val)
            except Exception:
                pass
        for prop, val in (
            ("UseAbsoluteTime", False),
            ("AbsoluteTimeInMDF", False),
            ("MDFAbsoluteTime", False),
            ("StoreAbsoluteTime", False),
            ("TimeMode", "Relative"),  # may be enum; string often accepted late-bound
        ):
            try:
                setattr(self.app.Measurement, prop, val)
            except Exception:
                pass

        try:
            self.app.Measurement.MDFFilename = mdf_path
        except Exception:
            pass

        # Start measurement
        try:
            self.app.Measurement.Start()
        except Exception:
            pass

        rec = RecorderResult(
            self.app,
            cleanup_items,
            var_list,
            vector_refs,
            can_refs,
            mdf_path,
            prefer_raw=prefer_raw,
            prefer_enum_numeric=prefer_enum_numeric,
            normalize_time_zero=normalize_time_zero,
        )
        try:
            yield rec
        finally:
            rec.finalize()
