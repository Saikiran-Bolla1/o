"""
CANape automation helper with explicit Recorder lifecycle.

Updates (reflecting Vector CANape COM docs for IRecorders / IMeasurementRecorders):
- Creates a dedicated recorder via Application.Recorders.Add(name)
- Assigns the recorder to each added channel using Channel.AssignedRecorders.Add(recorder)
- Added exclusive_recorder flag (default True):
    * True  -> Clear existing AssignedRecorders before adding ours (exclusive use)
    * False -> Keep existing; just Add ours and later Remove only ours
- During finalization:
    * Stops measurement
    * Removes ONLY our recorder assignment from each channel using
          Channel.AssignedRecorders.Remove(recorderObj) or Remove("RecorderName")
      (falls back to Clear only if exclusive_recorder True or targeted removal fails)
    * Removes the recorder object from Application.Recorders.Remove("RecorderName")
- Avoids overuse of .Clear() which would remove unrelated recorder mappings.

Other retained features:
- Direct variable access: sess["Device:Var"]
- Supports ECU (XCP/CCP) variables, Vector driver signals, CAN (DBC) signals
- Physical values by default; can force raw or numeric enum values
- Ensures devices online before read/write/record
- Clears all task channels before starting (your earlier request)
- After recording, clears task channels again
- Returns parsed MF4 data via RecorderResult

Requires:
  pip install pywin32 asammdf numpy
"""

import os, re, time
import win32com.client
import numpy as np
from datetime import datetime
from contextlib import contextmanager
from typing import Dict, List, Optional, Union, Iterable, Tuple
from asammdf import MDF, Signal

# ---------------------------- Helpers ---------------------------- #

def _dispatch_canape():
    return win32com.client.Dispatch("CANape.Application")

def _ensure_dir(path: str):
    p = os.path.dirname(os.path.abspath(path))
    if p and not os.path.exists(p):
        os.makedirs(p, exist_ok=True)

def _wait_stable(path: str, timeout=30.0, poll=0.25):
    end = time.time() + timeout
    last = -1
    seen = False
    while time.time() < end:
        if os.path.exists(path):
            sz = os.path.getsize(path)
            if seen and sz == last and sz > 0:
                return True
            last = sz
            seen = True
        time.sleep(poll)
    return os.path.exists(path)

def _to_float(val):
    if isinstance(val, (int, float, np.integer, np.floating)): return float(val)
    if val is None: return np.nan
    if isinstance(val, (bytes, bytearray)):
        try: val = val.decode("utf-8", "ignore")
        except: return np.nan
    s = str(val).strip().replace("\xa0", " ")
    if not s or s.lower() in ("nan","none","null"): return np.nan
    l = s.lower()
    if l in ("true","on","high","yes"): return 1.0
    if l in ("false","off","low","no"): return 0.0
    m = re.search(r"[-+]?\d+(?:[.,]\d+)?(?:[eE][-+]?\d+)?", s)
    if m:
        try: return float(m.group(0).replace(",", "."))
        except: return np.nan
    return np.nan

def _maybe_text_to_numeric(samples, signal: Signal):
    if hasattr(samples, "dtype") and samples.dtype.kind in ("i","u","f","b"):
        return samples
    conv = getattr(signal, "conversion", None)
    mapping = None
    if conv:
        for attr in ("text_2_value","text2value","text_to_value","value_map","val_map","mapping"):
            mapping = getattr(conv, attr, None)
            if mapping: break
        if mapping is None:
            txts = getattr(conv, "texts", None) or getattr(conv, "labels", None)
            vals = getattr(conv, "values", None) or getattr(conv, "ids", None)
            if txts is not None and vals is not None:
                try: mapping = {t:v for t,v in zip(txts, vals)}
                except: mapping = None
    if mapping:
        out = []
        for s in samples:
            if s in mapping:
                out.append(_to_float(mapping[s])); continue
            if isinstance(s, (bytes, bytearray)):
                try: s2 = s.decode(errors="ignore")
                except: s2 = ""
            else: s2 = str(s)
            v = mapping.get(s2)
            out.append(_to_float(v if v is not None else s))
        return np.array(out, dtype=float)
    return np.array([_to_float(s) for s in samples], dtype=float)

def _get_signal(mdf: MDF, name: str, prefer_raw: bool):
    if prefer_raw:
        try: return mdf.get(name, raw=True)
        except: return mdf.get(name)
    else:
        try: return mdf.get(name)
        except: return mdf.get(name, raw=True)

# ---------------------------- Abstractions ---------------------------- #

class CanapeVariable:
    def __init__(self, app, dev_com, device: str, var: str):
        self._app = app
        self._dev = dev_com
        self.device_name = device
        self.varname = var
        self.longname = f"{device}:{var}"

    def _ensure_online(self):
        try:
            if not self._dev.IsOnline:
                self._dev.GoOnline()
        except: pass

    @property
    def value(self):
        self._ensure_online()
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Read()
        return obj.Value

    @value.setter
    def value(self, v):
        self._ensure_online()
        self._dev.CalibrationObjects.Add(self.varname)
        obj = self._dev.CalibrationObjects.Item(self.varname)
        obj.Value = v
        obj.Write()

    def __repr__(self): return f"<CanapeVariable {self.longname}>"

class _TaskSignalRef:
    def __init__(self, device: str, signal: str):
        self.device = device
        self.signal = signal
    @property
    def longname(self): return f"{self.device}:{self.signal}"

class _SignalView:
    def __init__(self, sig: Signal, display: str, force_numeric: bool):
        xs, ys = sig.timestamps, sig.samples
        if force_numeric and hasattr(ys,"dtype") and ys.dtype.kind in ("O","U","S"):
            ys = _maybe_text_to_numeric(ys, sig)
        self._x = np.asarray(xs)
        self._y = np.asarray(ys)
        self._name = display
    @property
    def x(self): return self._x
    @property
    def y(self): return self._y
    @property
    def name(self): return self._name
    @property
    def data(self): return tuple(zip(self._x.astype(float), self._y.astype(float)))
    def __repr__(self): return f"<SignalView {self._name} len={len(self._x)}>"

# ---------------------------- Recorder Result ---------------------------- #

class RecorderResult:
    def __init__(
        self, app, cleanup, vars_, vector, can_, path,
        prefer_raw, prefer_enum_numeric,
        devices_involved, device_objs,
        recorder_obj, recorder_name,
        channel_assignments, exclusive
    ):
        self._app = app
        self._cleanup = cleanup
        self._vars = vars_
        self._vec = vector
        self._can = can_
        self.filepath = os.path.abspath(path)
        self._prefer_raw = prefer_raw
        self._prefer_enum_numeric = prefer_enum_numeric
        self._views_by_name: Dict[str, _SignalView] = {}
        self._order: List[str] = []
        self._mdf: Optional[MDF] = None
        self._devices_involved = devices_involved
        self._device_objs = device_objs
        self._recorder = recorder_obj
        self._rec_name = recorder_name
        self._channel_assignments = channel_assignments   # list of channel COM objects
        self._exclusive = exclusive

    def _enum_upgrade(self, mdf: MDF, sig: Signal, name: str):
        try:
            ys = sig.samples
            if self._prefer_enum_numeric and hasattr(ys,"dtype") and ys.dtype.kind in ("O","U","S"):
                try: return _get_signal(mdf, name, prefer_raw=True)
                except: return sig
        except: pass
        return sig

    def _add_view(self, mdf: MDF, display: str, candidates: List[str]):
        for cname in candidates:
            try:
                sig = _get_signal(mdf, cname, self._prefer_raw)
                sig = self._enum_upgrade(mdf, sig, cname)
                if display not in self._views_by_name:
                    self._views_by_name[display] = _SignalView(sig, display, self._prefer_enum_numeric)
                    self._order.append(display)
                return
            except: continue

    def finalize(self):
        # Stop measurement
        try: self._app.Measurement.Stop()
        except: pass

        # Remove ONLY our recorder assignment from each channel
        for ch in self._channel_assignments:
            try:
                # Preferred: Remove(recorder COM)
                try:
                    ch.AssignedRecorders.Remove(self._recorder)
                except:
                    # fallback by name
                    try:
                        ch.AssignedRecorders.Remove(self._rec_name)
                    except:
                        # as last resort (only if exclusive) clear all
                        if self._exclusive:
                            try: ch.AssignedRecorders.Clear()
                            except: pass
            except: pass

        # Remove channels from tasks
        for tsk, ch_name in self._cleanup:
            try: tsk.Channels.Remove(ch_name)
            except: pass

        # Remove recorder object
        try:
            self._app.Recorders.Remove(self._rec_name)
        except:
            # try by index search
            try:
                cnt = self._app.Recorders.Count
                for i in range(1, cnt+1):
                    try:
                        r = self._app.Recorders.Item(i)
                        if getattr(r, "Name", "") == self._rec_name:
                            self._app.Recorders.Remove(i)
                            break
                    except: pass
            except: pass

        # Wait for file, load MDF
        _wait_stable(self.filepath)
        try:
            self._mdf = MDF(self.filepath)
        except Exception as e:
            raise RuntimeError(f"Failed to open MF4 '{self.filepath}': {e}")

        for v in self._vars:
            self._add_view(self._mdf, v.longname, [v.longname, v.varname])
        for r in self._vec:
            self._add_view(self._mdf, r.longname, [r.longname, r.signal])
        for r in self._can:
            self._add_view(self._mdf, r.longname, [r.longname, r.signal])

        try:
            for ch in self._mdf.get_channel_names():
                if ch not in self._views_by_name:
                    try:
                        sig = _get_signal(self._mdf, ch, self._prefer_raw)
                        sig = self._enum_upgrade(self._mdf, sig, ch)
                        self._views_by_name[ch] = _SignalView(sig, ch, self._prefer_enum_numeric)
                    except: pass
        except: pass

        self._clear_all_involved_tasks()

    def _clear_all_involved_tasks(self):
        for name in self._devices_involved:
            dev = self._device_objs.get(name)
            if not dev: continue
            try:
                if not dev.IsOnline: dev.GoOnline()
                for t in dev.Tasks:
                    try: t.Channels.Clear()
                    except: pass
            except: pass

    def __getitem__(self, key: Union[str, CanapeVariable]):
        if isinstance(key, CanapeVariable):
            key = key.longname
        if key in self._views_by_name:
            return self._views_by_name[key]
        tail = key.split(":",1)[-1]
        matches = [n for n in self._views_by_name if n.endswith(":"+tail) or n.endswith("."+tail) or n==tail]
        if len(matches)==1:
            return self._views_by_name[matches[0]]
        raise KeyError(f"No recorded data for '{key}'")
    @property
    def signals(self): return [n for n in self._order]
    def values(self): return [self._views_by_name[n] for n in self._order if n in self._views_by_name]
    def close(self):
        try:
            if self._mdf: self._mdf.close()
        except: pass

# ---------------------------- Device & Session ---------------------------- #

class CanapeDevice:
    def __init__(self, app, dev_com, name):
        self.app = app
        self.dev = dev_com
        self.name = name

class CanapeAutomation:
    def __init__(self, project_path: Optional[str] = None):
        self.app = _dispatch_canape()
        try:
            self.app.Measurement.FifoSize = 2048
            self.app.Measurement.SampleSize = 1024
        except: pass
        if project_path is None:
            project_path = r"C:\Users\Public\Documents\Vector\CANape Examples 21.0\XCPDemo"
        self.app.Open2(project_path, 1, 100000, 0, 0, 1)
        time.sleep(1.5)
        self.devices: Dict[str, CanapeDevice] = {}
        self._var_cache: Dict[str, CanapeVariable] = {}

    def add_device(self, name: str, definition_path: str, dev_type: str, channel: int):
        dev_com = self.app.Devices.Add(name, definition_path, dev_type, channel)
        dev = CanapeDevice(self.app, dev_com, name)
        self.devices[name] = dev
        return dev

    def go_online_all(self, reconnect: bool=False):
        for d in self.devices.values():
            try: d.dev.GoOnline(reconnect)
            except: pass

    def __getitem__(self, longname: str) -> CanapeVariable:
        if ":" not in longname: raise ValueError('Use "Device:Variable" format.')
        dev, var = longname.split(":",1)
        if dev not in self.devices: raise KeyError(f"Device '{dev}' not added.")
        key = f"{dev}:{var}"
        if key not in self._var_cache:
            self._var_cache[key] = CanapeVariable(self.app, self.devices[dev].dev, dev, var)
        return self._var_cache[key]

    def _normalize_refs(self, items: Optional[Iterable[Union[str, CanapeVariable]]], kind: str) -> List[_TaskSignalRef]:
        out = []
        if not items: return out
        for it in items:
            if it is None: continue
            if isinstance(it, CanapeVariable):
                out.append(_TaskSignalRef(it.device_name, it.varname))
            elif isinstance(it, str):
                if ":" not in it: raise ValueError(f"Invalid {kind} signal '{it}' (expected 'Device:Signal')")
                d,s = it.split(":",1)
                out.append(_TaskSignalRef(d,s))
            else:
                raise TypeError(f"{kind}_signals entries must be str or CanapeVariable")
        return out

    def _ensure_online_and_clear(self, device_names: Iterable[str]):
        for name in device_names:
            dev = self.devices.get(name)
            if not dev: continue
            try:
                if not dev.dev.IsOnline:
                    dev.dev.GoOnline()
                for t in dev.dev.Tasks:
                    try: t.Channels.Clear()
                    except: pass
            except: pass

    @contextmanager
    def recorder(
        self,
        *signals: Union[str, CanapeVariable],
        task: str = "100ms", sampling_time: Optional[int] = 100,
        mdf_path: Optional[str] = None,
        vector_signals: Optional[Iterable[Union[str, CanapeVariable]]] = None,
        vector_task: str = "cyclic", vector_sampling_time: Optional[int] = None,
        can_signals: Optional[Iterable[Union[str, CanapeVariable]]] = None,
        can_task: str = "can", can_sampling_time: Optional[int] = None,
        prefer_raw: bool = False,
        prefer_enum_numeric: bool = True,
        exclusive_recorder: bool = True,
    ):
        """
        exclusive_recorder:
            True  - remove any pre-existing recorder assignments on each channel (AssignedRecorders.Clear)
            False - keep other assignments, only Add / later Remove ours
        """
        # Normalize ECU signals
        ecu_vars: List[CanapeVariable] = []
        for s in signals:
            if s is None: continue
            if isinstance(s, CanapeVariable): ecu_vars.append(s)
            elif isinstance(s, str): ecu_vars.append(self[s])
            else: raise TypeError("signals must be str or CanapeVariable")

        vec_refs = self._normalize_refs(vector_signals, "vector")
        can_refs = self._normalize_refs(can_signals, "can")

        if not (ecu_vars or vec_refs or can_refs):
            raise TypeError("At least one of signals / vector_signals / can_signals required.")

        involved_devices = sorted(set(
            [v.device_name for v in ecu_vars] +
            [r.device for r in vec_refs] +
            [r.device for r in can_refs]
        ))

        # Ensure online & clear tasks BEFORE config
        self._ensure_online_and_clear(involved_devices)

        cleanup: List[Tuple[object,str]] = []
        channel_assignments = []

        # Build recorder + file
        if mdf_path is None:
            mdf_path = os.path.abspath(f"canape_recording_{datetime.now():%Y%m%d_%H%M%S}.mf4")
        _ensure_dir(mdf_path)

        recorder_name = f"pyRec_{datetime.now():%Y%m%d_%H%M%S_%f}"
        try:
            recorder_obj = self.app.Recorders.Add(recorder_name)  # IRecorders::Add
        except:
            recorder_name = f"pyRec_{int(time.time()*1000)}"
            recorder_obj = self.app.Recorders.Add(recorder_name)
        try: recorder_obj.MDFFilename = mdf_path
        except: pass
        try: self.app.Recorders.SelectedRecorder = recorder_obj
        except: pass

        # ECU grouping
        by_dev: Dict[str, List[CanapeVariable]] = {}
        for v in ecu_vars: by_dev.setdefault(v.device_name, []).append(v)

        def _assign(tsk, channel_name: str):
            """Add recorder assignment to channel."""
            try: ch = tsk.Channels(channel_name)
            except: return
            if exclusive_recorder:
                try: ch.AssignedRecorders.Clear()
                except: pass
            # Add our recorder (COM object or name)
            try:
                ch.AssignedRecorders.Add(recorder_obj)
            except:
                try: ch.AssignedRecorders.Add(recorder_name)
                except: pass
            channel_assignments.append(ch)

        for dev_name, vars_ in by_dev.items():
            dev_com = self.devices[dev_name].dev
            tsk = dev_com.Tasks(task)
            if sampling_time is not None:
                try: tsk.SamplingTime = int(sampling_time)
                except: pass
            for v in vars_:
                try: dev_com.CalibrationObjects.Add(v.varname)
                except: pass
                try:
                    tsk.Channels.Add(v.varname)
                    cleanup.append((tsk, v.varname))
                    _assign(tsk, v.varname)
                except: pass

        def _add_refs(refs: List[_TaskSignalRef], group_task: str, group_sampling: Optional[int]):
            if not refs: return
            group: Dict[str, List[_TaskSignalRef]] = {}
            for r in refs: group.setdefault(r.device, []).append(r)
            for dev_name, lst in group.items():
                dev_com = self.devices[dev_name].dev
                tsk = dev_com.Tasks(group_task)
                if group_sampling is not None:
                    try: tsk.SamplingTime = int(group_sampling)
                    except: pass
                for r in lst:
                    try:
                        tsk.Channels.Add(r.signal)
                        cleanup.append((tsk, r.signal))
                        _assign(tsk, r.signal)
                    except: pass

        _add_refs(vec_refs, vector_task, vector_sampling_time)
        _add_refs(can_refs, can_task, can_sampling_time)

        # Ensure devices online before start
        for d in involved_devices:
            try:
                dev = self.devices[d].dev
                if not dev.IsOnline: dev.GoOnline()
            except: pass

        try: self.app.Measurement.Start()
        except: pass

        rec = RecorderResult(
            self.app, cleanup, ecu_vars, vec_refs, can_refs,
            mdf_path, prefer_raw, prefer_enum_numeric,
            involved_devices, {n: self.devices[n].dev for n in involved_devices},
            recorder_obj, recorder_name, channel_assignments,
            exclusive_recorder
        )
        try:
            yield rec
        finally:
            rec.finalize()

    def close(self):
        try:
            for d in self.devices.values():
                try: d.dev.GoOffline()
                except: pass
        finally:
            try: self.app.Quit()
            except: pass

# ---------------------------- Example (commented) ---------------------------- #
# if __name__ == "__main__":
#     sess = CanapeAutomation(r"C:\path\to\Project")
#     ecu = sess.add_device("ECU", r"C:\my.ecu.a2l", "XCP", 1)
#     can = sess.add_device("CAN1", r"C:\bus.dbc", "CAN", 1)
#     sess.go_online_all()
#     with sess.recorder(
#         "ECU:EngSpd", "ECU:PedalPos",
#         can_signals=["CAN1:Msg1.Signal1"],
#         task="10ms", sampling_time=10,
#         mdf_path=r"C:\logs\run1.mf4",
#         prefer_enum_numeric=True,
#         exclusive_recorder=True
#     ) as rec:
#         time.sleep(5)
#     print(rec["ECU:EngSpd"].y[:5])
