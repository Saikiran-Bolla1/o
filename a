#!/usr/bin/env python3
# pip install pyelftools

from elftools.elf.elffile import ELFFile
import sys

MAX_ARRAY_SIZE = 32


def get_object_symbols(elffile):
    """Return dict[name] = {'addr': int, 'size': int} for STT_OBJECT from .symtab/.dynsym only."""
    out = {}
    for secname in ('.symtab', '.dynsym'):
        sec = elffile.get_section_by_name(secname)
        if not sec or not hasattr(sec, 'iter_symbols'):
            continue
        for sym in sec.iter_symbols():
            name = sym.name
            if not name:
                continue
            st_info = sym['st_info']
            if st_info['type'] != 'STT_OBJECT':
                continue  # variables only
            addr = int(sym['st_value'] or 0)
            size = int(sym['st_size'] or 0)
            # Skip undefined / no address
            if addr == 0:
                continue
            out[name] = {'addr': addr, 'size': size}
    return out


def resolve_base_type(dwarfinfo, die):
    """Walk typedef/const/volatile/restrict/pointer to reach a base_type.
    Returns (typename, byte_size) or ('unknown', None)
    """
    visited = set()
    while die and die.offset not in visited:
        visited.add(die.offset)
        tag = die.tag
        if tag == 'DW_TAG_base_type':
            name_attr = die.attributes.get('DW_AT_name')
            bs_attr = die.attributes.get('DW_AT_byte_size')
            tname = (name_attr.value.decode('utf-8', 'ignore') if name_attr else 'unknown')
            bsize = (bs_attr.value if bs_attr else None)
            return tname, bsize
        if 'DW_AT_type' in die.attributes:
            die = die.get_DIE_from_attribute('DW_AT_type')
        else:
            break
    return 'unknown', None


def array_first_dim_len(array_die):
    """Get first dimension length from DW_TAG_array_type (count or upper_bound+1)."""
    for child in array_die.iter_children():
        if child.tag == 'DW_TAG_subrange_type':
            cnt = child.attributes.get('DW_AT_count')
            if cnt:
                return int(cnt.value)
            ub = child.attributes.get('DW_AT_upper_bound')
            if ub:
                return int(ub.value) + 1
            # Some toolchains use DW_AT_lower_bound + DW_AT_upper_bound; lower is often 0/1.
            lb = child.attributes.get('DW_AT_lower_bound')
            if lb and ub:
                return int(ub.value) - int(lb.value) + 1
            # If none present, unknown
            return None
    return None


def iter_dwarf_variables(dwarfinfo):
    """Yield (var_name, var_die) for DWARF variables that have a name and type."""
    for cu in dwarfinfo.iter_CUs():
        for die in cu.iter_DIEs():
            if die.tag != 'DW_TAG_variable':
                continue
            name_attr = die.attributes.get('DW_AT_name')
            if not name_attr:
                continue
            if 'DW_AT_type' not in die.attributes:
                continue
            yield name_attr.value.decode('utf-8', 'ignore'), die


def main(path):
    with open(path, 'rb') as f:
        elf = ELFFile(f)

        # Build variable symbol map from .symtab + .dynsym only
        symmap = get_object_symbols(elf)

        if not elf.has_dwarf_info():
            print('No DWARF info in ELF; cannot resolve types/arrays.')
            # Still list raw variable symbols
            for name, meta in symmap.items():
                print(f"{name}  type=unknown addr=0x{meta['addr']:x} size={meta['size']}")
            return

        dwarfinfo = elf.get_dwarf_info()

        # Map DWARF variable DIE by name for quick lookup
        dwarf_vars = {name: die for name, die in iter_dwarf_variables(dwarfinfo)}

        # Walk only symbols that exist as variables in .symtab/.dynsym
        for root_name, meta in sorted(symmap.items()):
            die = dwarf_vars.get(root_name)
            addr = meta['addr']
            # If we cannot find DWARF DIE for this symbol, print basic info
            if not die:
                print(f"{root_name}  type=unknown addr=0x{addr:x} size={meta['size']}")
                continue

            type_die = die.get_DIE_from_attribute('DW_AT_type')
            if not type_die:
                print(f"{root_name}  type=unknown addr=0x{addr:x} size={meta['size']}")
                continue

            if type_die.tag == 'DW_TAG_array_type':
                # Resolve element type
                elem_die = type_die.get_DIE_from_attribute('DW_AT_type')
                elem_type, elem_size = resolve_base_type(dwarfinfo, elem_die)
                if not elem_size:
                    elem_size = 1  # fallback so addresses still compute

                n = array_first_dim_len(type_die)
                n = n if n is not None else 0
                n_print = min(n, MAX_ARRAY_SIZE)

                # Expanded elements
                for i in range(n_print):
                    eaddr = addr + i * elem_size
                    print(f"{root_name}._{i}_  type={elem_type} addr=0x{eaddr:x} size={elem_size}")
                    # A2L link helper line
                    print(f"LINK {root_name} -> {root_name}._{i}_ @ 0x{eaddr:x}")

                # Root summary line (like tools show the array node)
                print(f"{root_name}  type=array[{n}] of {elem_type} base_addr=0x{addr:x} elem_size={elem_size}")

            else:
                base_type, bsize = resolve_base_type(dwarfinfo, type_die)
                print(f"{root_name}  type={base_type} addr=0x{addr:x} size={bsize if bsize else meta['size']}")


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <elf-file>")
        sys.exit(1)
    main(sys.argv[1])
