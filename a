from elftools.elf.elffile import ELFFile
import sys

MAX_ARRAY_SIZE = 32


def resolve_type(dwarfinfo, die):
    """Resolve down to the base type, return name, size, min/max if available."""
    while die:
        if die.tag == "DW_TAG_base_type":
            name = die.attributes["DW_AT_name"].value.decode("utf-8", errors="ignore")
            byte_size = die.attributes.get("DW_AT_byte_size", None)
            min_val = die.attributes.get("DW_AT_lower_bound", None)
            max_val = die.attributes.get("DW_AT_upper_bound", None)
            return {
                "type": name,
                "size": byte_size.value if byte_size else None,
                "min": min_val.value if min_val else None,
                "max": max_val.value if max_val else None,
            }
        elif "DW_AT_type" in die.attributes:
            die = dwarfinfo.get_DIE_from_refaddr(die.attributes["DW_AT_type"].value)
        else:
            break
    return {"type": "unknown", "size": None, "min": None, "max": None}


def get_array_bounds(array_die):
    """Extract array dimension sizes."""
    bounds = []
    for child in array_die.iter_children():
        if child.tag == "DW_TAG_subrange_type":
            count_attr = child.attributes.get("DW_AT_count")
            upper_attr = child.attributes.get("DW_AT_upper_bound")
            if count_attr:
                count = count_attr.value
            elif upper_attr:
                count = upper_attr.value + 1
            else:
                count = None
            if count:
                bounds.append(count)
    return bounds


def parse_variables(dwarfinfo, elffile):
    """Find global variables and print info."""
    for CU in dwarfinfo.iter_CUs():
        for DIE in CU.iter_DIEs():
            if DIE.tag == "DW_TAG_variable":
                name_attr = DIE.attributes.get("DW_AT_name")
                type_attr = DIE.attributes.get("DW_AT_type")
                loc_attr = DIE.attributes.get("DW_AT_location")

                if not name_attr or not type_attr:
                    continue

                var_name = name_attr.value.decode("utf-8", errors="ignore")
                type_die = dwarfinfo.get_DIE_from_refaddr(type_attr.value)

                # Resolve address if available
                address = None
                if loc_attr and loc_attr.form in ("DW_FORM_addr",):
                    address = loc_attr.value

                if type_die.tag == "DW_TAG_array_type":
                    element_type = resolve_type(dwarfinfo, dwarfinfo.get_DIE_from_refaddr(type_die.attributes["DW_AT_type"].value))
                    bounds = get_array_bounds(type_die)

                    if bounds:
                        dim_size = min(bounds[0], MAX_ARRAY_SIZE)
                        for i in range(dim_size):
                            print(f"{var_name}_{i}.{element_type['type']} "
                                  f"addr={hex(address) if address else 'N/A'} "
                                  f"size={element_type['size']} "
                                  f"min={element_type['min']} max={element_type['max']}")
                else:
                    element_type = resolve_type(dwarfinfo, type_die)
                    print(f"{var_name}.{element_type['type']} "
                          f"addr={hex(address) if address else 'N/A'} "
                          f"size={element_type['size']} "
                          f"min={element_type['min']} max={element_type['max']}")


def read_elf(filename):
    with open(filename, "rb") as f:
        elffile = ELFFile(f)

        if not elffile.has_dwarf_info():
            print("No DWARF info in ELF")
            return

        dwarfinfo = elffile.get_dwarf_info()
        parse_variables(dwarfinfo, elffile)


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <elf-file>")
        sys.exit(1)

    read_elf(sys.argv[1])
