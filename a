from elftools.elf.elffile import ELFFile
import sys

MAX_ARRAY_SIZE = 32

def resolve_type(dwarfinfo, die):
    """Resolve down to the base type, return name and size if available."""
    while die:
        if die.tag == "DW_TAG_base_type":
            name = die.attributes.get("DW_AT_name", None)
            name = name.value.decode("utf-8", errors="ignore") if name else "unknown"
            byte_size = die.attributes.get("DW_AT_byte_size", None)
            return name, byte_size.value if byte_size else None
        elif "DW_AT_type" in die.attributes:
            die_ref = die.attributes["DW_AT_type"].value
            die = dwarfinfo.get_DIE_from_refaddr(die_ref)
        else:
            break
    return "unknown", None

def get_array_bounds(array_die):
    """Extract array dimension sizes."""
    bounds = []
    for child in array_die.iter_children():
        if child.tag == "DW_TAG_subrange_type":
            count_attr = child.attributes.get("DW_AT_count")
            upper_attr = child.attributes.get("DW_AT_upper_bound")
            if count_attr:
                count = count_attr.value
            elif upper_attr:
                count = upper_attr.value + 1
            else:
                count = None
            if count:
                bounds.append(count)
    return bounds

def build_symbol_map(elffile):
    """
    Build map of symbol name -> address from both .symtab and .dynsym sections.
    Later symbols with the same name override earlier ones.
    """
    symmap = {}
    for section in elffile.iter_sections():
        sh_type = section.header['sh_type']
        if sh_type in ('SHT_SYMTAB', 'SHT_DYNSYM'):
            for symbol in section.iter_symbols():
                if symbol.name:
                    addr = symbol.entry.get("st_value", None)
                    symmap[symbol.name] = addr
    return symmap

def parse_variables(dwarfinfo, elffile):
    symmap = build_symbol_map(elffile)

    for CU in dwarfinfo.iter_CUs():
        for DIE in CU.iter_DIEs():
            if DIE.tag == "DW_TAG_variable":
                name_attr = DIE.attributes.get("DW_AT_name")
                type_attr = DIE.attributes.get("DW_AT_type")

                if not name_attr or not type_attr:
                    continue

                var_name = name_attr.value.decode("utf-8", errors="ignore")
                type_ref = type_attr.value
                type_die = dwarfinfo.get_DIE_from_refaddr(type_ref)

                base_type, size = resolve_type(dwarfinfo, type_die)

                # Address from symbol table if possible
                address = symmap.get(var_name, None)

                # If array â†’ expand with ._0_, ._1_ ...
                if type_die.tag == "DW_TAG_array_type":
                    # Safely get element type DIE
                    elem_type_die = None
                    if "DW_AT_type" in type_die.attributes:
                        elem_type_ref = type_die.attributes["DW_AT_type"].value
                        elem_type_die = dwarfinfo.get_DIE_from_refaddr(elem_type_ref)
                    if elem_type_die:
                        element_type, elem_size = resolve_type(dwarfinfo, elem_type_die)
                    else:
                        element_type, elem_size = "unknown", None

                    bounds = get_array_bounds(type_die)
                    if bounds:
                        dim_size = min(bounds[0], MAX_ARRAY_SIZE)
                        for i in range(dim_size):
                            addr_val = address + i * (elem_size or 1) if address is not None and elem_size else None
                            addr_str = hex(addr_val) if addr_val is not None else 'N/A'
                            print(
                                f"{var_name}._{i}_  "
                                f"type={element_type} "
                                f"addr={addr_str} "
                                f"size={elem_size}"
                            )
                        print(f"{var_name}  type=array[{bounds[0]}] of {element_type}")
                    else:
                        print(f"{var_name}  type=array[?] of {element_type}")
                else:
                    addr_str = hex(address) if address is not None else 'N/A'
                    print(
                        f"{var_name}  "
                        f"type={base_type} "
                        f"addr={addr_str} "
                        f"size={size}"
                    )

def read_elf(filename):
    with open(filename, "rb") as f:
        elffile = ELFFile(f)

        if not elffile.has_dwarf_info():
            print("No DWARF info in ELF")
            return

        dwarfinfo = elffile.get_dwarf_info()
        parse_variables(dwarfinfo, elffile)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <elf-file>")
        sys.exit(1)

    read_elf(sys.argv[1])
