from elftools.elf.elffile import ELFFile
import sys

MAX_ARRAY_SIZE = 32


def resolve_type(dwarfinfo, die):
    """Resolve down to the base type, return name and size if available."""
    while die:
        if die.tag == "DW_TAG_base_type":
            name = die.attributes["DW_AT_name"].value.decode("utf-8", errors="ignore")
            byte_size = die.attributes.get("DW_AT_byte_size", None)
            return name, byte_size.value if byte_size else None
        elif "DW_AT_type" in die.attributes:
            die = dwarfinfo.get_DIE_from_refaddr(die.attributes["DW_AT_type"].value)
        else:
            break
    return "unknown", None


def get_array_bounds(array_die):
    """Extract array dimension sizes."""
    bounds = []
    for child in array_die.iter_children():
        if child.tag == "DW_TAG_subrange_type":
            count_attr = child.attributes.get("DW_AT_count")
            upper_attr = child.attributes.get("DW_AT_upper_bound")
            if count_attr:
                count = count_attr.value
            elif upper_attr:
                count = upper_attr.value + 1
            else:
                count = None
            if count:
                bounds.append(count)
    return bounds


def build_symbol_map(elffile):
    """Build map of symbol name -> address from ELF symbol table."""
    symmap = {}
    for section in elffile.iter_sections():
        if not hasattr(section, "iter_symbols"):
            continue
        for symbol in section.iter_symbols():
            if symbol.name:
                symmap[symbol.name] = symbol["st_value"]
    return symmap


def parse_variables(dwarfinfo, elffile):
    symmap = build_symbol_map(elffile)

    for CU in dwarfinfo.iter_CUs():
        for DIE in CU.iter_DIEs():
            if DIE.tag == "DW_TAG_variable":
                name_attr = DIE.attributes.get("DW_AT_name")
                type_attr = DIE.attributes.get("DW_AT_type")

                if not name_attr or not type_attr:
                    continue

                var_name = name_attr.value.decode("utf-8", errors="ignore")
                type_die = dwarfinfo.get_DIE_from_refaddr(type_attr.value)

                base_type, size = resolve_type(dwarfinfo, type_die)

                # Address from symbol table if possible
                address = symmap.get(var_name, None)

                # If array â†’ expand with ._0_, ._1_ ...
                if type_die.tag == "DW_TAG_array_type":
                    element_type, elem_size = resolve_type(
                        dwarfinfo,
                        dwarfinfo.get_DIE_from_refaddr(type_die.attributes["DW_AT_type"].value),
                    )
                    bounds = get_array_bounds(type_die)
                    if bounds:
                        dim_size = min(bounds[0], MAX_ARRAY_SIZE)
                        for i in range(dim_size):
                            print(
                                f"{var_name}._{i}_  "
                                f"type={element_type} "
                                f"addr={hex(address + i * (elem_size or 1)) if address else 'N/A'} "
                                f"size={elem_size}"
                            )
                    # also print the root symbol (summary)
                    print(f"{var_name}  type=array[{bounds[0]}] of {element_type}")
                else:
                    print(
                        f"{var_name}  "
                        f"type={base_type} "
                        f"addr={hex(address) if address else 'N/A'} "
                        f"size={size}"
                    )


def read_elf(filename):
    with open(filename, "rb") as f:
        elffile = ELFFile(f)

        if not elffile.has_dwarf_info():
            print("No DWARF info in ELF")
            return

        dwarfinfo = elffile.get_dwarf_info()
        parse_variables(dwarfinfo, elffile)


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <elf-file>")
        sys.exit(1)

    read_elf(sys.argv[1])
