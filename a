#!/usr/bin/env python3
# pip install pyelftools

from elftools.elf.elffile import ELFFile
import sys

MAX_ARRAY_ELEMS = 32

# DWARF encodings (values are standard; pyelftools exposes raw ints)
DW_ATE_ADDRESS        = 0x01
DW_ATE_BOOLEAN        = 0x02
DW_ATE_COMPLEX_FLOAT  = 0x03
DW_ATE_FLOAT          = 0x04
DW_ATE_SIGNED         = 0x05
DW_ATE_SIGNED_CHAR    = 0x06
DW_ATE_UNSIGNED       = 0x07
DW_ATE_UNSIGNED_CHAR  = 0x08

def get_object_symbols(elffile):
    """Return {name: {'addr': int, 'size': int}} for STT_OBJECT from .symtab and .dynsym only."""
    out = {}
    for secname in ('.symtab', '.dynsym'):
        sec = elffile.get_section_by_name(secname)
        if not sec or not hasattr(sec, 'iter_symbols'):
            continue
        for sym in sec.iter_symbols():
            if sym['st_info']['type'] != 'STT_OBJECT':
                continue  # variables only
            name = sym.name
            if not name:
                continue
            addr = int(sym['st_value'] or 0)
            size = int(sym['st_size'] or 0)
            if addr == 0:  # skip undefined/absolute
                continue
            out[name] = {'addr': addr, 'size': size}
    return out

def iter_dwarf_variables(dwarfinfo):
    """Yield (name, die) for DWARF variables that have a name and type."""
    for cu in dwarfinfo.iter_CUs():
        for die in cu.iter_DIEs():
            if die.tag != 'DW_TAG_variable':
                continue
            n = die.attributes.get('DW_AT_name')
            if not n:
                continue
            if 'DW_AT_type' not in die.attributes:
                continue
            yield n.value.decode('utf-8', 'ignore'), die

def resolve_base_type(dwarfinfo, die):
    """
    Walk typedef/const/volatile/restrict/pointer until DW_TAG_base_type.
    Return (typename, byte_size, encoding) or ('unknown', None, None).
    """
    seen = set()
    cur = die
    while cur and cur.offset not in seen:
        seen.add(cur.offset)
        if cur.tag == 'DW_TAG_base_type':
            tname = cur.attributes.get('DW_AT_name')
            bsize = cur.attributes.get('DW_AT_byte_size')
            enc   = cur.attributes.get('DW_AT_encoding')
            return (
                tname.value.decode('utf-8', 'ignore') if tname else 'unknown',
                int(bsize.value) if bsize else None,
                int(enc.value) if enc else None
            )
        # Stop at pointer type: treat pointer size as scalar value width, not array element
        if cur.tag == 'DW_TAG_pointer_type':
            bsize = cur.attributes.get('DW_AT_byte_size')
            return ('pointer', int(bsize.value) if bsize else None, None)
        nxt = cur.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in cur.attributes else None
        cur = nxt
    return ('unknown', None, None)

def array_first_dim_len(array_die):
    """Get first dimension length from DW_TAG_array_type (count or upper_bound+1)."""
    for child in array_die.iter_children():
        if child.tag != 'DW_TAG_subrange_type':
            continue
        cnt = child.attributes.get('DW_AT_count')
        if cnt:
            return int(cnt.value)
        ub  = child.attributes.get('DW_AT_upper_bound')
        lb  = child.attributes.get('DW_AT_lower_bound')
        if ub and lb:
            return int(ub.value) - int(lb.value) + 1
        if ub:
            return int(ub.value) + 1
    return None

def type_min_max(encoding, byte_size):
    """Infer min/max from DWARF base type encoding & size (integers & booleans)."""
    if byte_size is None:
        return (None, None)
    bits = 8 * byte_size
    if encoding in (DW_ATE_UNSIGNED, DW_ATE_UNSIGNED_CHAR):
        return (0, (1 << bits) - 1)
    if encoding in (DW_ATE_SIGNED, DW_ATE_SIGNED_CHAR):
        return (-(1 << (bits - 1)), (1 << (bits - 1)) - 1)
    if encoding == DW_ATE_BOOLEAN:
        return (0, 1)
    # Floats / others: leave unknown (DWARF doesn't encode IEEE ranges)
    return (None, None)

def main(path):
    with open(path, 'rb') as f:
        elf = ELFFile(f)

        # 1) Symbols from .symtab + .dynsym (variables only)
        symmap = get_object_symbols(elf)

        # If no DWARF, print basic info and exit
        if not elf.has_dwarf_info():
            for name, meta in sorted(symmap.items(), key=lambda kv: kv[1]['addr']):
                print(f"{name}  type=unknown addr=0x{meta['addr']:x} size={meta['size']}")
            return

        dwarfinfo = elf.get_dwarf_info()
        dwarf_vars = {name: die for name, die in iter_dwarf_variables(dwarfinfo)}

        # 2) Walk only symbols we actually have (keeps to .symtab/.dynsym as requested)
        for name, meta in sorted(symmap.items(), key=lambda kv: kv[1]['addr']):
            addr = meta['addr']
            die  = dwarf_vars.get(name)
            if not die:
                # No DWARF entry → print what we have
                print(f"{name}  type=unknown addr=0x{addr:x} size={meta['size']}")
                continue

            tdie = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
            if not tdie:
                print(f"{name}  type=unknown addr=0x{addr:x} size={meta['size']}")
                continue

            if tdie.tag == 'DW_TAG_array_type':
                # True array → expand using real element type & byte size
                elem_die = tdie.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in tdie.attributes else None
                elem_type, elem_size, elem_enc = resolve_base_type(dwarfinfo, elem_die)
                if elem_size is None or elem_size == 0:
                    elem_size = 1  # conservative fallback so addresses still compute
                n = array_first_dim_len(tdie) or 0
                n_print = min(n, MAX_ARRAY_ELEMS)

                # Expanded children
                for i in range(n_print):
                    eaddr = addr + i * elem_size
                    vmin, vmax = type_min_max(elem_enc, elem_size)
                    print(f"{name}._{i}_  type={elem_type} addr=0x{eaddr:x} size={elem_size} min={vmin} max={vmax}")

                # Root summary (like tool trees do)
                print(f"{name}  type=array[{n}] of {elem_type} base_addr=0x{addr:x} elem_size={elem_size}")

            else:
                # Scalar (or struct/pointer/etc.)
                base_type, bsize, enc = resolve_base_type(dwarfinfo, tdie)
                vmin, vmax = type_min_max(enc, bsize)
                print(f"{name}  type={base_type} addr=0x{addr:x} size={bsize if bsize else meta['size']} min={vmin} max={vmax}")

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <elf-file>")
        sys.exit(1)
    main(sys.argv[1])
