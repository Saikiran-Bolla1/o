#!/usr/bin/env python3
# pip install pyelftools

from elftools.elf.elffile import ELFFile
import sys

MAX_ARRAY_ELEMS = 32

# DWARF encodings
DW_ATE_ADDRESS        = 0x01
DW_ATE_BOOLEAN        = 0x02
DW_ATE_COMPLEX_FLOAT  = 0x03
DW_ATE_FLOAT          = 0x04
DW_ATE_SIGNED         = 0x05
DW_ATE_SIGNED_CHAR    = 0x06
DW_ATE_UNSIGNED       = 0x07
DW_ATE_UNSIGNED_CHAR  = 0x08


def get_object_symbols(elffile):
    """Return {name: {'addr': int, 'size': int}} for STT_OBJECT from .symtab and .dynsym only."""
    out = {}
    for secname in ('.symtab', '.dynsym'):
        sec = elffile.get_section_by_name(secname)
        if not sec or not hasattr(sec, 'iter_symbols'):
            continue
        for sym in sec.iter_symbols():
            if sym['st_info']['type'] != 'STT_OBJECT':
                continue
            name = sym.name
            if not name:
                continue
            addr = int(sym['st_value'] or 0)
            size = int(sym['st_size'] or 0)
            if addr == 0:  # skip undefined
                continue
            out[name] = {'addr': addr, 'size': size}
    return out


def iter_dwarf_variables(dwarfinfo):
    """Yield (name, die) for DWARF variables that have a name and type."""
    for cu in dwarfinfo.iter_CUs():
        for die in cu.iter_DIEs():
            if die.tag != 'DW_TAG_variable':
                continue
            n = die.attributes.get('DW_AT_name')
            if not n:
                continue
            if 'DW_AT_type' not in die.attributes:
                continue
            yield n.value.decode('utf-8', 'ignore'), die


def resolve_base_type(dwarfinfo, die):
    """Walk typedef/const/volatile/restrict/pointer until DW_TAG_base_type."""
    seen = set()
    cur = die
    while cur and cur.offset not in seen:
        seen.add(cur.offset)
        if cur.tag == 'DW_TAG_base_type':
            tname = cur.attributes.get('DW_AT_name')
            bsize = cur.attributes.get('DW_AT_byte_size')
            enc   = cur.attributes.get('DW_AT_encoding')
            return (
                tname.value.decode('utf-8', 'ignore') if tname else 'unknown',
                int(bsize.value) if bsize else None,
                int(enc.value) if enc else None
            )
        if cur.tag == 'DW_TAG_pointer_type':
            bsize = cur.attributes.get('DW_AT_byte_size')
            return ('pointer', int(bsize.value) if bsize else None, None)
        nxt = cur.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in cur.attributes else None
        cur = nxt
    return ('unknown', None, None)


def array_first_dim_len(array_die):
    """Get first dimension length from DW_TAG_array_type."""
    for child in array_die.iter_children():
        if child.tag != 'DW_TAG_subrange_type':
            continue
        cnt = child.attributes.get('DW_AT_count')
        if cnt:
            return int(cnt.value)
        ub = child.attributes.get('DW_AT_upper_bound')
        lb = child.attributes.get('DW_AT_lower_bound')
        if ub and lb:
            return int(ub.value) - int(lb.value) + 1
        if ub:
            return int(ub.value) + 1
    return None


def type_min_max(encoding, byte_size):
    """Infer min/max from encoding & size."""
    if byte_size is None:
        return (None, None)
    bits = 8 * byte_size
    if encoding in (DW_ATE_UNSIGNED, DW_ATE_UNSIGNED_CHAR):
        return (0, (1 << bits) - 1)
    if encoding in (DW_ATE_SIGNED, DW_ATE_SIGNED_CHAR):
        return (-(1 << (bits - 1)), (1 << (bits - 1)) - 1)
    if encoding == DW_ATE_BOOLEAN:
        return (0, 1)
    return (None, None)


def main(path):
    with open(path, 'rb') as f:
        elf = ELFFile(f)

        symmap = get_object_symbols(elf)

        if not elf.has_dwarf_info():
            for name, meta in sorted(symmap.items(), key=lambda kv: kv[1]['addr']):
                print(f"{name}  type=unknown addr=0x{meta['addr']:x} size={meta['size']}")
            return

        dwarfinfo = elf.get_dwarf_info()
        dwarf_vars = {name: die for name, die in iter_dwarf_variables(dwarfinfo)}

        sorted_syms = sorted(symmap.items(), key=lambda kv: kv[1]['addr'])

        for idx, (name, meta) in enumerate(sorted_syms):
            addr = meta['addr']
            size = meta['size']
            die  = dwarf_vars.get(name)

            tdie = die.get_DIE_from_attribute('DW_AT_type') if die and 'DW_AT_type' in die.attributes else None

            # --- Case A: DWARF explicit array ---
            if tdie and tdie.tag == 'DW_TAG_array_type':
                elem_die = tdie.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in tdie.attributes else None
                elem_type, elem_size, elem_enc = resolve_base_type(dwarfinfo, elem_die)
                if not elem_size:
                    elem_size = 1
                n = array_first_dim_len(tdie) or 0
                n_print = min(n, MAX_ARRAY_ELEMS)
                for i in range(n_print):
                    eaddr = addr + i * elem_size
                    vmin, vmax = type_min_max(elem_enc, elem_size)
                    print(f"{name}._{i}_  type={elem_type} addr=0x{eaddr:x} size={elem_size} min={vmin} max={vmax}")
                print(f"{name}  type=array[{n}] of {elem_type} base_addr=0x{addr:x} elem_size={elem_size}")
                continue

            # --- Case B: Heuristic array (from size or address gap) ---
            next_addr = sorted_syms[idx+1][1]['addr'] if idx+1 < len(sorted_syms) else None
            elem_size = size if size in (1,2,4,8) else 1

            if size > elem_size and size % elem_size == 0:
                count = min(size // elem_size, MAX_ARRAY_ELEMS)
                for i in range(count):
                    eaddr = addr + i * elem_size
                    print(f"{name}._{i}_  type=unknown addr=0x{eaddr:x} size={elem_size}")
                print(f"{name}  type=array[{count}] of unknown base_addr=0x{addr:x} elem_size={elem_size}")
                continue

            if next_addr and next_addr > addr and (next_addr - addr) > elem_size*2:
                gap = next_addr - addr
                count = min(gap // elem_size, MAX_ARRAY_ELEMS)
                for i in range(count):
                    eaddr = addr + i * elem_size
                    print(f"{name}._{i}_  type=unknown addr=0x{eaddr:x} size={elem_size}")
                print(f"{name}  type=array[{count}] of unknown base_addr=0x{addr:x} elem_size={elem_size}")
                continue

            # --- Case C: Scalar ---
            if tdie:
                base_type, bsize, enc = resolve_base_type(dwarfinfo, tdie)
                vmin, vmax = type_min_max(enc, bsize)
                print(f"{name}  type={base_type} addr=0x{addr:x} size={bsize if bsize else size} min={vmin} max={vmax}")
            else:
                print(f"{name}  type=unknown addr=0x{addr:x} size={size}")


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <elf-file>")
        sys.exit(1)
    main(sys.argv[1])
