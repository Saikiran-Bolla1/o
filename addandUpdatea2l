#!/usr/bin/env python3
"""
Update and extend A2L files using symbol addresses from an ELF (with DWARF).

Fix: Correctly resolves struct member offsets using DW_AT_data_member_location
with DWARF exprloc (DW_OP_plus_uconst, DW_OP_constu, etc.), so recursive
members get proper addresses.

Requires: pip install pyelftools
"""

import sys
import re
import ast
from typing import List, Dict, Optional, Tuple, Set, Union

from elftools.elf.elffile import ELFFile
from elftools.dwarf.descriptions import describe_form_class
from elftools.dwarf.dwarf_expr import DWARFExprParser

MAX_ARRAY = 32
DW_ATE_ADDRESS        = 0x01
DW_ATE_BOOLEAN        = 0x02
DW_ATE_COMPLEX_FLOAT  = 0x03
DW_ATE_FLOAT          = 0x04
DW_ATE_SIGNED         = 0x05
DW_ATE_SIGNED_CHAR    = 0x06
DW_ATE_UNSIGNED       = 0x07
DW_ATE_UNSIGNED_CHAR  = 0x08

def get_symbols(elffile):
    out = {}
    for secname in ('.symtab', '.dynsym'):
        sec = elffile.get_section_by_name(secname)
        if not sec or not hasattr(sec, "iter_symbols"):
            continue
        for s in sec.iter_symbols():
            name = s.name
            if not name:
                continue
            addr = int(s['st_value'] or 0)
            size = int(s['st_size'] or 0)
            st_type = s['st_info']['type']
            kind = st_type.lower() if isinstance(st_type, str) else str(st_type).lower()
            out[name] = {'addr': addr, 'size': size, 'kind': kind}
    return out

def resolve_typedefs(die):
    if die is None:
        return None
    seen = set()
    cur = die
    while cur and cur.offset not in seen:
        seen.add(cur.offset)
        if cur.tag in ('DW_TAG_base_type', 'DW_TAG_pointer_type',
                       'DW_TAG_array_type', 'DW_TAG_structure_type', 'DW_TAG_union_type',
                       'DW_TAG_enumeration_type'):
            return cur
        if 'DW_AT_type' in cur.attributes:
            cur = cur.get_DIE_from_attribute('DW_AT_type')
        else:
            break
    return cur

def base_type_info(base_die):
    if base_die is None:
        return ('unknown', None, None)
    if base_die.tag == 'DW_TAG_pointer_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('pointer', int(bs.value) if bs else None, None)
    if base_die.tag == 'DW_TAG_base_type':
        nm = base_die.attributes.get('DW_AT_name')
        bs = base_die.attributes.get('DW_AT_byte_size')
        enc = base_die.attributes.get('DW_AT_encoding')
        return (nm.value.decode('utf-8', 'ignore') if nm else 'unknown',
                int(bs.value) if bs else None,
                int(enc.value) if enc else None)
    if base_die.tag == 'DW_TAG_enumeration_type':
        bs = base_die.attributes.get('DW_AT_byte_size')
        return ('enum', int(bs.value) if bs else None, DW_ATE_SIGNED)
    bs = base_die.attributes.get('DW_AT_byte_size')
    return ('unknown', int(bs.value) if bs else None, None)

def array_len_first_dim(array_die) -> Optional[int]:
    for child in array_die.iter_children():
        if child.tag != 'DW_TAG_subrange_type':
            continue
        cnt = child.attributes.get('DW_AT_count')
        if cnt:
            return int(cnt.value)
        ub = child.attributes.get('DW_AT_upper_bound')
        lb = child.attributes.get('DW_AT_lower_bound')
        if ub and lb:
            return int(ub.value) - int(lb.value) + 1
        if ub:
            return int(ub.value) + 1
    return None

def dwarf_type_to_str(tname, tenc, tsize):
    if tenc == DW_ATE_UNSIGNED and tsize == 4: return "uint32"
    if tenc == DW_ATE_UNSIGNED and tsize == 2: return "ushort"
    if tenc == DW_ATE_UNSIGNED and tsize == 1: return "ubyte"
    if tenc == DW_ATE_SIGNED and tsize == 4: return "int32"
    if tenc == DW_ATE_SIGNED and tsize == 2: return "short"
    if tenc == DW_ATE_SIGNED and tsize == 1: return "byte"
    if tenc == DW_ATE_BOOLEAN: return "bool"
    return tname

def should_emit(name, filter_list, filter_hits):
    if not filter_list:
        return True
    matched = False
    for f in filter_list:
        if name == f or name.startswith(f + ".") or name.startswith(f + "._"):
            matched = True
            if filter_hits is not None and f in filter_hits:
                filter_hits[f] += 1
    return matched

def should_traverse(name, filter_list):
    if not filter_list:
        return True
    for f in filter_list:
        if name == f or name.startswith(f + ".") or name.startswith(f + "._"):
            return True
        if f.startswith(name + ".") or f.startswith(name + "._"):
            return True
    return False

def _decode_lit(op_name: str) -> Optional[int]:
    if not op_name.startswith('DW_OP_lit'):
        return None
    try:
        return int(op_name[len('DW_OP_lit'):])
    except Exception:
        return None

def _data_member_offset(member_die) -> int:
    loc_attr = member_die.attributes.get('DW_AT_data_member_location')
    if not loc_attr:
        return 0
    cls = describe_form_class(loc_attr.form)
    if cls == 'constant':
        try:
            return int(loc_attr.value)
        except Exception:
            return 0
    if cls == 'exprloc':
        try:
            parser = DWARFExprParser(member_die.cu.dwarfinfo.structs)
            ops = parser.parse_expr(loc_attr.value)
            offset = 0
            pending_const: Optional[int] = None
            for op in ops:
                name = op.op_name
                if name == 'DW_OP_plus_uconst':
                    offset += int(op.args[0])
                    continue
                if name in (
                    'DW_OP_constu', 'DW_OP_const1u', 'DW_OP_const2u',
                    'DW_OP_const4u', 'DW_OP_const8u'
                ):
                    pending_const = int(op.args[0])
                    continue
                lit_val = _decode_lit(name)
                if lit_val is not None:
                    pending_const = lit_val
                    continue
                if name in ('DW_OP_plus', 'DW_OP_add'):
                    if pending_const is not None:
                        offset += pending_const
                        pending_const = None
                    continue
            if offset == 0 and pending_const is not None:
                offset += pending_const
            return int(offset)
        except Exception:
            return 0
    return 0

def collect_dwarf_struct_vars(prefix, base_addr, die, rows, symbols_dict, filter_list, filter_hits):
    die = resolve_typedefs(die)
    if not die:
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), "unknown", "", "unknown"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": "unknown",
                "byte_size": "",
                "kind": "unknown"
            }
        return

    tag = die.tag

    if tag == 'DW_TAG_array_type':
        elem_die = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
        elem_die = resolve_typedefs(elem_die)
        etname, esize, etenc = base_type_info(elem_die)
        n = array_len_first_dim(die) or 0
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), f"array[{n}]", esize if esize else "", "array"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": f"array[{n}]",
                "byte_size": esize if esize else "",
                "kind": "array"
            }
        n_print = min(n, MAX_ARRAY)
        for i in range(n_print):
            eaddr = base_addr + i * (esize if esize else 1)
            array_elem_prefix = f"{prefix}._{i}_"
            if elem_die and elem_die.tag in ('DW_TAG_structure_type', 'DW_TAG_array_type'):
                collect_dwarf_struct_vars(array_elem_prefix, eaddr, elem_die, rows, symbols_dict, filter_list, filter_hits)
            else:
                if should_emit(array_elem_prefix, filter_list, filter_hits):
                    row = [array_elem_prefix, hex(eaddr), dwarf_type_to_str(etname, etenc, esize), esize if esize else "", "array_elem"]
                    rows.append(row)
                    symbols_dict[array_elem_prefix] = {
                        "address": hex(eaddr),
                        "type": dwarf_type_to_str(etname, etenc, esize),
                        "byte_size": esize if esize else "",
                        "kind": "array_elem"
                    }
        return

    if tag == 'DW_TAG_structure_type':
        _, tsize, _ = base_type_info(die)
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), "struct", tsize if tsize else "", "struct"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": "struct",
                "byte_size": tsize if tsize else "",
                "kind": "struct"
            }
        for child in die.iter_children():
            if child.tag != 'DW_TAG_member':
                continue
            mname_attr = child.attributes.get('DW_AT_name')
            mname = mname_attr.value.decode('utf-8', 'ignore') if mname_attr else '<anon>'
            off = _data_member_offset(child)
            mt = child.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in child.attributes else None
            if not mt:
                continue
            collect_dwarf_struct_vars(f"{prefix}.{mname}", base_addr + off, mt, rows, symbols_dict, filter_list, filter_hits)
        return

    if tag == 'DW_TAG_union_type':
        _, tsize, _ = base_type_info(die)
        if should_emit(prefix, filter_list, filter_hits):
            row = [prefix, hex(base_addr), "union", tsize if tsize else "", "union"]
            rows.append(row)
            symbols_dict[prefix] = {
                "address": hex(base_addr),
                "type": "union",
                "byte_size": tsize if tsize else "",
                "kind": "union"
            }
        for child in die.iter_children():
            if child.tag != 'DW_TAG_member':
                continue
            mname_attr = child.attributes.get('DW_AT_name')
            mname = mname_attr.value.decode('utf-8', 'ignore') if mname_attr else '<anon>'
            mt = child.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in child.attributes else None
            if not mt:
                continue
            collect_dwarf_struct_vars(f"{prefix}.{mname}", base_addr, mt, rows, symbols_dict, filter_list, filter_hits)
        return

    # leaf/base types
    tname, tsize, tenc = base_type_info(die)
    if should_emit(prefix, filter_list, filter_hits):
        row = [prefix, hex(base_addr), dwarf_type_to_str(tname, tenc, tsize), tsize if tsize else "", "variable"]
        rows.append(row)
        symbols_dict[prefix] = {
            "address": hex(base_addr),
            "type": dwarf_type_to_str(tname, tenc, tsize),
            "byte_size": tsize if tsize else "",
            "kind": "variable"
        }

def build_symbols_dict(elf_path: str, filter_list: Optional[List[str]]) -> Tuple[Dict[str, Dict[str, str]], Set[str]]:
    with open(elf_path, 'rb') as f:
        elf = ELFFile(f)
        symbols = get_symbols(elf)

        if not elf.has_dwarf_info():
            raise RuntimeError("No DWARF info found in ELF file.")

        if filter_list and len(filter_list) > 0:
            print("Filters provided:", ", ".join(filter_list))
        else:
            print("No filters provided; processing all symbols.")

        dwarfinfo = elf.get_dwarf_info()
        rows = []
        symbols_dict: Dict[str, Dict[str, str]] = {}
        filter_hits = {f: 0 for f in (filter_list or [])}

        for name, meta in sorted(symbols.items(), key=lambda kv: kv[1]['addr']):
            if filter_list and not should_traverse(name, filter_list):
                continue
            addr = meta['addr']
            found = False
            for cu in dwarfinfo.iter_CUs():
                for die in cu.iter_DIEs():
                    if die.tag != 'DW_TAG_variable':
                        continue
                    n = die.attributes.get('DW_AT_name')
                    if not n:
                        continue
                    vname = n.value.decode('utf-8', 'ignore')
                    if vname == name:
                        tdie = die.get_DIE_from_attribute('DW_AT_type') if 'DW_AT_type' in die.attributes else None
                        if tdie:
                            collect_dwarf_struct_vars(name, addr, tdie, rows, symbols_dict, filter_list, filter_hits)
                        else:
                            if should_emit(name, filter_list, filter_hits):
                                symbols_dict[name] = {
                                    "address": hex(addr),
                                    "type": "unknown",
                                    "byte_size": "",
                                    "kind": "unknown"
                                }
                        found = True
                        break
                if found:
                    break

        unmatched = {f for f, c in filter_hits.items() if c == 0}
        if filter_list:
            if unmatched:
                print("Warning: the following filters matched no symbols:")
                for f in unmatched:
                    print(f" - {f}")
            else:
                print("All filters matched at least one symbol.")

        return symbols_dict, unmatched

def _parse_hex_to_int(addr_hex) -> Optional[int]:
    if isinstance(addr_hex, int):
        return addr_hex
    if not isinstance(addr_hex, str):
        return None
    s = addr_hex.strip()
    try:
        if s.lower().startswith("0x"):
            return int(s, 16)
        return int(s, 16)
    except Exception:
        return None

def to_upper_hex(addr_hex: str) -> str:
    n = _parse_hex_to_int(addr_hex)
    if n is None:
        if isinstance(addr_hex, str) and addr_hex.strip().lower().startswith("0x"):
            return "0x" + addr_hex.strip()[2:].upper()
        return str(addr_hex)
    return f"0x{n:X}"

class A2LBlock:
    def __init__(self,
                 kind: str,
                 name: str,
                 symbol: str,
                 begin_idx: int,
                 end_idx: int,
                 addr_line_idx: Optional[int],
                 old_addr_int: Optional[int],
                 old_addr_hex: Optional[str]):
        self.kind = kind
        self.name = name
        self.symbol = symbol
        self.begin_idx = begin_idx
        self.end_idx = end_idx
        self.addr_line_idx = addr_line_idx
        self.old_addr_int = old_addr_int
        self.old_addr_hex = old_addr_hex

MEAS_BEGIN_RE = re.compile(r'^\s*/begin\s+MEASUREMENT\s+(\S+)')
CHAR_BEGIN_RE = re.compile(r'^\s*/begin\s+CHARACTERISTIC\s+(\S+)')
SYMBOL_LINK_RE = re.compile(r'^\s*SYMBOL_LINK\s+"([^"]+)"')
END_BLOCK_RE_TMPL = "/end {}"
ECU_ADDRESS_RE = re.compile(r'^(\s*ECU_ADDRESS\s+)(0x[0-9A-Fa-f]+)(.*)$')
VALUE_ADDR_RE  = re.compile(r'^(\s*VALUE\s+)(0x[0-9A-Fa-f]+)(.*)$')
ADDRESS_RE     = re.compile(r'^(\s*ADDRESS\s+)(0x[0-9A-Fa-f]+)(.*)$')
DEC_ANY_ADDR_RE = re.compile(r'^(\s*(?:ECU_ADDRESS|VALUE|ADDRESS)\s+)(\d+)(.*)$')

def parse_a2l_blocks(lines: List[str]) -> Tuple[List[A2LBlock], List[str]]:
    blocks: List[A2LBlock] = []
    filters: List[str] = []

    i = 0
    n = len(lines)
    while i < n:
        line = lines[i]

        m_meas = MEAS_BEGIN_RE.match(line)
        m_char = CHAR_BEGIN_RE.match(line)

        if m_meas or m_char:
            kind = "MEASUREMENT" if m_meas else "CHARACTERISTIC"
            name = (m_meas or m_char).group(1)
            begin_idx = i
            symbol_name = name
            addr_line_idx: Optional[int] = None
            old_addr_hex: Optional[str] = None
            old_addr_int: Optional[int] = None

            j = i + 1
            end_idx = None
            while j < n:
                l2 = lines[j]
                m_sym = SYMBOL_LINK_RE.match(l2)
                if m_sym:
                    symbol_name = m_sym.group(1).strip()
                if addr_line_idx is None:
                    m = ECU_ADDRESS_RE.match(l2) or VALUE_ADDR_RE.match(l2) or ADDRESS_RE.match(l2) or DEC_ANY_ADDR_RE.match(l2)
                    if m:
                        addr_line_idx = j
                        old_addr_hex = m.group(2)
                        try:
                            if old_addr_hex.lower().startswith("0x"):
                                old_addr_int = int(old_addr_hex, 16)
                            else:
                                old_addr_int = int(old_addr_hex, 10)
                        except Exception:
                            old_addr_int = None
                if l2.strip().lower() == END_BLOCK_RE_TMPL.format(kind.lower()):
                    end_idx = j
                    break
                j += 1
            if end_idx is None:
                end_idx = n - 1

            blocks.append(A2LBlock(kind=kind, name=name, symbol=symbol_name,
                                   begin_idx=begin_idx, end_idx=end_idx,
                                   addr_line_idx=addr_line_idx,
                                   old_addr_int=old_addr_int,
                                   old_addr_hex=old_addr_hex))

            if symbol_name not in filters:
                filters.append(symbol_name)

            i = end_idx + 1
            continue

        i += 1

    return blocks, filters

def force_uppercase_known_address_keywords(lines: List[str]) -> List[str]:
    out: List[str] = []
    for line in lines:
        raw = line.rstrip("\n")
        m = ECU_ADDRESS_RE.match(raw)
        if m:
            out.append(f"{m.group(1)}{to_upper_hex(m.group(2))}{m.group(3)}\n")
            continue
        m = ADDRESS_RE.match(raw)
        if m:
            out.append(f"{m.group(1)}{to_upper_hex(m.group(2))}{m.group(3)}\n")
            continue
        m = VALUE_ADDR_RE.match(raw)
        if m:
            out.append(f"{m.group(1)}{to_upper_hex(m.group(2))}{m.group(3)}\n")
            continue
        out.append(line)
    return out

def update_a2l_lines(lines: List[str], blocks: List[A2LBlock], addr_map: Dict[str, str]) -> Tuple[List[str], List[str]]:
    out_lines = list(lines)
    warnings: List[str] = []

    symbol_groups: Dict[str, List[A2LBlock]] = {}
    for b in blocks:
        symbol_groups.setdefault(b.symbol, []).append(b)

    for symbol, group in symbol_groups.items():
        addr_hex = addr_map.get(symbol)
        if not addr_hex:
            for b in group:
                warnings.append(f"No address found for symbol '{symbol}' (block {b.kind} {b.name}).")
            continue

        base_new_int = _parse_hex_to_int(addr_hex)
        if base_new_int is None:
            for b in group:
                warnings.append(f"Resolved address for symbol '{symbol}' is invalid: {addr_hex}")
            continue

        ref_old_int: Optional[int] = None
        for b in group:
            if b.old_addr_int is not None:
                ref_old_int = b.old_addr_int
                break

        multi = len(group) > 1 and ref_old_int is not None

        for b in group:
            if b.addr_line_idx is None:
                warnings.append(f"No address line found to update for symbol '{symbol}' (block {b.kind} {b.name}).")
                continue

            delta = 0
            if multi and b.old_addr_int is not None and ref_old_int is not None:
                delta = b.old_addr_int - ref_old_int

            new_addr_int = base_new_int + delta
            new_addr_hex = f"0x{new_addr_int:X}"

            old = out_lines[b.addr_line_idx].rstrip("\n")

            m = ECU_ADDRESS_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{new_addr_hex}{m.group(3)}"
                out_lines[b.addr_line_idx] = new_line + "\n"
                continue
            m = VALUE_ADDR_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{new_addr_hex}{m.group(3)}"
                out_lines[b.addr_line_idx] = new_line + "\n"
                continue
            m = ADDRESS_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{new_addr_hex}{m.group(3)}"
                out_lines[b.addr_line_idx] = new_line + "\n"
                continue
            m = DEC_ANY_ADDR_RE.match(old)
            if m:
                new_line = f"{m.group(1)}{new_addr_hex}{m.group(3)}"
                out_lines[b.addr_line_idx] = new_line + "\n"
                continue

            warnings.append(f"Could not update address line for symbol '{symbol}' (block {b.kind} {b.name}): '{old}'")

    out_lines = force_uppercase_known_address_keywords(out_lines)

    return out_lines, warnings

def _guess_datatype_and_limits(meta: Optional[Dict[str, str]]) -> Tuple[str, str, str, str]:
    t = (meta or {}).get("type", "") if meta else ""
    t = (t or "").lower()
    meas = "UBYTE"
    dep = "UByte_Value"
    lower = "0"
    upper = "255"

    if t in ("bool",):
        meas, dep, lower, upper = "UBYTE", "UByte_Value", "0", "1"
    elif t in ("ubyte", "uint8", "unsigned char"):
        meas, dep, lower, upper = "UBYTE", "UByte_Value", "0", "255"
    elif t in ("byte", "int8", "signed char"):
        meas, dep, lower, upper = "SBYTE", "SByte_Value", "-128", "127"
    elif t in ("ushort", "uint16", "unsigned short"):
        meas, dep, lower, upper = "UWORD", "UWord_Value", "0", "65535"
    elif t in ("short", "int16", "signed short"):
        meas, dep, lower, upper = "SWORD", "SWord_Value", "-32768", "32767"
    elif t in ("uint32", "unsigned int", "unsigned long"):
        meas, dep, lower, upper = "ULONG", "ULong_Value", "0", "4294967295"
    elif t in ("int32", "signed int", "long", "int"):
        meas, dep, lower, upper = "SLONG", "SLong_Value", "-2147483648", "2147483647"
    elif "float" in t:
        meas, dep, lower, upper = "FLOAT32", "Float_Value", "-3.402823e+38", "3.402823e+38"

    return meas, dep, lower, upper

def _render_new_block(variablename: str, kind: str, addr_hex: str, meta: Optional[Dict[str, str]]) -> List[str]:
    meas_dt, char_dep, lower, upper = _guess_datatype_and_limits(meta)
    addr_hex_up = to_upper_hex(addr_hex)
    lines: List[str] = []
    if kind == "MEASUREMENT":
        lines.extend([
            f'/begin MEASUREMENT {variablename} ""\n',
            f'  {meas_dt} NO_COMPU_METHOD 0 0 {upper}\n',
            f'  ECU_ADDRESS {addr_hex_up}\n',
            f'  SYMBOL_LINK "{variablename}" 0\n',
            f'/end MEASUREMENT\n',
        ])
    else:
        lines.extend([
            f'/begin CHARACTERISTIC {variablename} ""\n',
            f'  VALUE {addr_hex_up} {char_dep} 0 NO_COMPU_METHOD 0 {upper}\n',
            f'  SYMBOL_LINK "{variablename}" 0\n',
            f'/end CHARACTERISTIC\n',
        ])
    return lines

def _normalize_variablename_input(variablename: Union[str, List[str]]) -> List[str]:
    names: List[str] = []
    if isinstance(variablename, (list, tuple, set)):
        names = [str(x).strip() for x in variablename if str(x).strip()]
    elif isinstance(variablename, str):
        s = variablename.strip()
        if s.startswith("[") and s.endswith("]"):
            try:
                parsed = ast.literal_eval(s)
                if isinstance(parsed, (list, tuple, set)):
                    names = [str(x).strip() for x in parsed if str(x).strip()]
                else:
                    names = [s]
            except Exception:
                names = [p.strip() for p in s.strip("[]").split(",") if p.strip()]
        elif "," in s:
            names = [p.strip() for p in s.split(",") if p.strip()]
        elif s:
            names = [s]
    seen = set()
    uniq = []
    for n in names:
        if n not in seen:
            seen.add(n)
            uniq.append(n)
    return uniq

def _find_insert_position_after_kind(lines: List[str], blocks: List[A2LBlock], kind: str) -> int:
    last_end = -1
    for b in blocks:
        if b.kind == kind and b.end_idx > last_end:
            last_end = b.end_idx
    if last_end >= 0:
        return last_end + 1
    return len(lines)

def Updatea2l(olda2l: str, elf: str, newa2l: str) -> None:
    with open(olda2l, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    blocks, filters = parse_a2l_blocks(lines)
    if not blocks:
        print("No MEASUREMENT or CHARACTERISTIC blocks found in A2L.")
    else:
        print(f"Found {len(blocks)} blocks to process.")
    if filters:
        print("Symbols to resolve from ELF:")
        for s in filters:
            print(f" - {s}")

    symbols_dict, missing_filters = build_symbols_dict(elf, filters)
    addr_map = {name: to_upper_hex(meta["address"]) for name, meta in symbols_dict.items()}
    print(f"Resolved {len(addr_map)} symbol addresses from ELF/DWARF.")

    updated_lines, warnings = update_a2l_lines(lines, blocks, addr_map)

    for w in warnings:
        print("Warning:", w)
    if missing_filters:
        print("These A2L symbols were not found in ELF/DWARF:")
        for s in sorted(missing_filters):
            print(f" - {s}")

    with open(newa2l, "w", encoding="utf-8", errors="ignore") as f:
        f.writelines(updated_lines)
    print(f"Saved updated A2L to: {newa2l}")

def addvariable(olda2l: str, elf: str, variablename: Union[str, List[str]], vartype: str, outputfile: str) -> None:
    kind = (vartype or "").strip().upper()
    if kind not in ("CHARACTERISTIC", "MEASUREMENT"):
        raise ValueError("vartype must be 'characteristic' or 'measurement'")

    with open(olda2l, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    blocks, filters = parse_a2l_blocks(lines)
    existing_symbols = {b.symbol for b in blocks}

    extra_filters = _normalize_variablename_input(variablename)
    for tok in extra_filters:
        if tok not in filters:
            filters.append(tok)

    print(f"Starting 'addvariable' with {len(filters)} filter token(s).")
    if extra_filters:
        print("- Added filter token(s):", ", ".join(extra_filters))

    symbols_dict, missing_filters = build_symbols_dict(elf, filters)
    addr_map = {name: to_upper_hex(meta["address"]) for name, meta in symbols_dict.items()}
    print(f"Resolved {len(addr_map)} addresses from ELF.")

    updated_lines, warnings = update_a2l_lines(lines, blocks, addr_map)
    for w in warnings:
        print("Warning:", w)

    missing_symbols = [
        name for name, meta in symbols_dict.items()
        if name not in existing_symbols and meta.get("kind") not in ("struct", "array", "union")
    ]

    if not missing_symbols:
        print("No new filtered symbols to add; only addresses were updated.")
        with open(outputfile, "w", encoding="utf-8", errors="ignore") as f:
            f.writelines(updated_lines)
        print(f"Saved updated A2L to: {outputfile}")
        return

    print(f"Adding {len(missing_symbols)} new {kind} block(s) for filtered symbols not present in A2L.")

    insert_lines: List[str] = []
    for idx, name in enumerate(sorted(missing_symbols)):
        meta = symbols_dict.get(name, {})
        addr_hex = to_upper_hex(meta.get("address", "0x0"))
        block_lines = _render_new_block(name, kind, addr_hex, meta)
        insert_lines.extend(block_lines)
        if idx != len(missing_symbols) - 1:
            insert_lines.append("\n")

    insert_idx = _find_insert_position_after_kind(updated_lines, blocks, kind)

    if insert_idx > 0:
        prev_line = updated_lines[insert_idx - 1]
        if prev_line.strip() != "":
            updated_lines[insert_idx:insert_idx] = ["\n"]
            insert_idx += 1
        else:
            k = insert_idx - 1
            while k - 1 >= 0 and updated_lines[k - 1].strip() == "":
                del updated_lines[k - 1]
                insert_idx -= 1
                k -= 1

    updated_lines[insert_idx:insert_idx] = insert_lines
    updated_lines = force_uppercase_known_address_keywords(updated_lines)

    with open(outputfile, "w", encoding="utf-8", errors="ignore") as f:
        f.writelines(updated_lines)
    print(f"Appended {len(missing_symbols)} new {kind} block(s) after last {kind} section and saved to: {outputfile}")

def _main(argv: List[str]) -> int:
    if len(argv) < 2:
        print(f"Usage:\n"
              f"  {argv[0]} update <olda2l> <elf> <newa2l>\n"
              f"  {argv[0]} add <olda2l> <elf> <variablename|list> <characteristic|measurement> <outputfile>\n\n"
              f"Notes:\n"
              f"- 'add' updates addresses for existing blocks AND appends ALL filtered symbols missing from the A2L.\n"
              f"- Filters = all symbols referenced in the A2L + provided variablename(s).\n"
              f"- variablename can be a comma-separated list (A,B,C) or a JSON-like list string (e.g., [\"A\",\"B\"]).\n"
              f"- New MEASUREMENT/CHARACTERISTIC blocks are inserted right after the last block of the same kind.\n"
              f"- All ECU_ADDRESS/ADDRESS/VALUE addresses are emitted in uppercase hex.\n"
              f"- Recurring symbols: per-block address deltas relative to the first occurrence are preserved on update.")
        return 1

    cmd = argv[1].lower()
    if cmd == "update":
        if len(argv) < 5:
            print(f"Usage: {argv[0]} update <olda2l> <elf> <newa2l>")
            return 1
        _, _, olda2l, elf, newa2l = argv[:5]
        Updatea2l(olda2l, elf, newa2l)
        return 0

    if cmd == "add":
        if len(argv) < 7:
            print(f"Usage: {argv[0]} add <olda2l> <elf> <variablename|list> <characteristic|measurement> <outputfile>")
            return 1
        _, _, olda2l, elf, variablename_arg, vartype, outputfile = argv[:7]
        variablename_list = _normalize_variablename_input(variablename_arg)
        addvariable(olda2l, elf, variablename_list, vartype, outputfile)
        return 0

    print(f"Unknown command: {cmd}")
    return 1

if __name__ == "__main__":
    sys.exit(_main(sys.argv))
