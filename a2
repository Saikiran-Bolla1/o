#!/usr/bin/env python3
"""
merge_a2l_elf_multi.py

Usage:
    pip install pyelftools
    python merge_a2l_elf_multi.py input.a2l input.elf output.a2l

Features:
 - Updates MEASUREMENT, CHARACTERISTIC, AXIS_PTS blocks by replacing addresses
   with addresses derived from ELF symbols (case-insensitive matching).
 - Configurable block list.
 - Reports names present in A2L but missing in ELF.
"""
import re
import sys
from collections import defaultdict
from elftools.elf.elffile import ELFFile

# ----------------------------
# Configuration
# ----------------------------
# Blocks to scan / update. Add more block names if needed.
BLOCKS_TO_UPDATE = ["MEASUREMENT", "CHARACTERISTIC", "AXIS_PTS"]

# A2L name normalization for matching (lowercase by default)
def norm_name(n):
    return n.lower()

# ----------------------------
# ELF parsing
# ----------------------------
def read_elf_symbols(elf_path):
    symbols = {}
    with open(elf_path, "rb") as f:
        elffile = ELFFile(f)
        symtab = elffile.get_section_by_name(".symtab")
        if not symtab:
            # Some linkers put symbols elsewhere; try dynamic symbol table
            symtab = elffile.get_section_by_name(".dynsym")
        if not symtab:
            raise RuntimeError("No symbol table (.symtab or .dynsym) found in ELF file!")
        for symbol in symtab.iter_symbols():
            name = symbol.name
            addr = symbol['st_value']
            # store only meaningful symbol addresses
            if name and addr is not None and addr != 0:
                symbols[norm_name(name)] = addr
    return symbols

# ----------------------------
# Helpers for address formatting/parsing
# ----------------------------
def format_addr_hex(addr):
    return f"0x{addr:X}"

hex_or_dec_re = re.compile(r"(0x[0-9A-Fa-f]+|\d+)")

# ----------------------------
# Update logic for single-line blocks (MEASUREMENT / CHARACTERISTIC)
# Typical A2L line (one-line): /begin MEASUREMENT VarName ... 0x1234 ...
# ----------------------------
single_line_pattern_template = r"(/begin\s+{block}\s+)(\S+)(.*?)(0x[0-9A-Fa-f]+|\d+)(.*)"

def update_single_line_blocks(lines, elf_symbols, block, updated_names, missing_names):
    pattern = re.compile(single_line_pattern_template.format(block=block), re.IGNORECASE)
    for i, line in enumerate(lines):
        m = pattern.match(line)
        if m:
            prefix, var_name, before_addr, old_addr, after_addr = m.groups()
            key = norm_name(var_name)
            if key in elf_symbols:
                new_addr = format_addr_hex(elf_symbols[key])
                lines[i] = f"{prefix}{var_name}{before_addr}{new_addr}{after_addr}\n"
                updated_names.append(var_name)
            else:
                missing_names.append(var_name)

# ----------------------------
# Update logic for AXIS_PTS (stateful block scan)
# We'll find "/begin AXIS_PTS <Name> ..." where the address might be on the same
# line or on a following line inside the block. We update the first numeric token
# that looks like an address on that begin-line or within the block.
# ----------------------------
axis_begin_pattern = re.compile(r"(/begin\s+AXIS_PTS\s+)(\S+)(.*)", re.IGNORECASE)
axis_end_pattern = re.compile(r"/end\s+AXIS_PTS", re.IGNORECASE)

def update_axis_pts_blocks(lines, elf_symbols, updated_names, missing_names):
    i = 0
    n = len(lines)
    while i < n:
        line = lines[i]
        mb = axis_begin_pattern.match(line)
        if mb:
            prefix, var_name, rest = mb.groups()
            key = norm_name(var_name)
            # Search for an address token on this line first
            addr_match = hex_or_dec_re.search(line)
            updated = False
            if key in elf_symbols:
                new_addr = format_addr_hex(elf_symbols[key])
                if addr_match:
                    # replace the first address-like token on the begin line
                    start, end = addr_match.span()
                    newline = line[:start] + new_addr + line[end:]
                    lines[i] = newline if newline.endswith("\n") else newline + "\n"
                    updated_names.append(var_name)
                    updated = True
                else:
                    # look forward inside block until /end AXIS_PTS and replace first address-like token
                    j = i + 1
                    while j < n and not axis_end_pattern.search(lines[j]):
                        am = hex_or_dec_re.search(lines[j])
                        if am:
                            s, e = am.span()
                            newline = lines[j][:s] + new_addr + lines[j][e:]
                            lines[j] = newline if newline.endswith("\n") else newline + "\n"
                            updated_names.append(var_name)
                            updated = True
                            break
                        j += 1
                    # if not found inside block, append a comment line with address (safe fallback)
                    if not updated:
                        insert_line = f"  /* ADDED_ADDR {new_addr} */\n"
                        lines.insert(i+1, insert_line)
                        n += 1
                        updated_names.append(var_name)
                        updated = True
            else:
                # not found in ELF; record as missing but still continue scanning to /end
                missing_names.append(var_name)
            # advance to after the /end AXIS_PTS
            k = i + 1
            while k < n and not axis_end_pattern.search(lines[k]):
                k += 1
            i = k + 1
            continue
        i += 1

# ----------------------------
# Main merge routine
# ----------------------------
def merge_a2l_with_elf(a2l_path, elf_symbols, output_path):
    with open(a2l_path, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    updated_names = []
    missing_names = []

    # Update MEASUREMENT and CHARACTERISTIC using single-line style
    for block in ["MEASUREMENT", "CHARACTERISTIC"]:
        update_single_line_blocks(lines, elf_symbols, block, updated_names, missing_names)

    # Update AXIS_PTS (stateful)
    update_axis_pts_blocks(lines, elf_symbols, updated_names, missing_names)

    # Write merged output
    with open(output_path, "w", encoding="utf-8") as f:
        f.writelines(lines)

    # Summaries
    unique_updated = sorted(set(updated_names))
    unique_missing = sorted(set(missing_names))

    print(f"[INFO] Updated {len(unique_updated)} unique A2L entries.")
    print(f"[INFO] Wrote merged A2L -> {output_path}")
    if unique_missing:
        print(f"[WARN] {len(unique_missing)} A2L names were not found in ELF:")
        for nm in unique_missing:
            print("   -", nm)
    else:
        print("[INFO] All A2L names we tried were found in the ELF.")

# ----------------------------
# CLI
# ----------------------------
if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: python merge_a2l_elf_multi.py <input.a2l> <input.elf> <output.a2l>")
        sys.exit(1)

    a2l_file = sys.argv[1]
    elf_file = sys.argv[2]
    out_file = sys.argv[3]

    print("[INFO] Reading ELF symbols...")
    elf_syms = read_elf_symbols(elf_file)
    print(f"[INFO] ELF symbols loaded: {len(elf_syms)}")

    print("[INFO] Merging A2L (MEASUREMENT / CHARACTERISTIC / AXIS_PTS)...")
    merge_a2l_with_elf(a2l_file, elf_syms, out_file)
